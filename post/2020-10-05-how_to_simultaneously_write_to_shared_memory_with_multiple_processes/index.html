
<!DOCTYPE html>
<html
  lang="en"
  data-figures=""
  
    class="page"
  
  
  >
  <head>
<title>How to simultaneously write to shared memory with multiple processes | Matt&#39;s Tech Blog</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="en" />

<meta property="og:type" content="article">
<meta name="description" content="Most of our modern day computers have more than one processing unit. They are often referred to as cores. For a developer, effectively using multiple cores …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="@coming_soon">
<meta name="twitter:title" content="How to simultaneously write to shared memory with multiple processes" />
<meta name="twitter:image" content="https://mmlind.github.io/images/thumbnail.png"/>
<meta property="og:url" content="https://mmlind.github.io/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes/" />
<meta property="og:title" content="How to simultaneously write to shared memory with multiple processes" />
<meta property="og:description" content="Most of our modern day computers have more than one processing unit. They are often referred to as cores. For a developer, effectively using multiple cores …" />
<meta property="og:image" content="https://mmlind.github.io/images/thumbnail.png" />
  <meta name="keywords" content="ai,machine learning,nlp,nlm,large language models" />

<link rel="apple-touch-icon" sizes="180x180" href="https://mmlind.github.io/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mmlind.github.io/icons/favicon-32x32.png">
<link rel="manifest" href="https://mmlind.github.io/icons/site.webmanifest">

<link rel="canonical" href="https://mmlind.github.io/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes/">



<link rel="preload" href="https://mmlind.github.io/css/styles.5bbdaff74df43ad3301fd1da44a332ca19afbd2dbb8c4f1e6c7fb5da394229112d9972011fedf21ba2cbd401586281122a5901efade33dec7837cceff22fa6ad.css" integrity = "sha512-W72v9030OtMwH9HaRKMyyhmvvS27jE8ebH&#43;12jlCKREtmXIBH&#43;3yG6LL1AFYYoESKlkB763jPex4N8zv8i&#43;mrQ==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://mmlind.github.io/en/js/bundle.f4da32c64ece1e7d5a836039ceed09b7e4f3592da2a593a2c0e74dd8b24aef5d873eea6fcf180b171a60c193c271d3f845628a40d93531f8e49a553ed23162cd.js" as="script" integrity=
"sha512-9Noyxk7OHn1ag2A5zu0Jt&#43;TzWS2ipZOiwOdN2LJK712HPupvzxgLFxpgwZPCcdP4RWKKQNk1MfjkmlU&#43;0jFizQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://mmlind.github.io/css/styles.5bbdaff74df43ad3301fd1da44a332ca19afbd2dbb8c4f1e6c7fb5da394229112d9972011fedf21ba2cbd401586281122a5901efade33dec7837cceff22fa6ad.css" integrity="sha512-W72v9030OtMwH9HaRKMyyhmvvS27jE8ebH&#43;12jlCKREtmXIBH&#43;3yG6LL1AFYYoESKlkB763jPex4N8zv8i&#43;mrQ==" crossorigin="anonymous">

  </head>
  <body
    data-code="7"
    data-lines="false"
    id="documentTop"
    data-lang="en"
  >

<header class="nav_header" >
  <nav class="nav"><a href='https://mmlind.github.io/' class="nav_brand nav_item" title="Matt&#39;s Tech Blog">
  <img src="https://mmlind.github.io/logos/logo.png" class="logo" alt="Matt&#39;s Tech Blog">
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://mmlind.github.io/" class="nav_item" title="Blog">Blog </a>
  </div>
  <div class="nav_parent">
    <a href="https://mmlind.github.io/about/" class="nav_item" title="About">About </a>
  </div>
      
      <div class="nav_parent">
        <a href="#" class="nav_item"></a>
        <div class="nav_sub">
          <span class="nav_child"></span>
          
          <a href="https://mmlind.github.io/" class="nav_child nav_item">English</a>
          
          <a href="https://mmlind.github.io/de/" class="nav_child nav_item">Deutsch</a>
          
        </div>
      </div>
<div class='follow'>
  <a href="https://github.com/#">
    <svg class="icon">
  <title>github</title>
  <use xlink:href="#github"></use>
</svg>

  </a>
  <a href="https://cn.linkedin.com/in/mmlind">
    <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

  </a>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title">How to simultaneously write to shared memory with multiple processes</h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Oct 5, 2020</span>
    <span class="post_time"> · 20 min read</span><span>&nbsp;· <a href='https://mmlind.github.io/tags/multiprocessing/' title="MULTIPROCESSING" class="post_tag button button_translucent">MULTIPROCESSING
        </a><a href='https://mmlind.github.io/tags/c/' title="C" class="post_tag button button_translucent">C
        </a>
    </span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    Share on:
    <a href="https://twitter.com/intent/tweet?text=How%20to%20simultaneously%20write%20to%20shared%20memory%20with%20multiple%20processes&url=https%3a%2f%2fmmlind.github.io%2fpost%2f2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fmmlind.github.io%2fpost%2f2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes%2f&t=How%20to%20simultaneously%20write%20to%20shared%20memory%20with%20multiple%20processes" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://mmlind.github.io/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><p>Most of our modern day computers have more than one processing unit. They are often referred to as <em>cores</em>. For a developer, effectively using multiple cores simultaneously to speed up program execution by parallel processing comes with challenges. One of them is changing the value of a variable in shared memory.</p>
<p>In this blog post I introduce one of the two most common methods to overcome this problem by synchronizing access to shared memory: <code>fork</code> and <code>semaphores</code>. (The other option would be <code>pthreads</code> and <code>mutexes</code>.)</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt=""
      
        class="image_figure image_internal image_unprocessed"
        src="multiprocess_memory.png"
      
      
    />

    </picture>
</figure>
</p>
<h2 id="parallel-processing">Parallel processing</h2>
<p>Most computers nowadays come with a multi-core processor. In fact, the Mac that I’m using to write this blog on comes with 6 cores. At least that’s what the system configuration menu tells me:</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt=""
      
        class="image_figure image_internal image_unprocessed"
        src="mac_sysinfo.png"
      
      
    />

    </picture>
</figure>
</p>
<p>Does this mean that all software runs 6 times as fast? Unfortunately not. Only a small subset of all software effectively leverages the enourmous computing power that modern laptops and desktops possess. Why? Writing software that executes multiple tasks in parallel is significantly more complex than solving the same problem sequentially.</p>
<h3 id="how-many-cores-does-my-computer-have">How many cores does my computer have?</h3>
<p>At this point, you may want to know how many cores or processing units your computer is equipped with. To retrieve the number of processing units you can use the following ‘C’ code</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">long</span> <span class="n">nproc</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_NPROCESSORS_ONLN</span><span class="p">);</span>
</span></span></code></pre></div><p>which, in my case, returns ... <strong>12</strong>. Why the difference to the 6 cores that were reported by the system configuration above? <a href="https://de.wikipedia.org/wiki/Hyper-Threading">Hyperthreading</a>. 6 <strong>physical</strong> cores inside the computer are presented as 12 <strong>virtual</strong> cores to the operating system.</p>
<h3 id="multiprocessing-and-multithreading">Multiprocessing and multithreading</h3>
<p>The 2 main technical options for a developer to implement parallel processing are <strong>multiprocessing</strong> and <strong>multithreading</strong>. Both allow to execute multiple tasks simultaneously by spinning-off separate <strong>processes</strong> or <strong>threads</strong> that run independently of the main process.</p>
<p>Beware that in both methods tasks really run “simultaneously”, or in parallel, only if there is more than 1 processing unit. If you run multiple processes or threads on a single core computer, all tasks are in the end still executed sequentially, one after the other, by the same (aka. only) processor without any gain in performance.</p>
<p>Also, be aware that task scheduling is done by the operating system, not by the application. Thus, as a developer you cannot decide what task, no matter whether it’s a <strong>process</strong> or a <strong>thread</strong>, is run by what core. In fact, if you run multiple tasks there is no guarantee at all that each of these tasks will actually run on a different processing unit. Fortunately, modern operating systems allocate the workload evenly, hence in practice your processes are typically allocated to different processing units.</p>
<h3 id="challenges-of-parallel-processing">Challenges of parallel processing</h3>
<p>To effectively use multiple cores in an application, the first thing a developer needs to do is to adapt the application logic or flow. Simply running the same algorithm on a multiple cores machine will not result in any performance improvement. Further down below I will provide an example for such a change in application logic.</p>
<p>Second, you will need your multiple processes or threads to exchange information or to communicate with each other. This is called IPC or inter process communication. The most common techniques to support IPC are typically either based on messaging or on memory. Messaging based techniques include <strong>SIGNALs</strong> and <strong>PIPEs</strong>. Information is sent as messages from one task to another.</p>
<p>In this post I want to explore the memory based approach. Instead of multiple tasks exchanging messages they communicate by writing information to memory that can be read by other tasks. In most cases this method is faster than messaging via PIPEs or SIGNALs.</p>
<p>Yet, this method comes with one big caveat. If multiple tasks write to the same shared memory at the same time they may conflict with each other. This is called a race condition because the tasks run in parallel, like multiple runners in a race, and you cannot predict which runner wins, i.e. you don’t know the order in which these tasks are executed.</p>
<p>To overcome this problem of race conditions we therefore need to synchronize any write access to shared memory. Let’s look at a simple example to demonstrate this:</p>
<h3 id="a-simple-problem--solved-with-a-single-process">A simple problem – solved with a single process</h3>
<p>Let’s say we have a large array of random integers between 0-9 and we want to calculate the frequency of each digit. How many 1s, 2s, 3s…. etc are there in the array. It’s a very simple problem that is solved in 2 steps.</p>
<p>First, create the array with the random numbers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="c1">// create a large array of random numbers between 0-9
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">long</span> <span class="n">arrlen</span>  <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>        <span class="c1">// arbitrary length of the array
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span>  <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">// there are 10 digits [0-9]
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">    <span class="kt">long</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arrlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">ndigits</span><span class="p">;</span>
</span></span></code></pre></div><p>Second, count the frequencies per digit:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="c1">// count the frequency of each digit in the array
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_sp</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ndigits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span> <span class="c1">// frequency counter per digit [single process]
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="n">freq_sp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>Since this is a very simple calculation, it would take less than 1 second to complete. For the purpose of this demo, I simulate a more complex algorithm that takes longer to complete by simply adding a <code>usleep</code> pause of 0.1 milliseconds into the loop.</p>
<p>At the end, we want to confirm the calculation. The <code>sum</code> of all frequencies should match <code>arrlen</code>. Consider this a checksum that we want to refer to further later.</p>
<p>Let’s also time the calculation and output the number of seconds the whole algorithm took to complete:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="kt">long</span> <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies: %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
</span></span></code></pre></div><p>If you put the pieces of code above together and run it your output should look similar to this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Sum of all frequencies:        100,000 (13 sec)
</span></span></code></pre></div><p>A single process took about 13 seconds to complete this calculation. (The time on your computer may vary. But the time obviously will always be 10+ seconds since we added 100,000 times a pause of 0.1 milliseconds which translates into 10 seconds.)</p>
<h3 id="solving-the-problem-with-multiple-processes">Solving the problem with multiple processes</h3>
<p>Now, let’s see whether we can speed-up this calculation if we use <strong>multiprocessing</strong>.</p>
<p>As I mentioned above, the first thing to do for multiprocessing is to adapt the logic or flow of the application. We need to find instructions that can be effectively run in parallel without affecting the result.</p>
<p>In our simple example we run a <code>for</code> loop from <code>1</code> to <code>arrlen</code>. If multiple processes all were to run this same loop we would not only get a different result but we would also likely end up with an even slower algorithm.</p>
<p>Instead, we split the array into segments and let each process calculate the digit frequencies of the numbers in that particular segment. So, if we assume that we want to run 2 processes in parallel, then process #1 would work on segment [0..49,000] and process #2 would work on segment [50,000..99,999]. The same logic applies to any other number of processes that you may want to run in parallel. The more processes, the more segments.</p>
<p>The resulting code for this new logic should look something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl">    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of processes to run simultaneously
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="c1">// define a segment that each process works on independently
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>        <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">             <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span></code></pre></div><p>So, almost there. But something is still missing. Above code is still executed by a single process. How to create 2 or more processes that run in parallel, and then make each process work on a different segment of the array?</p>
<p>The 2 most common techniques to run multiple tasks in parallel are <code>fork</code> and <code>pthread</code>. While the former basically clones your whole program (aka. process), the latter spins off a new thread within the current process. Therefore, when we’re using <code>fork</code> we’re talking about <strong>multiprocessing</strong>, and when we’re using pthread we’re talking about <strong>multithreading</strong>.</p>
<p>I won’t go into much detail about the difference between the two. There are abundant online resources on this topic. Put simply, you can think of the following analogy:</p>
<p>Think of your program as a worker. <code>fork</code> clones this worker and gives you 2 independent workers that both handle the workload in parallel. <code>pthread</code> on the other side grows your worker a new pair of arms Each pair works independently but is still part of the same body and controlled by the same brain.</p>
<h3 id="multiprocessing-using-fork">Multiprocessing using <code>fork</code></h3>
<p>Citing from its <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">man page</a> <code>fork</code> <em>“creates a new process by duplicating the calling process. The new process is referred to as the child process. The calling process is referred to as the parent process.”</em></p>
<p>I recommend reading the man page and doing some of the many online tutorials on fork before you continue. The usage of fork and understanding the resulting program logic can be a bit tricky in the beginning, especially if you fork multiple times.</p>
<p>Below code shows a useful generic structure that can be widely applied whenever you want to do multiprocessing. It runs any task <code>nproc</code> times in parallel by creating <code>nproc</code> child processes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl">    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">         
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">             
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">             <span class="c1">// code that shall be executed by each child process
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>             
</span></span><span class="line"><span class="ln">11</span><span class="cl">             <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello! I am process [%d].</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">             <span class="c1">/// ...
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>             
</span></span><span class="line"><span class="ln">15</span><span class="cl">             
</span></span><span class="line"><span class="ln">16</span><span class="cl">             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">         
</span></span><span class="line"><span class="ln">19</span><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="c1">// wait for all child processes to finish
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// parent process proceeds....
</span></span></span></code></pre></div><p>Please note that at the end the parent process waits until all child processes have exited and only then resumes the program flow. Not waiting for child processes to finish is often a source of errors.</p>
<p>The <code>wait</code> command also gives you the opportunity to bring the application logic back into a single process. Often this is needed, for example when only a certain part of your application logic can be parallelized. When this part is completed, you want to proceed sequentially. Using</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>allows you to do so.</p>
<p>Also, beware that in above generic code structure <code>nproc</code> represents the number of processes, not the number of processors. You could run more processes than there are actual processing units.</p>
<h3 id="simple-problem-using-multiprocessing">Simple problem using multiprocessing</h3>
<p>Now, let’s put it all together. Let’s apply the above multiprocessing code structure to our problem of calculating the frequencies of random digits:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl">    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of child processes to run simultaneously
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">         
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>  <span class="c1">// exit if fork was not successful
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// define what each child process will do
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">             
</span></span><span class="line"><span class="ln">13</span><span class="cl">             <span class="c1">// define a segment that each child process works on independently
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>             <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">             <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">             
</span></span><span class="line"><span class="ln">17</span><span class="cl">             <span class="c1">// sum up the frequencies in this segment of the array
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">             <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">              
</span></span><span class="line"><span class="ln">23</span><span class="cl">             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">         
</span></span><span class="line"><span class="ln">26</span><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="c1">// wait for all child processes to finish
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="c1">// calculating the sum of all frequencies to check     
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="c1"></span>    <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_mp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies: %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
</span></span></code></pre></div><p>If you add this code to your previous code and run it alltogether you should see something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Sum of all frequencies (single process) :        100,000 (13 sec)
</span></span><span class="line"><span class="ln">2</span><span class="cl">Sum of all frequencies (multiprocessing):              0 (6 sec)
</span></span></code></pre></div><p>The second calculation, using multiprocessing, required only 6 seconds versus 13 seconds for the single process calculation. However, the sum of the frequencies, which serves as our checksum to verify that our calculation worked correctly, now returns a 0 instead of the expected 100,000. Why?</p>
<h3 id="shared-memory-for-ipc">Shared memory for IPC</h3>
<p>In the above code I purposely didn’t include the definition of the <code>freq_mp</code> variable. If you defined it using <code>malloc</code>, same as we did previously for a single process, you will end up with this wrong result. The problem is that once you forked the current process, each resulting child process will have a separate copy of all variables of the parent process. If the child process changes any of those variables, those changes have no impact on the original variable in the parent process. So when the child processes were incrementing <code>freq_mp</code> those changes did not affect the copy of <code>freq_mp</code> in the parent process which however is the one that we sum up at the end.</p>
<p>To solve this problem, we need to define <code>freq_mp</code> as shared memory that can be accessed, and in particular written to, by both parent and child process. I do this with <code>mmap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="c1">// define a shared memory to store the frequency counters
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_mp</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">freq_mp</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;mmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span></code></pre></div><p>Now, all child processes can write to <code>freq_mp</code> and their changes can be read by the parent process. Actually, not only by the parent process but also by all other child processes.</p>
<p>When the shared memory is not used anymore you don’t <code>free</code> it as you would for <code>malloc</code> allocated variables. Instead, the corresponding method for shared memory created with <code>mmap</code> is <code>munmap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">freq_mp</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;munmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>   
</span></span></code></pre></div><p>Therefore, make sure you add the above at the end of your code.</p>
<p>Great. So let’s see what happens. Let’s run the code again, using <strong>multiprocessing</strong> and this time using <strong>shared memory</strong>. If you do so, you will see an output that looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Sum of all frequencies (single process) :        100,000 (13 sec)
</span></span><span class="line"><span class="ln">2</span><span class="cl">Sum of all frequencies (multiprocessing):         99,988 (6 sec)
</span></span></code></pre></div><p>Wow! What is this?! Now, our multiprocessing <strong>did</strong> calculate the frequencies, however the sum of those frequencies mystically is <strong>not</strong> correct. The sum that was calculated by multiple processes in parallel is <strong>not</strong> equal to the sum that a single process calculated. (In your own testing you may see a smaller or larger difference, or in fact, you may see no difference at all. But, in general, very likely you <strong>will</strong> see a difference, and the larger the array the larger the difference.)</p>
<p>What happened?</p>
<h3 id="remember-race-conditions">Remember race conditions?</h3>
<p>The problem with the above code is that multiple processes try to write to the same shared memory at the same time. This causes some of the writes getting <strong>lost</strong> or <strong>cancelled out</strong>.</p>
<p>To avoid this problem we need to <strong>synchronize</strong> the <strong>writes</strong>. Without synchronization there is no guarantee that all writes are successfully completed.</p>
<h2 id="synchronizing-memory-writes-for-multiprocessing">Synchronizing memory writes for multiprocessing</h2>
<p>Synchronizing writes means that if one process writes to a variable in shared memory, this process locks the variable first so that no other process can write to it. After the writing is complete, the process <strong>unlocks</strong> or <strong>releases</strong> the shared memory and only then another process will be able to write to it. In short, what we need is a mutually exclusive write.</p>
<p>The 2 most common techniques to synchronize memory access are <code>semaphores</code> and <code>mutexes</code>. You can think of both as some low-level registers that can be set to a certain value, and then depending on that value either allow or block access to a resource.</p>
<p><strong>Semaphores</strong> are more powerful, can be used across processes, and support incrementing values instead of simply setting a binary 0 or 1. They behave like ‘counting locks’ that only open if their value is 1. Semaphores are defined in sets of arbitrary length. Each set is identified by its unique ID.</p>
<p>In our example, I use ‘semaphores’ as simple on/off switches, similar to mutexes. Altogether, we need the following 5 steps to use semaphores effectively:</p>
<h4 id="step-1-define">Step 1: Define</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</span></span></code></pre></div><p>This will create a new semaphore set with 1 semaphore.</p>
<h4 id="step-2-initialize">Step 2: Initialize</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released/unlocked
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
</span></span></code></pre></div><p>This will set the initial value of the semaphore to 1, which means it’s unlocked.</p>
<h4 id="step-3-lock">Step 3: Lock</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// lock the semaphore
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>Before any process writes to the shared variable, use <code>semop</code> to lock the semaphore.</p>
<p>This will automatically block other processes that attempt to write to this variable. Those processes are made wait until the semaphore is unlocked.</p>
<h4 id="step-4-releaseunlock">Step 4: Release/Unlock</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// release/unlock the semaphore
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>After a process has completed writing to the shared variable, use <code>semop</code> to unlock the semaphore.</p>
<h4 id="step-5-remove">Step 5: Remove</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">);</span>
</span></span></code></pre></div><p>Whenever a semaphore set is not needed anymore it should be properly removed. This cleanup process is important because semaphores continue to exist even when the calling program is completed.</p>
<p>There is also a limit to the amount of semaphores that can be created and that can exist at any given time. Hence, if you don’t remove garbage you may at some point reach the given limit of your computer which makes any subsequent call to <code>semget</code> fail.</p>
<p>You can see a list of open semaphores via the console using:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">$ ipcs -s
</span></span></code></pre></div><p>The limit of the maximum number of semaphores that can exist at any given time can be checked via</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">long</span> <span class="n">max_nsem</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_SEM_NSEMS_MAX</span><span class="p">);</span>
</span></span></code></pre></div><p>or in the console via</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln"> 1</span><span class="cl">$ ipcs -S
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	semmap:     30	<span class="o">(</span><span class="c1"># of entries in semaphore map)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	semmni:      0	<span class="o">(</span><span class="c1"># of semaphore identifiers)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	semmns:      0	<span class="o">(</span><span class="c1"># of semaphores in system)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	semmnu:      0	<span class="o">(</span><span class="c1"># of undo structures in system)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	semmsl:  87381	<span class="o">(</span>max <span class="c1"># of semaphores per id)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	semopm:      5	<span class="o">(</span>max <span class="c1"># of operations per semop call)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	semume:     10	<span class="o">(</span>max <span class="c1"># of undo entries per process)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	semusz:     32	<span class="o">(</span>size in bytes of undo structure<span class="o">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	semvmx:  32767	<span class="o">(</span>semaphore maximum value<span class="o">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	semaem:  16384	<span class="o">(</span>adjust on <span class="nb">exit</span> max value<span class="o">)</span>
</span></span></code></pre></div><p>on Mac OS or via</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">$ cat /proc/sys/kernel/sem
</span></span></code></pre></div><p>on Linux.</p>
<h2 id="synchronizing-memory-writes-with-semaphores">Synchronizing memory writes with semaphores</h2>
<p>Now, let’s put all of the above together and use <strong>semaphores</strong> to ensure that our multiprocessing calculation ends up with the correct frequency counts.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">  1</span><span class="cl">    <span class="c1">// create a very large array of random numbers between 0-9
</span></span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln">  3</span><span class="cl">    <span class="kt">long</span> <span class="n">arrlen</span>  <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>        <span class="c1">// arbitrary length of the array
</span></span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span>  <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">// there are 10 digits [0-9]
</span></span></span><span class="line"><span class="ln">  5</span><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arrlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">  6</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">ndigits</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl">
</span></span><span class="line"><span class="ln">  8</span><span class="cl">    
</span></span><span class="line"><span class="ln">  9</span><span class="cl">    <span class="c1">// PART I -- counting frequencies with a single processes
</span></span></span><span class="line"><span class="ln"> 10</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl">    <span class="n">time_t</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_sp</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ndigits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span> <span class="c1">// frequency counter per digit (single process)
</span></span></span><span class="line"><span class="ln"> 13</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">        <span class="n">freq_sp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">    <span class="c1">// calculate the sum of all frequencies to check that the calculation is correct
</span></span></span><span class="line"><span class="ln"> 20</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">    <span class="kt">long</span> <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies (single process) : %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">freq_sp</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">    <span class="c1">// PART II -- counting frequencies with multiple processes
</span></span></span><span class="line"><span class="ln"> 29</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">    <span class="c1">// define a shared memory to store the frequency counters
</span></span></span><span class="line"><span class="ln"> 32</span><span class="cl"><span class="c1"></span>    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_mp</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">freq_mp</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;mmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">    <span class="c1">// define a semaphore set for synchronizing write access to shared memory
</span></span></span><span class="line"><span class="ln"> 36</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span></span></span><span class="line"><span class="ln"> 37</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">    <span class="c1">// initialize the semaphore
</span></span></span><span class="line"><span class="ln"> 41</span><span class="cl"><span class="c1"></span>    <span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released/unlocked
</span></span></span><span class="line"><span class="ln"> 42</span><span class="cl"><span class="c1"></span>    <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// struct to feed into semaphore functions
</span></span></span><span class="line"><span class="ln"> 45</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of child processes to run simultaneously
</span></span></span><span class="line"><span class="ln"> 47</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>    <span class="c1">// reset the time counter
</span></span></span><span class="line"><span class="ln"> 49</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">         
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>  <span class="c1">// exit if fork was not successful
</span></span></span><span class="line"><span class="ln"> 54</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">        <span class="c1">// define what each child process will do
</span></span></span><span class="line"><span class="ln"> 56</span><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">             
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">             <span class="c1">// define a segment that each child process works on independently
</span></span></span><span class="line"><span class="ln"> 59</span><span class="cl"><span class="c1"></span>             <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">             <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">             
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">             <span class="c1">// sum up the numbers in this segment of the array
</span></span></span><span class="line"><span class="ln"> 63</span><span class="cl"><span class="c1"></span>             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// lock the semaphore
</span></span></span><span class="line"><span class="ln"> 66</span><span class="cl"><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">                 
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">                 
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span></span></span><span class="line"><span class="ln"> 70</span><span class="cl"><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// release/unlock the semaphore
</span></span></span><span class="line"><span class="ln"> 73</span><span class="cl"><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">                 
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">             <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">              
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">         
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">    <span class="c1">// wait for all child processes to finish
</span></span></span><span class="line"><span class="ln"> 84</span><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">    <span class="c1">// calculate the sum of all frequencies to check that the calculation is correct
</span></span></span><span class="line"><span class="ln"> 88</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">    <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_mp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">        
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies (multiprocessing): %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">    <span class="c1">// cleanup
</span></span></span><span class="line"><span class="ln"> 96</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semctl remove&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>        <span class="c1">// remove semaphore
</span></span></span><span class="line"><span class="ln"> 98</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">freq_mp</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;munmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>   <span class="c1">// unmap shared memory
</span></span></span><span class="line"><span class="ln">100</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
</span></span></code></pre></div><p>Running above code will output something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Sum of all frequencies (single process) :        100,000 (13 sec)
</span></span><span class="line"><span class="ln">2</span><span class="cl">Sum of all frequencies (multiprocessing):        100,000 (13 sec)
</span></span></code></pre></div><p>Great. The semaphores work. Write access to shared memory is now synchronized and all processes' writes are successfully completed. However, please note that this synchronization came at a cost. All of the performance gain achieved via multiprocessing seems to be lost. Now, multiprocessing takes the same 13 seconds as did a single process.</p>
<h3 id="memory-synchronization-comes-at-a-cost">Memory synchronization comes at a cost</h3>
<p>That’s disappointing, isn’t it? It was for me when I first noticed the enormous negative performance impact semaphores can have. Every time a lock is set or unset, a low-level call to the OS is made which is slow. Let’s understand in more detail what’s happening and whether there is any option to improve performance.</p>
<p>Based on our current logic, both/all processes lock the same semaphore every time they need to write. This means that the probability that a process that wants to write to the shared variable needs to wait until the semaphore is unlocked is very high. Basically, the probability is 100% because all processes use the same lock.</p>
<p>Therefore, if we were to use multiple locks, for example a different lock for each digit (remember, we want to count the frequencies per digit 0-9) then the probability of encountering locked memory would decrease to only 10% since we have 10 different locks.</p>
<p>As semaphores are defined in sets this can be implemented very easily. We need to make 3 changes:</p>
<p>First, when we <em>define</em> the semaphore we make the size of the set equal to the number of digits, i.e. 10.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="n">ndigits</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</span></span></code></pre></div><p>With this change, the same <code>semid</code> now refers to a set of 10 semaphores instead of a single semaphore.</p>
<p>Second, we need to initialize <strong>all</strong> of the semaphores in the set. Therefore, we put the <code>semctl</code> initialization into a loop. (Alternatively, you could also use the <code>SETALL</code> option instead of a loop. Please refer to the <code>semctl</code> man page.)</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl">    <span class="c1">//    semctl(semid, 0, SETVAL, semun);
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
</span></span></code></pre></div><p>Third, when we lock or release the semaphore we need to define which semaphore in the set we refer to. This is done by adding</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</span></span></code></pre></div><p>as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl">             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">// pick the semaphore in the set
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// lock the semaphore
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                 
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// release/unlock the semaphore
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 
</span></span><span class="line"><span class="ln">14</span><span class="cl">             <span class="p">}</span>
</span></span></code></pre></div><p>If you apply all of these changes, i.e. you now use 10 semaphores instead of 1, and run above code again you should see something like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">Sum of all frequencies (single process) :        100,000 (13 sec)
</span></span><span class="line"><span class="ln">2</span><span class="cl">Sum of all frequencies (multiprocessing):        100,000 (7 sec)
</span></span></code></pre></div><p>Voila! The multiprocessing result is still correct (i.e. memory synchronization via semaphores works) and we see some performance improvement from multiprocessing compared to a single process.</p>
<h2 id="conclusion">Conclusion</h2>
<p><strong>Multiprocessing</strong> requires a completely new consideration, or redesign, of the application logic. Processes need to communicate with each other (IPC) to share the result of their work. When <strong>shared memory</strong> is used for IPC, memory access needs to be <strong>synchronized</strong> to avoid unpredictable outcomes caused by <strong>race conditions</strong>. Synchronization, no matter whether via <strong>semaphores</strong> or <strong>mutexes</strong>, comes at a cost that often negatively compensates any performance gain from <strong>multiprocessing</strong>. To reduce the cost a developer has to carefully weigh different options for the <strong>design</strong> of semaphores or mutexes.</p>
<h5 id="sources-and-further-references">Sources and further references:</h5>
<ul>
<li><a href="http://beej.us/guide/bgipc/html/multi/">Beej’s Guide to Unix IPC</a></li>
<li><a href="https://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html">POSIX thread (pthread) libraries</a></li>
<li><a href="http://users.cs.cf.ac.uk/Dave.Marshall/C/node29.html">Threads: Basic Theory and Libraries</a></li>
<li><a href="https://barrgroup.com/embedded-systems/how-to/rtos-mutex-semaphore">Mutexes and Semaphores Demystified</a></li>
</ul>
<p>.</p>

    </div>
<div class="post_comments">
  
  
    
 <script src="https://utteranc.es/client.js"
         repo="https://github.com/mmlind/mmlind.github.io"
         issue-term="pathname"
         theme="github-dark"
         
         label="blog comments ✨💬✨"
         
         crossorigin="anonymous"
         async>
 </script>
 
  
  
</div>




  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    
  
  <div class="search">
    <input type="search" class="search_field form_field" placeholder='Search...' id="find" autocomplete="off" data-scope='post'>
    <label for="find" class="search_label"><svg class="icon">
  <title>search</title>
  <use xlink:href="#search"></use>
</svg>

    </label>
    
    <div class="search_results results"></div>
  </div>

        <h2>Matt Lind</h2>
      <div class="author_bio">
        Tech geek, command-line aficionado, AI enthusiast, life-long learner.
      </div>
      <a href='https://mmlind.github.io/about/' class="button mt-1" role="button" title='Read More'>Read More</a>

    
    
    <h2 class="mt-4">Featured Posts</h2>
    <ul>
      <li>
        <a href="https://mmlind.github.io/post/2023-05-14-how_to_make_chatgpt_work_with_your_own_data/" class="nav-link" title="How to make ChatGPT work with your own data">How to make ChatGPT work with your own data</a>
      </li>
    </ul>
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      <li>
        <a href="https://mmlind.github.io/post/2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files/" class="nav-link" title="Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files">Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes/" class="nav-link" title="How to simultaneously write to shared memory with multiple processes">How to simultaneously write to shared memory with multiple processes</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2020-09-29-migrating_my_github-pages_blog_from_jekyl_to_hugo/" class="nav-link" title="Migrating my GitHub pages blog from Jekyl to Hugo">Migrating my GitHub pages blog from Jekyl to Hugo</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2017-12-26-using_logistic_regression_to_classify_images/" class="nav-link" title="Using logistic regression to classify images">Using logistic regression to classify images</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2017-03-05-understanding_linear_regression/" class="nav-link" title="Understanding linear regression">Understanding linear regression</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2016-02-12-deep_neural_network_for_mnist_handwriting_recognition/" class="nav-link" title="Deep Neural Network for MNIST Handwriting Recognition">Deep Neural Network for MNIST Handwriting Recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2015-08-09-simple_3-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link" title="Simple 3-Layer Neural Network for MNIST Handwriting Recognition">Simple 3-Layer Neural Network for MNIST Handwriting Recognition</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://mmlind.github.io/tags/machine-learning/' class="post_tag button button_translucent" title="machine-learning">
          MACHINE-LEARNING
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/computer-vision/' class="post_tag button button_translucent" title="computer-vision">
          COMPUTER-VISION
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/blogging/' class="post_tag button button_translucent" title="blogging">
          BLOGGING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/math/' class="post_tag button button_translucent" title="math">
          MATH
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/multiprocessing/' class="post_tag button button_translucent" title="multiprocessing">
          MULTIPROCESSING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/natural-language-processing/' class="post_tag button button_translucent" title="natural-language-processing">
          NATURAL-LANGUAGE-PROCESSING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/nlp/' class="post_tag button button_translucent" title="nlp">
          NLP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/chat-gpt/' class="post_tag button button_translucent" title="chat-gpt">
          CHAT-GPT
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://mmlind.github.io/icons/cli.png' class="icon icon_2 transparent" alt="Matt&#39;s Tech Blog">
    <p>Copyright&nbsp;2015-&nbsp;<span class="year"></span>&nbsp;MATT&#39;S TECH BLOG. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://mmlind.github.io/en/js/bundle.f4da32c64ece1e7d5a836039ceed09b7e4f3592da2a593a2c0e74dd8b24aef5d873eea6fcf180b171a60c193c271d3f845628a40d93531f8e49a553ed23162cd.js" integrity="sha512-9Noyxk7OHn1ag2A5zu0Jt&#43;TzWS2ipZOiwOdN2LJK712HPupvzxgLFxpgwZPCcdP4RWKKQNk1MfjkmlU&#43;0jFizQ==" crossorigin="anonymous"></script>

  <script src="https://mmlind.github.io/js/search.min.441534ebca8f29b72ee98c817c1d9c475fc24ae0a88f1c2eb4deacb203fccebce3c0eee3c758545c399671772a0bc025c7e45b2b1396a19a6dff7ead9c73f066.js"></script>

  </body>
</html>
