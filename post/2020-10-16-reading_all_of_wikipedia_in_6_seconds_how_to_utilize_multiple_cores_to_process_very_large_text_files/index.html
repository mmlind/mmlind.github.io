
<!DOCTYPE html>
<html
  lang="en"
  data-figures=""
  
    class="page"
  
  
  >
  <head>
<title>Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files | Matt&#39;s Tech Blog</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">





<meta property="og:locale" content="en" />

<meta property="og:type" content="article">
<meta name="description" content="I was about to do some basic natural language processing (NLP) task on a large text file: create a dictionary of unique words and count how many times each word …" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:creator" content="@coming_soon">
<meta name="twitter:title" content="Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files" />
<meta name="twitter:image" content="https://mmlind.github.io/images/thumbnail.png"/>
<meta property="og:url" content="https://mmlind.github.io/post/2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files/" />
<meta property="og:title" content="Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files" />
<meta property="og:description" content="I was about to do some basic natural language processing (NLP) task on a large text file: create a dictionary of unique words and count how many times each word …" />
<meta property="og:image" content="https://mmlind.github.io/images/thumbnail.png" />
  <meta name="keywords" content="ai,machine learning,nlp,nlm,large language models" />

<link rel="apple-touch-icon" sizes="180x180" href="https://mmlind.github.io/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mmlind.github.io/icons/favicon-32x32.png">
<link rel="manifest" href="https://mmlind.github.io/icons/site.webmanifest">

<link rel="canonical" href="https://mmlind.github.io/post/2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files/">



<link rel="preload" href="https://mmlind.github.io/css/styles.5bbdaff74df43ad3301fd1da44a332ca19afbd2dbb8c4f1e6c7fb5da394229112d9972011fedf21ba2cbd401586281122a5901efade33dec7837cceff22fa6ad.css" integrity = "sha512-W72v9030OtMwH9HaRKMyyhmvvS27jE8ebH&#43;12jlCKREtmXIBH&#43;3yG6LL1AFYYoESKlkB763jPex4N8zv8i&#43;mrQ==" as="style" crossorigin="anonymous">



<link rel="preload" href="https://mmlind.github.io/en/js/bundle.f4da32c64ece1e7d5a836039ceed09b7e4f3592da2a593a2c0e74dd8b24aef5d873eea6fcf180b171a60c193c271d3f845628a40d93531f8e49a553ed23162cd.js" as="script" integrity=
"sha512-9Noyxk7OHn1ag2A5zu0Jt&#43;TzWS2ipZOiwOdN2LJK712HPupvzxgLFxpgwZPCcdP4RWKKQNk1MfjkmlU&#43;0jFizQ==" crossorigin="anonymous">


<link rel="stylesheet" type="text/css" href="https://mmlind.github.io/css/styles.5bbdaff74df43ad3301fd1da44a332ca19afbd2dbb8c4f1e6c7fb5da394229112d9972011fedf21ba2cbd401586281122a5901efade33dec7837cceff22fa6ad.css" integrity="sha512-W72v9030OtMwH9HaRKMyyhmvvS27jE8ebH&#43;12jlCKREtmXIBH&#43;3yG6LL1AFYYoESKlkB763jPex4N8zv8i&#43;mrQ==" crossorigin="anonymous">

  </head>
  <body
    data-code="7"
    data-lines="false"
    id="documentTop"
    data-lang="en"
  >

<header class="nav_header" >
  <nav class="nav"><a href='https://mmlind.github.io/' class="nav_brand nav_item" title="Matt&#39;s Tech Blog">
  <img src="https://mmlind.github.io/logos/logo.png" class="logo" alt="Matt&#39;s Tech Blog">
  <div class="nav_close">
    <div><svg class="icon">
  <title>open-menu</title>
  <use xlink:href="#open-menu"></use>
</svg>
<svg class="icon">
  <title>closeme</title>
  <use xlink:href="#closeme"></use>
</svg>
</div>
  </div>
</a>

    <div class='nav_body nav_body_left'>
      
      
      
        

  <div class="nav_parent">
    <a href="https://mmlind.github.io/" class="nav_item" title="Blog">Blog </a>
  </div>
  <div class="nav_parent">
    <a href="https://mmlind.github.io/about/" class="nav_item" title="About">About </a>
  </div>
      
      <div class="nav_parent">
        <a href="#" class="nav_item"></a>
        <div class="nav_sub">
          <span class="nav_child"></span>
          
          <a href="https://mmlind.github.io/" class="nav_child nav_item">English</a>
          
          <a href="https://mmlind.github.io/de/" class="nav_child nav_item">Deutsch</a>
          
        </div>
      </div>
<div class='follow'>
  <a href="https://github.com/#">
    <svg class="icon">
  <title>github</title>
  <use xlink:href="#github"></use>
</svg>

  </a>
  <a href="https://cn.linkedin.com/in/mmlind">
    <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

  </a>
<div class="color_mode">
  <input type="checkbox" class="color_choice" id="mode">
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class="grid-inverse wrap content">
  <article class="post_content">
    <h1 class="post_title">Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files</h1>
  <div class="post_meta">
    <span><svg class="icon">
  <title>calendar</title>
  <use xlink:href="#calendar"></use>
</svg>
</span>
    <span class="post_date">
      Oct 16, 2020</span>
    <span class="post_time"> · 51 min read</span><span>&nbsp;· <a href='https://mmlind.github.io/tags/natural-language-processing/' title="NATURAL LANGUAGE PROCESSING" class="post_tag button button_translucent">NATURAL LANGUAGE PROCESSING
        </a><a href='https://mmlind.github.io/tags/nlp/' title="NLP" class="post_tag button button_translucent">NLP
        </a><a href='https://mmlind.github.io/tags/multiprocessing/' title="MULTIPROCESSING" class="post_tag button button_translucent">MULTIPROCESSING
        </a><a href='https://mmlind.github.io/tags/c/' title="C" class="post_tag button button_translucent">C
        </a><a href='https://mmlind.github.io/tags/python/' title="PYTHON" class="post_tag button button_translucent">PYTHON
        </a>
    </span>
    <span class="page_only">&nbsp;·
  <div class="post_share">
    Share on:
    <a href="https://twitter.com/intent/tweet?text=Reading%20all%20of%20Wikipedia%20in%206%20seconds%3a%20how%20to%20utilize%20multiple%20cores%20to%20process%20very%20large%20text%20files&url=https%3a%2f%2fmmlind.github.io%2fpost%2f2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>twitter</title>
  <use xlink:href="#twitter"></use>
</svg>

    </a>
    <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fmmlind.github.io%2fpost%2f2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files%2f&t=Reading%20all%20of%20Wikipedia%20in%206%20seconds%3a%20how%20to%20utilize%20multiple%20cores%20to%20process%20very%20large%20text%20files" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
      <svg class="icon">
  <title>facebook</title>
  <use xlink:href="#facebook"></use>
</svg>

    </a>
    <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow">
      <svg class="icon">
  <title>linkedin</title>
  <use xlink:href="#linkedin"></use>
</svg>

    </a>
    <a href="https://mmlind.github.io/post/2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files/" title="Copy Link" class="link link_yank">
      <svg class="icon">
  <title>copy</title>
  <use xlink:href="#copy"></use>
</svg>

    </a>
  </div>
  </span>
  </div>

    <div class="post_body"><p>I was about to do some basic natural language processing (NLP) task on a large text file: create a dictionary of unique words and count how many times each word occurs. Easy peasy. This should only take me a minute. So I thought. While coding did not take more than 2 zips of coffee, I needed to wait almost an hour for the task to complete. That was unacceptable. There must be a way to accelerate this process.</p>
<p>So I detoured, digging into parallel processing with multi-core computers. Along the way, I learned about semaphores, mutexes, pipes, and parallel hash tables. I knew I was cracking the nut with a sledgehammer. But hey, data files are only getting bigger. Remember anyone complaining “the data source is too big for our model!”? Me neither.</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt=""
      
        class="image_figure image_internal image_unprocessed"
        src="nlp.png"
      
      
    />

    </picture>
</figure>
</p>
<p>A friend asked me for help to assess a new algorithm for building word embeddings. Remember those numerical representations of words that allow you to do arithmetic calculations such as the (in)famous</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln">1</span><span class="cl">King - Man + Woman = Queen
</span></span></code></pre></div><p>equation? In a typical machine learning manner, he emphasized that we would need a very large text corpus for building and training the model. Otherwise, the algorithm wouldn’t work.</p>
<p>So, off I go to look for freely available large text corpora. One of the first potential sources that come to my mind is ... Wikipedia. As of October 2020, the English Wikipedia text spans <a href="http://wikicount.net/">more than 6 million articles</a>. With an average of 1,324 words per article the whole corpus should provide us with 8 billion words. That seemed like a good start.</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt=""
      
        class="image_figure image_internal image_unprocessed"
        src="wikicount_202010.png"
      
      
    />

    </picture>
</figure>
</p>
<h2 id="reading-large-wikipedia-files">Reading large Wikipedia files</h2>
<p>Regular backups are available at <a href="https://dumps.wikimedia.org/">dumps.wikimedia.org</a>, and the latest dumps of the English site can be downloaded <a href="https://dumps.wikimedia.org/enwiki/latest/">here</a>. Simply look for a file <em>enwiki-latest-pages-articles.xml.bz2</em> which includes all current articles.</p>
<p>Naturally, these files are not small. The current version of the English Wikipedia dump file is a whopping 17.7 GB, <strong>compressed</strong>. One of the reasons for the enormous file size is that all dump files come in a clumsy XML format which carries a lot of extra baggage.</p>
<p>I download the version dated October 2, 2020. Since I’m interested in a plain text corpus, I need to strip off the XML markup and all the metadata that is included. Fortunately, there are tools that convert the files in a breeze, such as <a href="https://www.kdnuggets.com/2017/11/building-wikipedia-text-corpus-nlp.html">Building a Wikipedia Text Corpus for Natural Language Processing</a> or <a href="https://github.com/yohasebe/wp2txt">WP2TXT</a>.</p>
<h2 id="creating-a-dictionary-from-a-text-corpus">Creating a dictionary from a text corpus</h2>
<p>After conversion to plain text, the dump file of the English Wikipedia still weighs a staggering 17.3 GB. (After decompression, the original dump file exploded to 78 GB of XML which then get stripped down to 17 GB.) I call it <code>enwiki.txt</code>. This is the file that I am going to work on.</p>
<p>My first task is to build a dictionary of its unique words and count their respective occurrences. The tool I’m using to create the dictionary is <strong>Python</strong>, the de facto weapon of choice nowadays for many machine learning practitioners, data scientists, and anyone else who wants to get stuff done quickly.</p>
<h2 id="processing-with-python">Processing with Python</h2>
<p>Python is amazing. The language empowers a developer to achieve complex tasks with little code. Creating a dictionary from a text corpus requires only a few lines:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-PYTHON" data-lang="PYTHON"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">import</span> <span class="nn">datetime</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;corpus/corpus.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">top</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Execution time: </span><span class="si">%.0f</span><span class="s2"> seconds&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Number of words in the dictionary: </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Top 10 words:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">])</span>
</span></span></code></pre></div><p>Yes, this is elementary school syntax. Hold on. We’re just getting started. If you’re a devoted Pythonista you must know at least 27.5 other ways to do this. If you want to highlight any method in particular, please leave a comment below.</p>
<p>Running this script on my computer takes 3,430 seconds to complete. That’s me waiting for more than 53 mins. Or almost one hour. Just to tell me the following:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">Execution time: 3,430 seconds
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">Number of words in the dictionary: 9,969,783
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">Top 10 words:
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">the  187,815,597
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">of    94,989,314
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">and   79,019,333
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">in    76,509,632
</span></span><span class="line"><span class="ln">10</span><span class="cl">to    52,986,068
</span></span><span class="line"><span class="ln">11</span><span class="cl">was   30,276,734
</span></span><span class="line"><span class="ln">12</span><span class="cl">is    23,444,605
</span></span><span class="line"><span class="ln">13</span><span class="cl">for   23,133,442
</span></span><span class="line"><span class="ln">14</span><span class="cl">on    22,621,322
</span></span><span class="line"><span class="ln">15</span><span class="cl">as    22,363,717
</span></span></code></pre></div><p>Huh. I’m going to end up with a caffeine addiction if I don’t speed this up. Come on, Python. You can do better than that.</p>
<p>The simple <code>split()</code> method doesn’t cut it. And, I want to include some pre-processing such as converting all words to lower case. So I plugin the <a href="https://stackoverflow.com/questions/35857519/efficiently-count-word-frequencies-in-python">following method</a> next, using Python’s <code>counter</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-PYTHON" data-lang="PYTHON"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">punctuation</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kn">import</span> <span class="nn">datetime</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="k">def</span> <span class="nf">count_words_in_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">linewords</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">punctuation</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">return</span> <span class="n">Counter</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">linewords</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="n">dic</span> <span class="o">=</span> <span class="n">count_words_in_file</span><span class="p">(</span><span class="s1">&#39;corpus/enwiki_short.txt&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="n">top</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Execution time: </span><span class="si">%.0f</span><span class="s2"> seconds&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Number of words in the dictionary: </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="s2">&#34;Top 10 words:&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</span></span></code></pre></div><p>That’s a few libraries to import, but it’s concise, elegant, and even covers the pre-processing. Nice. And more importantly, this method performs better, taking <strong>only</strong> 1,402 seconds or about 23+ minutes on my computer to complete. Yeah. This saves me half an hour.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">Execution time: 1,402 seconds
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">Number of words in the dictionary: 10,148,725
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">Top 10 words:
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">(&#39;the&#39;, 187,814,291)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">(&#39;of&#39;,   94,986,720)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">(&#39;and&#39;,  79,017,578)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">(&#39;in&#39;,   76,500,162)
</span></span><span class="line"><span class="ln">10</span><span class="cl">(&#39;to&#39;,   52,983,623)
</span></span><span class="line"><span class="ln">11</span><span class="cl">(&#39;was&#39;,  30,276,660)
</span></span><span class="line"><span class="ln">12</span><span class="cl">(&#39;is&#39;,   23,444,109)
</span></span><span class="line"><span class="ln">13</span><span class="cl">(&#39;for&#39;,  23,132,718)
</span></span><span class="line"><span class="ln">14</span><span class="cl">(&#39;on&#39;,   22,619,230)
</span></span><span class="line"><span class="ln">15</span><span class="cl">(&#39;as&#39;,   22,363,452)
</span></span></code></pre></div><blockquote>
<p>Both methods return the same top 10 words. The exact token counts yet differ because they use different word boundaries.</p>
</blockquote>
<p>I’m grateful for the additional half an hour that my life just gained. I’m celebrating for a few seconds, then my mind wanders off. Come on. It’s 2020. Almost every home computer comes with multiple cores, running at &gt;3 Ghz. The Mac Mini I’m using to write this blog on boasts 6 cores. With that much computing power is it not possible to speed up the processing of large text files? And how can I effectively use <strong>all</strong> cores and process the file <strong>in parallel</strong>?</p>
<p>Questions demand answers. I decide to do some investigation into multiprocessing and multithreading. I want to assess how any such techniques could help me to process the Wikipedia file faster.</p>
<h2 id="sequential-processing-with-c">Sequential processing with C</h2>
<p>I start my investigation by developing a simple C program that processes the text corpus on a single core, sequentially.</p>
<p>Writing C code is clearly not as efficient and elegant as coding in Python. The idea of the sledgehammer begins to form. But hey, for this kind of operation I need a scalpel, not a kitchen knife. And I just love the power and precision of the C language.</p>
<p>I break down the algorithm for creating the dictionary into 4 main steps:</p>
<ul>
<li>Map the corpus file to memory</li>
<li>Read the corpus word by word</li>
<li>Deduplicate all words</li>
<li>Sort the words by count in descending order</li>
</ul>
<p>Wow. Just mapping out my to-do list already takes more lines of writing than coding the whole piece in Python. This better works.</p>
<h3 id="1-map-the-corpus-file-to-memory">1. Map the corpus file to memory</h3>
<p>Given the monstrous size of Wikipedia dump files, I want to ensure they can be read on computers that do not have sufficient memory to load the complete file at once. Therefore, I use mmap to map the physical file into memory. The loading into memory happens dynamically and the operating system helps to cache pages which further improves performance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">map_shared_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">fsize</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">        
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">struct</span> <span class="n">stat</span> <span class="n">fstat</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fstat</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[STAT] Error getting file stats! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="o">*</span><span class="n">fsize</span> <span class="o">=</span> <span class="n">fstat</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[OPEN] Error opening file for shared use! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">fsize</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[MMAP] Error creating shared memory for file reading! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[CLOSE] Error closing mapped file! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Using <code>mmap</code> is simple and straight forward. I create the above function <code>map_shared_file()</code> to do and hide all the usual error handling. The function returns a pointer which allows reading the file simply by accessing the pointer. The function also returns the file size of the corpus which I will need later.</p>
<blockquote>
<p>BTW: I also tested loading the corpus file into memory. Surprisingly, this did not result in any measurable performance improvement. On the contrary, in some scenarios loading the file into memory was somewhat slower than mapping the file.</p>
</blockquote>
<h3 id="2-read-the-corpus-word-by-word">2. Read the corpus word by word</h3>
<p>To process the corpus word by word, I first introduce an object for representing a word that I can use throughout the program. I call it the <code>corpus_token_t</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// basic structure to represent a &#39;word/token&#39; that exists in the corpus
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">corpus_token_t</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">size_t</span> <span class="n">off</span><span class="p">;</span>                 <span class="c1">// offset of 1st occurrence in corpus
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>                    <span class="c1">// length of the token, not null-terminated
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>               <span class="c1">// counter for how many times this token is found
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">corpus_token_t</span><span class="p">;</span>
</span></span></code></pre></div><p>If you have worked on NLP you’re familiar with the token terminology. It’s neither a coin nor a password. And has no relationship to cryptocurrencies. In some languages, such as Chinese or other Asian languages, the most basic element of a sentence or a text is not a <strong>word</strong> but a <strong>character</strong>. A <strong>token</strong> represents an element of the written language: either a single <strong>character</strong> or a series of characters, i.e. a <strong>word</strong>.</p>
<p>To maximize performance my <code>corpus_token_t</code> object does not include a <code>string</code> or the actual character representation of the token. (Yes, I know. C doesn’t have a <code>string</code> in the first place. But you know what I mean.) Instead, I only store the offset of the first occurrence of this token in the corpus. Plus its length and a counter for how many times this token appeared in the corpus.</p>
<p>Now, I can stroll along and read the file. But wait. What’s that? I see 2 bumps in this walk in the park: multi-byte sequences and word boundaries.</p>
<h4 id="multi-byte-sequences">Multi-byte sequences</h4>
<p>I want to be able to read Wikipedia dumps (or any other text files for that matter) of any language. Therefore, I can’t read the file simply <code>char</code> by <code>char</code> because in many languages a single ‘letter’, or character, uses more than a single byte <code>char</code>.</p>
<p>UTF8 has become a de facto standard in the digital world. Unfortunately, in UTF8 there is no fixed character length. Characters may range in size from 1 to 4 bytes which makes handling UTF8 in C a bit of a pain.</p>
<p>Fortunately, there are some small libraries to come to the rescue. Jeff Bezanson’s early groundwork for UTF8 processing called <a href="https://github.com/JeffBezanson/cutef8">cutef8</a>, for example. I grab his macro for identifying whether a <code>char</code> is UTF8...</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="cp">#define IS_UTF8(c) (((c)&amp;0xC0)!=0x80)
</span></span></span></code></pre></div><p>... and pump up his original <code>u8_memchr</code> function to create the following <code>get_next_token</code> function to read a text segment of given length token by token:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="n">USE_SINGLE_CHARS_AS_TOKENS</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// set to &#39;true&#39; for Asian languages
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">corpus_token_t</span> <span class="nf">get_next_token</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">end</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">size_t</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="c1">// move IDX forward in case it points INSIDE of a multibyte character
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_UTF8</span><span class="p">(</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">])</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="c1">// move IDX gradually forward
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="o">&lt;</span><span class="n">MAX_TOKEN_STRING_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]</span> <span class="p">){</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="kt">uint32_t</span> <span class="n">u8_char_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="kt">int</span>      <span class="n">u8_char_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">u8_char_code</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">u8_char_code</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="n">u8_char_size</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">            <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_UTF8</span><span class="p">(</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]));</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="n">u8_char_code</span> <span class="o">-=</span> <span class="n">UTF8_OFFSETS</span><span class="p">[</span><span class="n">u8_char_size</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="c1">// 3 exit conditions: (1) multi-byte character, (2) end of text, (3) token delimiter
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>        <span class="kt">bool</span> <span class="n">is_del</span> <span class="o">=</span> <span class="n">is_token_delimiter</span><span class="p">(</span><span class="n">u8_char_code</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">is_del</span> <span class="o">||</span> <span class="o">*</span><span class="n">idx</span><span class="o">==</span><span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">USE_SINGLE_CHARS_AS_TOKENS</span> <span class="o">&amp;&amp;</span> <span class="n">u8_char_size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">            <span class="n">tok</span><span class="p">.</span><span class="n">len</span>   <span class="o">=</span> <span class="n">is_del</span> <span class="o">?</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">-</span> <span class="n">u8_char_size</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="n">tok</span><span class="p">.</span><span class="n">off</span>   <span class="o">=</span> <span class="n">start_idx</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">            <span class="n">tok</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">            <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">        
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="c1">// if no token was found, return empty token reference
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1"></span>    <span class="n">tok</span><span class="p">.</span><span class="n">len</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="n">tok</span><span class="p">.</span><span class="n">off</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">    <span class="n">tok</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">    
</span></span><span class="line"><span class="ln">42</span><span class="cl">    <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Good. This takes care of bump #1. Moving on.</p>
<h4 id="word-boundaries">Word boundaries</h4>
<p>What constitutes a <em>word</em>? In most Western languages one obvious answer is a whitespace between two characters. Sure. But there are plenty of other characters and cases to consider. I wrap all such characters into a function <code>is_token delimiter</code>. Whenever a token delimiter is read, the end, or boundary, of a token has been reached.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">bool</span> <span class="nf">is_token_delimiter</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">utf_code</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">32</span>    <span class="o">||</span> <span class="c1">// &#34; &#34; space
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span>  <span class="mi">9</span>    <span class="o">||</span> <span class="c1">// &#34; &#34; tab
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">10</span>    <span class="o">||</span> <span class="c1">// &#34;\n&#34; linefeed
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">13</span>    <span class="o">||</span> <span class="c1">// &#34;&#34; carriage return
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">33</span>    <span class="o">||</span> <span class="c1">// &#39;!&#39;
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">34</span>    <span class="o">||</span> <span class="c1">// &#39;&#34;&#39;
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">35</span>    <span class="o">||</span> <span class="c1">// &#39;#&#39;
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">39</span>    <span class="o">||</span> <span class="c1">// &#39;&#39;&#39;
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">40</span>    <span class="o">||</span> <span class="c1">// &#39;(&#39;
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">41</span>    <span class="o">||</span> <span class="c1">// &#39;)&#39;
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">42</span>    <span class="o">||</span> <span class="c1">// &#39;*&#39;
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">43</span>    <span class="o">||</span> <span class="c1">// &#39;+&#39;
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">44</span>    <span class="o">||</span> <span class="c1">// &#39;,&#39;
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">46</span>    <span class="o">||</span> <span class="c1">// &#39;.&#39;
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">47</span>    <span class="o">||</span> <span class="c1">// &#39;/&#39;
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">58</span>    <span class="o">||</span> <span class="c1">// &#39;:&#39;
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">59</span>    <span class="o">||</span> <span class="c1">// &#39;;&#39;
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">60</span>    <span class="o">||</span> <span class="c1">// &#39;&lt;&#39;
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">61</span>    <span class="o">||</span> <span class="c1">// &#39;=&#39;
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">62</span>    <span class="o">||</span> <span class="c1">// &#39;&gt;&#39;
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">63</span>    <span class="o">||</span> <span class="c1">// &#39;?&#39;
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">91</span>    <span class="o">||</span> <span class="c1">// &#39;[&#39;
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">92</span>    <span class="o">||</span> <span class="c1">// &#39;\&#39;
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">93</span>    <span class="o">||</span> <span class="c1">// &#39;]&#39;
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">95</span>    <span class="o">||</span> <span class="c1">// &#39;_&#39;
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">123</span>   <span class="o">||</span> <span class="c1">// &#39;{&#39;
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">124</span>   <span class="o">||</span> <span class="c1">// &#39;|&#39;
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">125</span>   <span class="o">||</span> <span class="c1">// &#39;}&#39;
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8212</span>  <span class="o">||</span> <span class="c1">// &#39;—&#39;&#39;
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8216</span>  <span class="o">||</span> <span class="c1">// &#39;‘&#39;
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8217</span>  <span class="o">||</span> <span class="c1">// &#39;’&#39;
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8220</span>  <span class="o">||</span> <span class="c1">// &#39;“&#39;
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8221</span>  <span class="o">||</span> <span class="c1">// &#39;”&#39;
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">12289</span> <span class="o">||</span>  <span class="c1">// u8&#34;、&#34;
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">12290</span> <span class="o">||</span>  <span class="c1">// u8&#34;。&#34;
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="c1"></span>                   
</span></span><span class="line"><span class="ln">43</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65281</span> <span class="o">||</span>  <span class="c1">// u8&#34;！&#34;
</span></span></span><span class="line"><span class="ln">44</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65288</span> <span class="o">||</span>  <span class="c1">// u8&#34;（&#34;
</span></span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65289</span> <span class="o">||</span>  <span class="c1">// u8&#34;）&#34;
</span></span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65292</span> <span class="o">||</span>  <span class="c1">// u8&#34;，&#34;
</span></span></span><span class="line"><span class="ln">47</span><span class="cl"><span class="c1"></span>                   
</span></span><span class="line"><span class="ln">48</span><span class="cl">                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65306</span> <span class="o">||</span>  <span class="c1">// u8&#34;：&#34;
</span></span></span><span class="line"><span class="ln">49</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65307</span> <span class="o">||</span>  <span class="c1">// u8&#34;；&#34;
</span></span></span><span class="line"><span class="ln">50</span><span class="cl"><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65311</span> <span class="o">||</span>  <span class="c1">// u8&#34;？&#34;
</span></span></span><span class="line"><span class="ln">51</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">                   <span class="p">(</span><span class="n">utf_code</span>  <span class="o">&gt;=</span>  <span class="mi">917600</span> <span class="o">&amp;&amp;</span> <span class="n">utf_code</span>  <span class="o">&lt;=</span>  <span class="mi">917699</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">                   <span class="p">(</span><span class="n">utf_code</span>  <span class="o">&gt;=</span> <span class="mi">1113000</span> <span class="o">&amp;&amp;</span> <span class="n">utf_code</span>  <span class="o">&lt;=</span> <span class="mi">1113100</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">
</span></span><span class="line"><span class="ln">55</span><span class="cl">                   <span class="p">);</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">    
</span></span><span class="line"><span class="ln">57</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>The definition of <em>token delimiters</em> impacts the number of tokens put into the dictionary and their respective counts. If the raw text version of the Wikipedia dump file does not include punctuation then you don’t need this many token delimiters because most of these characters have already been removed during XML to TXT conversion.</p>
</blockquote>
<p>Equipped with these two functions I can now loop through the file and pick up all its tokens as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">char</span> <span class="n">CORPUS_FILE_NAME</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;enwiki.txt&#34;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">map_shared_file</span><span class="p">(</span><span class="n">CORPUS_FILE_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_fsize</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="n">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="n">size_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">corpus_fsize</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="c1">// do something with this token....
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>                
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Straight forward and painless. So far, so good. What’s next? What do I do with the tokens read from the corpus?</p>
<h3 id="3-deduplicate-all-words">3. Deduplicate all words</h3>
<p>A dictionary is a list of all the <strong>unique</strong> words, or tokens, in a text. Therefore, I need to <strong>deduplicate</strong> the tokens. And do so at the speed of light.</p>
<p>Enter hash tables. One of the most efficient tools for deduplication and quick lookups is a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a>. The <em>string</em> of a token shall serve as my hash key. I’m sketching down the main steps I need to implement:</p>
<ul>
<li>Create the hash table</li>
<li>Hash a string</li>
<li>Compare tokens</li>
<li>Insert a token into the hash table</li>
</ul>
<h4 id="create-the-hash-table">Create the hash table</h4>
<p>The hash table itself is nothing but an array of <code>corpus_token_t</code> objects. Not a fan of dynamically resized arrays, I wonder about its size. There is no agreed definition of the ideal or best size of a hash table. <a href="https://stackoverflow.com/questions/22741966/how-to-choose-size-of-hash-table">Some</a> argue its load factor – the share of hash table entries, or buckets, that are filled – should not exceed 70%. Sounds like a reasonable metric to start from.</p>
<p>But wait. The size of the hash table depends on the size of the dictionary, which in return depends on the size of the corpus text. Would it not be ideal to link the size of the hash table directly to … say … corpus file size? After all, if the table is too big, I’ll be wasting lots of memory. If it’s too small, I’ll have lots of hash ‘misses’ which will slow down performance.</p>
<p>I decide to sacrifice a few bits for the sake of performance, and come up with the following, somewhat arbitrary, formula that defines hash size based on file size:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">MAX_HASH_LENGTH</span> <span class="o">=</span> <span class="mi">30000</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">log10</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1">//    MAX_HASH_LENGTH = 13727587;
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1">//    MAX_HASH_LENGTH = 18303449;
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">//    MAX_HASH_LENGTH = 36606883;
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1">//    MAX_HASH_LENGTH = 53150323;
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1">//    MAX_HASH_LENGTH = 80000023;
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok_htab</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">MAX_HASH_SIZE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</span></span></code></pre></div><p>The function includes, as comments, some of the fixed sizes that I used. They’re all prime numbers which arguably make better hashes. And if you wonder how do I get a prime number above, say, 50 million? No, I didn’t calculate them. I used <a href="http://compoasso.free.fr/primelistweb/page/prime/liste_online_en.php">this online tool</a> to simply look them up.</p>
<h4 id="hash-a-string">Hash a string</h4>
<p>Next, I need to hash each token to obtain a unique code. Remember that our <code>corpus_token_t</code> object does not include the actual character representation (aka string) of this token?</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">get_token_string</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">memcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">corpus</span> <span class="o">+</span> <span class="n">tok</span><span class="p">.</span><span class="n">off</span><span class="p">,</span> <span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">memset</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="c1">// convert to lower case
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)))</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I first need to obtain the string before I can create a hash. I also convert all tokens to lowercase to more efficiently utilize the hash table. And for most NLP tasks the <em>case</em> of a word is insignificant.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">size_t</span> <span class="nf">get_token_hash</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// create a character representation of the token
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">tok_str</span><span class="p">[</span><span class="n">MAX_TOKEN_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">get_token_string</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok_str</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="c1">// hash the token string
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">tok_str</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">5381</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">))</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">^</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// hash * 33 XOR c 
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">        
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>For the actual hashing, I use <a href="https://en.wikipedia.org/wiki/Daniel_J._Bernstein">Daniel J. Bernstein’s</a> DJB2 hash function which is simple and works well for strings. Feel free to try <a href="http://www.cse.yorku.ca/~oz/hash.html">others</a>.</p>
<h4 id="compare-tokens">Compare tokens</h4>
<p>When I insert a token into the hash table, I need to check for potential collisions. Therefore, I need a comparison function to assess whether two tokens are equal.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c1">// compare two integers and return the smaller one
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="cp">#define MIN_OF_TWO(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b);  _a &lt; _b ? _a : _b; })
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">int</span> <span class="nf">compare_corpus_tokens</span><span class="p">(</span><span class="k">const</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok1</span><span class="p">,</span> <span class="k">const</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">tok1</span><span class="p">).</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">tok2</span><span class="p">).</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">MIN_OF_TWO</span><span class="p">(</span><span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str1</span> <span class="o">=</span> <span class="n">corpus</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tok1</span><span class="p">).</span><span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str2</span> <span class="o">=</span> <span class="n">corpus</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tok2</span><span class="p">).</span><span class="n">off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="c1">// both strings differ in the first &#39;len&#39; chars
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="c1">// both strings are the same
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">len1</span> <span class="o">==</span> <span class="n">len2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="c1">// if both strings have a different length but share the first &#39;len&#39; characters
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>    <span class="c1">// the shorter one is the smaller one
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&lt;</span> <span class="n">len2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The above function does that efficiently using <em>pointers</em> only.</p>
<h4 id="insert-a-token-into-the-hash-table">Insert a token into the hash table</h4>
<p>At last, I insert the token into the hash table. If the token already exists, its counter will be incremented. If the assigned seat number on the hash table bus is taken already, let the token move on and find the next empty spot.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">insert_token</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        <span class="c1">// check if this bucket is empty
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            <span class="c1">// if the same token already exists in the hash table increment its counter
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">            <span class="c1">// otherwise move forward to the next bucket
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">        
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>Note to self: The function does not check whether the hash table is large enough to fit all tokens. In fact, if there were more tokens to put in the dictionary than there are buckets in the hash table the loop would run infinitely. @todo</p>
</blockquote>
<p>After all tokens are placed, the number of filled buckets tells me the number of unique tokens in the dictionary.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">size_t</span> <span class="nf">get_htab_token_count</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    
</span></span><span class="line"><span class="ln">5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_HASH_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">
</span></span><span class="line"><span class="ln">8</span><span class="cl">    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="4-sort-the-words-by-count-in-descending-order">4. Sort the words by count in descending order</h3>
<p>Almost there. I have read and deduplicated all tokens, and popped them into a gargantuan, sparsely populated hash table. I also calculated the word count. But how do I sort a hash table?</p>
<p>You don’t. Instead, I first copy all unique tokens into a more compact representation: an array of tokens, a.k.a. the dictionary.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">corpus_token_t</span> <span class="o">*</span><span class="nf">create_dictionary</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">dict_tok_count</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">corpus_tok_count</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="o">*</span><span class="n">corpus_tok_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">dict_tok_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">size_t</span> <span class="n">didx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">hidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">hidx</span><span class="o">&lt;</span><span class="n">MAX_HASH_SIZE</span><span class="p">;</span> <span class="n">hidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            <span class="o">*</span><span class="n">corpus_tok_count</span> <span class="o">+=</span> <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>  <span class="c1">// calc overall token count
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>            <span class="n">dict</span><span class="p">[</span><span class="n">didx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">];</span>              <span class="c1">// add token into dictionary
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">assert</span><span class="p">(</span><span class="n">didx</span> <span class="o">==</span> <span class="n">dict_tok_count</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="k">return</span> <span class="n">dict</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The dictionary can then be easily sorted using a standard <code>qsort</code> algorithm.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">compare_token_counters</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">size_t</span> <span class="n">freq_a</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">).</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">size_t</span> <span class="n">freq_b</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">).</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">freq_a</span> <span class="o">&lt;</span> <span class="n">freq_b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">freq_a</span> <span class="o">&gt;</span> <span class="n">freq_b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="kt">void</span> <span class="nf">sort_dict</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">dict_tok_count</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">qsort</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">dict_tok_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">),</span> <span class="n">compare_token_counters</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>   
</span></span></code></pre></div><p>That’s it. The moment of truth. I put all the above together: process the corpus, deduplicate tokens, count their occurrences, and sort the dictionary. And while I’m at it, I print out the top 10. Because I’m curious.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">text2dict</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">map_shared_file</span><span class="p">(</span><span class="n">CORPUS_FILE_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_fsize</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">MAX_HASH_SIZE</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">log10</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span>  <span class="o">=</span> <span class="n">create_token_hash</span> <span class="n">table</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">size_t</span> <span class="n">dict_tok_count</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="n">size_t</span> <span class="n">corpus_tok_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">create_dictionary</span><span class="p">(</span><span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict_tok_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_tok_count</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">sort_dict</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">dict_tok_count</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;# of tokens in corpus: [%&#39;15lu]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">corpus_tok_count</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;# of tokens in dict:   [%&#39;15lu]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">dict_tok_count</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="kt">char</span> <span class="n">tok_str</span><span class="p">[</span><span class="n">MAX_TOKEN_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Top 10:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">        <span class="n">get_token_string</span><span class="p">(</span><span class="n">dict</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tok_str</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;#%2d: %&#39;12zu = %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dict</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">,</span> <span class="n">tok_str</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">     
</span></span><span class="line"><span class="ln">27</span><span class="cl">    <span class="c1">// clean up
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">htab</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">unmap_shared_memory</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I call the function <code>text2dict</code> which later turned into its own <a href="https://github.com/mmlind/text2dict/">Github project</a>. When I run the code I get the following result:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="ln"> 1</span><span class="cl">Execution time: 756 seconds
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"># of tokens in corpus: [  2,796,219,305]
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"># of tokens in dict:   [      9,925,231]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">Top 10:
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"># 1:  187,816,162 = the
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"># 2:   94,989,894 = of
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"># 3:   79,019,494 = and
</span></span><span class="line"><span class="ln">10</span><span class="cl"># 4:   76,509,997 = in
</span></span><span class="line"><span class="ln">11</span><span class="cl"># 5:   52,986,487 = to
</span></span><span class="line"><span class="ln">12</span><span class="cl"># 6:   30,276,740 = was
</span></span><span class="line"><span class="ln">13</span><span class="cl"># 7:   23,445,023 = is
</span></span><span class="line"><span class="ln">14</span><span class="cl"># 8:   23,133,852 = for
</span></span><span class="line"><span class="ln">15</span><span class="cl"># 9:   22,621,486 = on
</span></span><span class="line"><span class="ln">16</span><span class="cl">#10:   22,363,826 = as
</span></span></code></pre></div><p>I’m getting pumped. Creating the dictionary sequentially via C takes 756 seconds, compared to 3,430 seconds from the first Python script, and 1,402 seconds from the second Python script. OMG. From now on, I will have to wait <em>only</em> 12 minutes each time I create the dictionary. Life is beautiful. Mine just extended another 10 minutes.</p>
<h2 id="parallel-processing-of-text-corpora">Parallel processing of text corpora</h2>
<p>After a short moment of rejoicing, I recall my original objective: <strong>utilizing multiple cores</strong>. Alright. Let’s do this. I’m rolling up the sleeves. What hardware shall I use for the ride?</p>
<h3 id="the-hardware">The hardware</h3>
<p>The first machine is my Mac Mini. I ordered it with full specs: 6 cores, 64 GB RAM.</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt=""
      
        class="image_figure image_internal image_unprocessed"
        src="mac_sysinfo.png"
      
      
    />

    </picture>
</figure>
</p>
<p>Can I trust the system info? Let me check the number of processing units via code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">long</span> <span class="n">nproc</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_NPROCESSORS_ONLN</span><span class="p">);</span>
</span></span></code></pre></div><p>The <em>sysconf</em> returns ... <strong>12</strong>. Why the difference to the 6 cores that were reported by the system configuration window? <a href="https://de.wikipedia.org/wiki/Hyper-Threading">Hyperthreading</a>. 6 <strong>physical</strong> cores are presented as 12 <strong>virtual</strong> cores to the operating system.</p>
<p>Anyway. 6 or 12, not much of a difference, I’m thinking. If I want to investigate the scalability of parallel processing I better prepare a bit more firepower.</p>
<h3 id="utilizing-azure-cloud-servers">Utilizing Azure cloud servers</h3>
<p>Enter Azure cloud servers. Microsoft’s Azure cloud offering is immense. You can order servers ranging from 1 to <strong>416 cores</strong>. Yes, that’s <strong>four hundred sixteen cores</strong>. And not only does the ‘M416ms_v2’ come with a whopping <strong>416 cores</strong>, but it also boasts <strong>11 TB of RAM</strong>. What?! Yes, that’s not a typo. It’s a T, not a G. That’s more than 5 times my hard drive capacity ... in RAM.</p>
<p>Naturally, I want to include this beast in my testing and reach out to Azure support to get my hands on it. I am, however, advised that these servers require a corporate account. Why? Well, for one, I guess, because this machine runs at $95k per month. That’s “k” as in kilo. Oops. I know some people like <a href="https://mijailovic.net/2020/03/28/azure-money-burning/">burning money on Azure</a> but this exceeds my budget just a tiny little bit.</p>
<p>Instead, I pick 2 other models. The first one is the “F64s_v2” with 64 cores and 128 GB RAM, running Debian Buster. I call it my “VM64”. I fire it up and print some system info from the console:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="line"><span class="ln"> 1</span><span class="cl">$ lscpu
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">Architecture:        x86_64
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">CPU op-mode<span class="o">(</span>s<span class="o">)</span>:      32-bit, 64-bit
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">Byte Order:          Little Endian
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">Address sizes:       <span class="m">46</span> bits physical, <span class="m">48</span> bits virtual
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">CPU<span class="o">(</span>s<span class="o">)</span>:              <span class="m">64</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">On-line CPU<span class="o">(</span>s<span class="o">)</span> list: 0-63
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">Thread<span class="o">(</span>s<span class="o">)</span> per core:  <span class="m">2</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">Core<span class="o">(</span>s<span class="o">)</span> per socket:  <span class="m">16</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">Socket<span class="o">(</span>s<span class="o">)</span>:           <span class="m">2</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">NUMA node<span class="o">(</span>s<span class="o">)</span>:        <span class="m">2</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">Vendor ID:           GenuineIntel
</span></span><span class="line"><span class="ln">14</span><span class="cl">CPU family:          <span class="m">6</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">Model:               <span class="m">85</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">Model name:          Intel<span class="o">(</span>R<span class="o">)</span> Xeon<span class="o">(</span>R<span class="o">)</span> Platinum <span class="m">8168</span> CPU @ 2.70GHz
</span></span><span class="line"><span class="ln">17</span><span class="cl">Stepping:            <span class="m">4</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">CPU MHz:             2693.876
</span></span><span class="line"><span class="ln">19</span><span class="cl">BogoMIPS:            5387.75
</span></span><span class="line"><span class="ln">20</span><span class="cl">Virtualization:      VT-x
</span></span><span class="line"><span class="ln">21</span><span class="cl">Hypervisor vendor:   Microsoft
</span></span><span class="line"><span class="ln">22</span><span class="cl">Virtualization type: full
</span></span><span class="line"><span class="ln">23</span><span class="cl">L1d cache:           32K
</span></span><span class="line"><span class="ln">24</span><span class="cl">L1i cache:           32K
</span></span><span class="line"><span class="ln">25</span><span class="cl">L2 cache:            1024K
</span></span><span class="line"><span class="ln">26</span><span class="cl">L3 cache:            33792K
</span></span><span class="line"><span class="ln">27</span><span class="cl">NUMA node0 CPU<span class="o">(</span>s<span class="o">)</span>:   0-31
</span></span><span class="line"><span class="ln">28</span><span class="cl">NUMA node1 CPU<span class="o">(</span>s<span class="o">)</span>:   32-63
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="line"><span class="ln">1</span><span class="cl">$ free --giga
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">              total        used        free      shared  buff/cache   available
</span></span><span class="line"><span class="ln">4</span><span class="cl">Mem:            <span class="m">135</span>           <span class="m">2</span>         <span class="m">132</span>           <span class="m">0</span>           <span class="m">0</span>         <span class="m">131</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">Swap:             <span class="m">0</span>           <span class="m">0</span>           <span class="m">0</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">SHELL
</span></span></code></pre></div><p>Yeah. Loading the Wikidump file into memory shouldn’t be a problem on this one.</p>
<p>The second cloud server is the “M128_s” with 128 cores and 2 TB RAM, also running Debian Buster. I call it my “VM128”.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="line"><span class="ln"> 1</span><span class="cl">$ lscpu
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">Architecture:        x86_64
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">CPU op-mode<span class="o">(</span>s<span class="o">)</span>:      32-bit, 64-bit
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">Byte Order:          Little Endian
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">Address sizes:       <span class="m">46</span> bits physical, <span class="m">48</span> bits virtual
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">CPU<span class="o">(</span>s<span class="o">)</span>:              <span class="m">128</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">On-line CPU<span class="o">(</span>s<span class="o">)</span> list: 0-127
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">Thread<span class="o">(</span>s<span class="o">)</span> per core:  <span class="m">2</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">Core<span class="o">(</span>s<span class="o">)</span> per socket:  <span class="m">16</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">Socket<span class="o">(</span>s<span class="o">)</span>:           <span class="m">4</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">NUMA node<span class="o">(</span>s<span class="o">)</span>:        <span class="m">4</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">Vendor ID:           GenuineIntel
</span></span><span class="line"><span class="ln">14</span><span class="cl">CPU family:          <span class="m">6</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">Model:               <span class="m">85</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">Model name:          Intel<span class="o">(</span>R<span class="o">)</span> Xeon<span class="o">(</span>R<span class="o">)</span> Platinum 8280M CPU @ 2.70GHz
</span></span><span class="line"><span class="ln">17</span><span class="cl">Stepping:            <span class="m">7</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">CPU MHz:             2693.670
</span></span><span class="line"><span class="ln">19</span><span class="cl">BogoMIPS:            5387.34
</span></span><span class="line"><span class="ln">20</span><span class="cl">Virtualization:      VT-x
</span></span><span class="line"><span class="ln">21</span><span class="cl">Hypervisor vendor:   Microsoft
</span></span><span class="line"><span class="ln">22</span><span class="cl">Virtualization type: full
</span></span><span class="line"><span class="ln">23</span><span class="cl">L1d cache:           32K
</span></span><span class="line"><span class="ln">24</span><span class="cl">L1i cache:           32K
</span></span><span class="line"><span class="ln">25</span><span class="cl">L2 cache:            1024K
</span></span><span class="line"><span class="ln">26</span><span class="cl">L3 cache:            39424K
</span></span><span class="line"><span class="ln">27</span><span class="cl">NUMA node0 CPU<span class="o">(</span>s<span class="o">)</span>:   0-31
</span></span><span class="line"><span class="ln">28</span><span class="cl">NUMA node1 CPU<span class="o">(</span>s<span class="o">)</span>:   32-63
</span></span><span class="line"><span class="ln">29</span><span class="cl">NUMA node2 CPU<span class="o">(</span>s<span class="o">)</span>:   64-95
</span></span><span class="line"><span class="ln">30</span><span class="cl">NUMA node3 CPU<span class="o">(</span>s<span class="o">)</span>:   96-127
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="line"><span class="ln">1</span><span class="cl">$ free --giga
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">              total        used        free      shared  buff/cache   available
</span></span><span class="line"><span class="ln">4</span><span class="cl">Mem:           <span class="m">2164</span>           <span class="m">8</span>        <span class="m">2155</span>           <span class="m">0</span>           <span class="m">0</span>        <span class="m">2150</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">Swap:             <span class="m">0</span>           <span class="m">0</span>           <span class="m">0</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">SHELL
</span></span></code></pre></div><p>All set. Equipped with my cute Mac Mini and 2 potent cloud titans, I’m ready to take on the parallel processing of Wikipedia.</p>
<h3 id="the-basic-design">The basic design</h3>
<p>I first assess each step of the overall algorithm from 2 angles: how does it impact performance, and how easy or difficult is it to run this step in parallel.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Steps for creating dictionary</th>
<th style="text-align:center">Impact on performance</th>
<th style="text-align:center">Difficulty to parallelize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Reading corpus word by word</td>
<td style="text-align:center">High</td>
<td style="text-align:center">Low</td>
</tr>
<tr>
<td style="text-align:left">Inserting words into hash table</td>
<td style="text-align:center">High</td>
<td style="text-align:center">Middle</td>
</tr>
<tr>
<td style="text-align:left">Copying unique words into array</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">Middle</td>
</tr>
<tr>
<td style="text-align:left">Sorting array by word count</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">High</td>
</tr>
</tbody>
</table>
<p>Good. Fortunately, the steps with a <strong>high</strong> impact on performance (reading the corpus, and inserting words into a hash table) are not difficult to parallelize. The steps with a low impact on performance (copying the words into an array and sorting the array) are not worthwhile spending a lot of extra time on. I just leave them as they are.</p>
<h4 id="reading-text-in-parallel">Reading text ‘in parallel’</h4>
<p>To read the corpus in parallel, via multiple cores, I need to divide the text into multiple segments and have each core read a different segment. Therefore, I define an object <code>range_t</code> that represents a corpus segment by its start and end <strong>offset</strong>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">// defines a segment via its first and last offset
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">range_t</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">    <span class="n">size_t</span> <span class="n">from</span><span class="p">;</span>    <span class="c1">// included
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">size_t</span> <span class="n">to</span><span class="p">;</span>      <span class="c1">// excluded
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">range_t</span><span class="p">;</span>
</span></span></code></pre></div><p>Yes. Both <code>from</code> and <code>to</code> are <em>offsets</em> relative to the corpus text and not memory addresses or pointers.</p>
<blockquote>
<p>Beware that while the <code>from</code> offset is included in the range, i.e. it’s <em>part</em> of the segment, the <code>to</code> offset is not.</p>
</blockquote>
<p>Next, I divide the corpus into as many segments as there are cores, or processes, so that each process can work independently on a different text segment.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">range_t</span> <span class="o">*</span><span class="nf">create_segments</span><span class="p">(</span><span class="n">size_t</span> <span class="n">total_size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nsegs</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&lt;</span> <span class="n">nsegs</span><span class="p">){</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;Error creating segments. ABORT&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nsegs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">range_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">size_t</span> <span class="n">seg_size</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">/</span> <span class="n">nsegs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">seg_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">&lt;</span><span class="n">nsegs</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="c1">//  divide into equally-sized segments
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="c1"></span>        <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="n">seg_idx</span> <span class="o">*</span> <span class="n">seg_size</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">to</span>   <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span> <span class="o">+</span> <span class="n">seg_size</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">        
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="c1">// always set the end of the last range to the end of the memory range
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">==</span> <span class="n">nsegs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">segs</span><span class="p">[</span><span class="n">nsegs</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">total_size</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">        
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The problem with this approach is that I may mistakenly chop the file in the middle of a word, or possibly even in the middle of a character. Remember multi-byte characters in UTF8? Therefore, I adjust the split points between segments by simply moving each point forward to the beginning of the next token.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">range_t</span> <span class="o">*</span><span class="nf">create_corpus_segments</span><span class="p">(</span><span class="n">size_t</span> <span class="n">corpus_size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nsegs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// first use default, i.e. divide into equally-sized segments
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">create_segments</span><span class="p">(</span><span class="n">corpus_size</span><span class="p">,</span> <span class="n">nsegs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">size_t</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="c1">// move the split point to the right to the start of the next token
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">seg_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">&lt;</span><span class="n">nsegs</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="n">pos</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">corpus_size</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="c1">// don&#39;t shift the 1st segment since it always starts at 0
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">seg_idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span>  <span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">to</span>   <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Ok. So far, so good. To read the text in parallel I won’t need much else. I can reuse the other functions I built before. One critical piece though is missing.</p>
<h3 id="multiprocessing-and-multithreading">Multiprocessing and multithreading</h3>
<p>The 2 main technical options for a developer to implement parallel processing are <strong>multiprocessing</strong> and <strong>multithreading</strong>. Both execute multiple tasks simultaneously by spinning-off separate <strong>processes</strong> or <strong>threads</strong> that run independently of the main process.</p>
<p>For spinning-off multiple processes, I use the following general <code>fork</code> boilerplate code. All I need to add is my <code>get_next_token</code> function and tuck it into the loop.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl">    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">         
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">             
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">             <span class="c1">// code that shall be executed by each child process
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>             
</span></span><span class="line"><span class="ln">11</span><span class="cl">             <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello! I am process [%d].</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">             <span class="c1">/// ...
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>             
</span></span><span class="line"><span class="ln">15</span><span class="cl">             
</span></span><span class="line"><span class="ln">16</span><span class="cl">             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">         
</span></span><span class="line"><span class="ln">19</span><span class="cl">     <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="c1">// wait for all child processes to finish
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// parent process proceeds....
</span></span></span></code></pre></div><p>At the end of the function, I need to make the parent process <code>wait</code> until all child processes have <code>exit</code>ed. Not waiting for child processes to finish is a frequent source of errors. The <code>wait</code> command also allows me to bring the application logic back into a single process.</p>
<blockquote>
<p>Beware that in the above <code>fork</code> boilerplate code <code>nproc</code> represents the number of processes, not the number of processors. You could run more processes than there are actual processing units or cores.</p>
</blockquote>
<h3 id="creating-the-dictionary-in-parallel">Creating the dictionary in parallel</h3>
<p>So. I finished reading the text, and feel tempted to pat myself on the back. After all, this was the heavy lifting, wasn’t it? Surely not. I just enjoyed my appetizer, and am moving on to the main course.</p>
<p>When multiple processes simultaneously make changes to the same variable (a.k.a. they need to <a href="/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes">write to the same shared memory</a>), they may conflict, or overlap, with each other. So-called race conditions between processes will cause unpredictable results. Oh.</p>
<h4 id="how-to-address-race-conditions-between-multiple-tasks">How to address <em>race conditions</em> between multiple tasks?</h4>
<p>I can resolve the problem of race conditions in 3 ways:</p>
<ul>
<li><strong>Avoid</strong> race conditions in the first place. Do not have multiple processes write to the <strong>same</strong> memory. Instead, each process writes to a <strong>different</strong> memory section, and sections are merged via a single process at the end.</li>
<li><strong>Synchronize</strong> memory access by having each process first lock the memory that it wants to write to. Other processes cannot access memory that is <strong>locked</strong> and need to wait until the locking process unlocks the memory again.</li>
<li><strong>Communicate</strong> between different processes in other ways than through memory sharing, such as sending messages or signals to each other. (Note to self: remember this nice tutorial on IPC called <a href="http://beej.us/guide/bgipc/html/multi/">Beej’s Guide to Unix IPC</a>.)</li>
</ul>
<p>I choose to test and compare all three, via different technical implementations.</p>
<p>After some initial research, I jot down the following 4 methods for me to investigate:</p>
<ul>
<li>multiple hash tables (<strong>avoid</strong>),</li>
<li>semaphores and mutexes (<strong>synchronize</strong>), and</li>
<li>pipes (<strong>communicate</strong>).</li>
</ul>
<p>In particular, I want to examine these 4 methods from 2 perspectives: <strong>performance</strong> and <strong>scalability</strong>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parallel processing technique</th>
<th style="text-align:center"><strong>Avoid</strong> simultaneous memory access</th>
<th style="text-align:center"><strong>Synchronize</strong> simultaneous memory access</th>
<th style="text-align:center"><strong>Communicate</strong> between processes (IPC)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Multiprocessing with separate hashes</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Multiprocessing with semaphores</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Multithreading with mutexes</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">Multiprocessing with pipes for IPC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
</tr>
</tbody>
</table>
<h3 id="methods-for-parallel-text-processing">Methods for parallel text processing</h3>
<p>Off I go to implement the four techniques one by one.</p>
<h4 id="1-multiprocessing-with-separate-hashes">1. Multiprocessing with separate hashes</h4>
<p>The easiest option to address <strong>race conditions</strong> is to <strong>avoid</strong> them. Instead of letting multiple processes write to the <strong>same</strong> memory, I can have each process write into its own <strong>separate</strong> hash table first and then merge the hash tables later. As easy as ABC.</p>
<p>I only need to make 3 modifications to the previous code:</p>
<ul>
<li>(A) create multiple hash tables,</li>
<li>(B) make each process insert tokens into a different hash table, and</li>
<li>(C) merge all hash tables into one at the end.</li>
</ul>
<h4 id="create-multiple-hash-tables">Create multiple hash tables</h4>
<p>Before I create more than one hash table I need to assess the memory impact. The length of the hash table I used before ranges from 14 to 80 million buckets. If a single <code>corpus_token_t</code> element occupies up to 24 bytes, my little friend <code>htab</code> demands a humongous 1.8 GB of RAM. And that’s just for one. If I breed 12 of these guys, I’ll have to kiss goodbye to 22 GB of memory. Running 128 processes? 230 GB of memory. Ouch.</p>
<p>A few seconds of silence. ... “So what!” This is not my Sanyo MBC 550 anymore, coding Pascal on 128 KB of RAM. In only a few years, the average Mac or Surface laptop ships with at least several TB of RAM. Let’s face it. Memory is ‘cheap’, and the machines I use for this exercise surely can handle the magnitude. I give it a go.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htabs</span> <span class="o">=</span> <span class="n">map_shared_memory</span><span class="p">(</span><span class="n">PROCESS_COUNT</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</span></span></code></pre></div><p>This time, I cannot create the hash table simply via <code>malloc</code>. Instead, I define all of them as shared memory so that the parent process can later consolidate all individual tables into a single one.</p>
<h4 id="make-each-process-insert-tokens-into-a-different-hash-table">Make each process insert tokens into a different hash table</h4>
<p>Next, I need to slightly amend the function that inserts tokens into the hash table. I just add a process identifier <code>pidx</code> which I multiply by the hash size to determine the correct table for each process.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">insert_token_pp</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="n">size_t</span> <span class="n">hidx_pp</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">hidx_pp</span> <span class="o">=</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">;</span>   <span class="c1">//    &lt;-- pick the hash table for this process
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="c1"></span>        
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// check if this bucket is empty
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">            
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="c1">// if the same token already exists in the hash table increment its counter
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span> <span class="o">+</span> <span class="n">hidx_pp</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="c1">// otherwise move forward to the next bucket
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            
</span></span><span class="line"><span class="ln">25</span><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">        
</span></span><span class="line"><span class="ln">31</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>BTW: I am adding <code>\_pp</code> at the end of a function to signal this function is processed in parallel by multiple processes or threads.</p>
</blockquote>
<h4 id="merge-all-hash-tables-into-one">Merge all hash tables into one</h4>
<p>After all processes have finished reading their corpus segment and adding the respective tokens into their process-specific hash table, I need to consolidate all hash tables into one.</p>
<p>For merging hash tables I cannot simply copy over the tokens and sum up their counts. The hash index of a token in one table may differ from the hash index of the same token in another table. Why? Remember that in case of a collision, the insert function moves the hash index gradually forward until an empty bucket is found. Therefore, the hash index for any given token depends on the timing.</p>
<p>Specifically, it depends on what other tokens have been processed so far. I, therefore, merge the tables by simply using the previous <code>insert_token</code> function.</p>
<p>But how long is this going to take? Can I not parallelize the merging to further speed up the whole process? Sure. I divide the table into multiple segments, similar to what I did with the corpus text before. Then, I have each process merge tokens of a specific segment only. This ensures that there are no overlaps when a token is added. My merge function looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">corpus_token_t</span> <span class="o">*</span><span class="nf">merge_hashtables</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htabs</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// create a new empty hash table that will hold the merged results of all processes&#39; hash tables
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span> <span class="o">=</span> <span class="n">map_shared_memory</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">range_t</span> <span class="o">*</span><span class="n">hsegs</span> <span class="o">=</span> <span class="n">create_segments</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span><span class="p">,</span> <span class="n">PROCESS_COUNT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">hidx</span><span class="o">=</span><span class="n">hsegs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span> <span class="n">hidx</span><span class="o">&lt;</span><span class="n">hsegs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span> <span class="n">hidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">hnum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">hnum</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">hnum</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">                    <span class="n">corpus_token_t</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">htabs</span><span class="p">[</span><span class="n">hnum</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">                    <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">insert_token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="n">wait_for_child_processes</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">hsegs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">    
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">return</span> <span class="n">htab</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Done. I’m putting the pieces together and am dying to see the result. How long will my first method for creating the dictionary via parallel processing take? I run the algorithm on my computer using all of its 12 virtual cores.</p>
<p>Yippee! 111 seconds. Wow! That’s about 6 times faster than the single process C program and about 11 times faster than the second Python script. My wait time for creating a Wikipedia dictionary got slashed from 57 minutes to 23 minutes, to 13 minutes, to now less than 2 minutes.</p>
<p><strong>Performance</strong> ... check. What about <strong>scalability</strong>?</p>
<p>I continue and deploy my code on the 2 Azure cloud servers.</p>
<p>Nope. Lesson #1 in the limitations of multiprocessing. The VM64 reaches its peak performance at 32 processes with an execution time of 50 seconds. Adding more cores, either in the VM64 or in the VM128, does not yield better performance. At some point, the cost of managing memory gobbles up all benefits of multiprocessing. <strong>Scalability</strong> ... X, beep.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Multiprocessing with separate hashes</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number of processes</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Processing time in seconds</td>
<td style="text-align:right">314</td>
<td style="text-align:right">126</td>
<td style="text-align:right">111</td>
<td style="text-align:right">73</td>
<td style="text-align:right">62</td>
<td style="text-align:right"><strong>50</strong></td>
<td style="text-align:right">68</td>
<td style="text-align:right">72</td>
<td style="text-align:right">97</td>
<td style="text-align:right">121</td>
</tr>
</tbody>
</table>
<p>And off to round two.</p>
<h3 id="2-multiprocessing-with-semaphores-for-memory-synchronization">2. Multiprocessing with semaphores for memory synchronization</h3>
<p>Next, I want to test using memory synchronization which should help to address the memory problem associated with the previous method. My first option for memory synchronization are <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphores</a>.</p>
<p>Semaphores are numeric registers that allow processes to make atomic operations. Atomic in this context means that an operation is guaranteed to be completed in one piece without interference from any other process. You can set a semaphore to a certain value, normally by incrementing or decrementing, and the operating system will ensure that only 1 process can access a defined resource, e.g. a memory address, at the same time.</p>
<p>Hhmmm… I’ve played <a href="/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes">with semaphores before</a> and don’t hold them dearly.</p>
<p>Let’s see. I do want to give it a shot. To implement this technique I need to make only 2 changes: create and initialize one semaphore per hash table bucket, and lock (unlock) the respective semaphore before (after) I access the hash table.</p>
<h4 id="create-and-initialize-one-semaphore-per-hash-table-bucket">Create and initialize one semaphore per hash table bucket</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#define SEMAPHORES_PER_SET 10000
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="kt">int</span> <span class="o">*</span><span class="nf">create_semaphore_sets</span><span class="p">(){</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">int</span> <span class="n">semset_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">semset_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semget&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    
</span></span><span class="line"><span class="ln">12</span><span class="cl">    
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="c1">// reset all counters and semaphores
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="c1"></span>    <span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">setid</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">setid</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">setid</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">semid</span><span class="o">&lt;</span><span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span> <span class="n">semid</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="k">if</span><span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="n">semid</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;semctl init for set %d sem %d: error %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">setid</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="k">return</span> <span class="n">semset_ids</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="kt">void</span> <span class="nf">remove_semaphore_sets</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="kt">int</span> <span class="n">semset_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semctl remove&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="lock-and-unlock-the-semaphore-before-and-after-access">Lock and unlock the semaphore before and after access</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">lock_semaphore</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">hidx</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="kt">int</span> <span class="n">setid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hidx</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">hidx</span> <span class="o">%</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">semid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// lock token
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semop&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="kt">void</span> <span class="nf">unlock_semaphore</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">hidx</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="kt">int</span> <span class="n">setid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hidx</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">hidx</span> <span class="o">%</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">semid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// unlock token
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semop&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>With so many semaphores, I need to assign each semaphore to serve a particular token or hash table bucket. I use the token’s hash index <code>hidx</code> to do so. But, for the design to work, I will require about 30-40 million semaphores in total.</p>
<p>In most operating systems, however, there is a limit to the number of semaphores. I’m starting to wonder whether semaphores are the right tool for the job. While in Linux I can change the limit by editing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SH" data-lang="SH"><span class="line"><span class="ln">1</span><span class="cl">/proc/sys/kernel/sem
</span></span></code></pre></div><p>I wasn’t able to increase the limit high enough on my Mac to process the full corpus. Therefore, I proceed with testing this method on the Azure servers only. The result is devastating.</p>
<p>Slow as molasses, the semaphores keep crawling for 12,833 and 14,398 seconds to process the full English Wikipedia dump with 32 and 64 cores respectively. That’s almost 4 hours compared to less than 1 minute using the previous method. OMG. What an epic fail. Or, to be fair, just the wrong tool for the job. Locking and unlocking a semaphore requires making a low-level operating system call each time which simply does not scale.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Multiprocessing with semaphores</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number of processes</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Processing time in seconds</td>
<td style="text-align:right"><strong>3,762</strong></td>
<td style="text-align:right">3,866</td>
<td style="text-align:right">3,987</td>
<td style="text-align:right">4,127</td>
<td style="text-align:right">12,833</td>
<td style="text-align:right">14,398</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
</tr>
</tbody>
</table>
<p>* I did not complete the testing for semaphores on the VM128 due to an increasingly slow performance with higher process count.</p>
<blockquote>
<p>One of the reasons semaphores are rather slow is that they work across processes. You could communicate between entirely different programs on the same machine which goes beyond what I need here.</p>
</blockquote>
<h3 id="3-multithreading-with-mutexes-for-memory-synchronization">3. Multithreading with mutexes for memory synchronization</h3>
<p>Round 3. <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">Mutexes</a> are binary, process-specific registers that can be used to control access to a resource and support <strong>atomic</strong> operations in a multitask environment. Their usage is straight forward and the program design resembles what I’ve done above for <strong>semaphores</strong>. With one important difference. <strong>Mutexes</strong> do not work <strong>across</strong> processes but only <strong>within</strong> a single process.</p>
<p>Therefore, I switch from <strong>multiprocessing</strong> to <strong>multithreading</strong> and make the following 4 changes to the code:</p>
<ul>
<li>introduce a ‘thread object’,</li>
<li>create and initialize one mutex per hash table bucket,</li>
<li>define a start function for each thread, and</li>
<li>lock (unlock) each mutex before (after) accessing the respective token.</li>
</ul>
<h4 id="introduce-a-new-thread-object">Introduce a new ‘thread object’</h4>
<p>One of the differences between using <code>pthread</code>s and <code>fork</code> is that when you send off a new thread you can only give it a single variable, or pointer, for the journey.</p>
<p>Therefore, I create a payload object <code>corpus_thread_t</code> which references all the variables each thread commands for its work.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">corpus_thread_t</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="kt">char</span>            <span class="o">*</span><span class="n">corpus</span><span class="p">;</span>        <span class="c1">// reference to corpus
</span></span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="c1"></span>    <span class="n">size_t</span>          <span class="n">from_off</span><span class="p">;</span>       <span class="c1">// reference to hash table
</span></span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1"></span>    <span class="n">size_t</span>          <span class="n">to_off</span><span class="p">;</span>         <span class="c1">// reference to mutexes array
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="n">corpus_token_t</span>  <span class="o">*</span><span class="n">htab</span><span class="p">;</span>          <span class="c1">// reference to corpus segment start
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span>    <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span><span class="p">;</span>          <span class="c1">// reference to corpus segment end
</span></span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">corpus_thread_t</span><span class="p">;</span>
</span></span></code></pre></div><p>Before I can inject the payload into the start function of a thread I need to initialize it with all the required values:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">corpus_thread_t</span> <span class="o">*</span><span class="nf">create_corpus_threads</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">corpus_thread_t</span> <span class="o">*</span><span class="n">cts</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PROCESS_COUNT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_thread_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">corpus</span>    <span class="o">=</span> <span class="n">corpus</span><span class="p">;</span>                  
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">htab</span>      <span class="o">=</span> <span class="n">htab</span><span class="p">;</span>                    
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mtxs</span>      <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from_off</span>  <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>       
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to_off</span>    <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>         
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">return</span> <span class="n">cts</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Ok. Each thread now receives an individualized <code>corpus_thread_t</code> payload object as a single variable. Only the mutexes are still missing. I add those in the next step.</p>
<h4 id="create-and-initialize-one-mutex-per-hash-table-bucket">Create and initialize one mutex per hash table bucket</h4>
<p>My design prescribes one mutex per hash table bucket. Fortunately, C offers a built-in <code>pthread_mutex_t</code> object so I do not need to dream up my own. I just create an array of these mutex objects matching the size of the hash table. Before I wave them off with <code>pthread_create</code> I quickly toss in the missing reference to the mutexes.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">process_corpus_multithreading</span><span class="p">(</span><span class="n">corpus_thread_t</span> <span class="o">*</span><span class="n">cts</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_HASH_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">pthread_mutex_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">PROCESS_COUNT</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="c1">// add the mutexes pointer into the thread objects
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="c1"></span>        <span class="n">cts</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">mtxs</span> <span class="o">=</span> <span class="n">mtxs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        
</span></span><span class="line"><span class="ln">13</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">process_corpus_pt</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cts</span><span class="p">[</span><span class="n">t</span><span class="p">]))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;pthread_create&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="c1">// wait for threads to exit
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">t</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">t</span><span class="p">],</span><span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="c1">// remove the mutexes pointers
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mtxs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">mtxs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>Beware two differences of multithreading to multiprocessing: first, the hash table variable does not need to be a <code>mmap</code> shared memory. A simple <code>malloc</code> suffices since all threads share the same global memory space. Second, the parent process does not <code>wait</code> for a thread to finish but needs to join the thread. If you don’t <code>pthread_join</code> threads at the end you may get unpredictable results.</p>
</blockquote>
<h4 id="define-a-start-function-for-each-thread">Define a start function for each thread</h4>
<p>Each thread requires a start function. If you reviewed the above code you will have noticed that it references a function <code>process_corpus_pt</code> and passes the payload <code>corpus_thread_t</code> struct in the form of <code>cts[t]</code> to it. This is what my start function looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="nf">process_corpus_pt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// thread index
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="n">corpus_thread_t</span> <span class="n">ct</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">corpus_thread_t</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">size_t</span> <span class="n">str_pos</span> <span class="o">=</span> <span class="n">ct</span><span class="p">.</span><span class="n">from_off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">size_t</span> <span class="n">str_end</span> <span class="o">=</span> <span class="n">ct</span><span class="p">.</span><span class="n">to_off</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">str_pos</span> <span class="o">&lt;</span> <span class="n">str_end</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">ct</span><span class="p">.</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str_pos</span><span class="p">,</span> <span class="n">str_end</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">insert_token_mt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">htab</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">corpus</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">mtxs</span><span class="p">);</span>       
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>   
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>I reference a new <code>insert_token_mt</code> function because the locking and unlocking for threads during a hash table insert work differently.</p>
<h4 id="lock-and-unlock-the-mutex-before-and-after-token-access">Lock and unlock the mutex before and after token access</h4>
<p>The <code>pthread</code> library generously offers a lock and unlock function. Awesome. Thank you. I simply add the locking and unlocking into the thread-specific <code>insert_token_mt</code> function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">insert_token_mt</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="c1">// check if this bucket is empty
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">            
</span></span><span class="line"><span class="ln">12</span><span class="cl">            <span class="c1">// if the same token already exists in the hash table increment its counter
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="o">+</span><span class="n">hidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">                <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">                <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">                
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="c1">// otherwise move forward to the next bucket
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_LENGTH</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">            
</span></span><span class="line"><span class="ln">26</span><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">        <span class="p">}</span>   
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="p">}</span>   
</span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Voila. Contender #3 is entering the ring. I can hardly sit tight. Will mutexes knock-out semaphores? Well, that’s not really the question, I hope. Running a BASIC script on a 286 can do that.</p>
<p>Yup. I’m happy with what I see. Creating the dictionary for the English Wikipedia dump takes only 122 seconds running 12 threads on my Mac Mini. That’s the second bests result so far. It’s a notch slower than the multiple hash tables method but consumes by far less memory. Nice. But how does it scale?</p>
<p>It doesn’t. Again. When I test this option on the cloud servers I find mutexes scale well to about 16 threads. At this point, performance hits a ceiling, and adding threads slows things down. Hmm. That’s unexpected. The overhead for locking and unlocking, plus the wait time if more than one thread wants to access the same token, eat up all the time gained from parallel processing.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Multiprocessing with separate hashes</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number of processes</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Processing time in seconds</td>
<td style="text-align:right">346</td>
<td style="text-align:right">145</td>
<td style="text-align:right">122</td>
<td style="text-align:right">119</td>
<td style="text-align:right"><strong>118</strong></td>
<td style="text-align:right">138</td>
<td style="text-align:right">159</td>
<td style="text-align:right">204</td>
<td style="text-align:right">227</td>
<td style="text-align:right">246</td>
</tr>
</tbody>
</table>
<h3 id="4-multiprocessing-with-pipes-for-ipc">4. Multiprocessing with pipes for IPC</h3>
<p>This leaves me with one last candidate to assess: <a href="http://www.gnu.org/software/libc/manual/html_node/Pipes-and-FIFOs.html">pipes</a>. Instead of communicating with each other by accessing the same memory, different processes send information in the form of messages to each other.</p>
<blockquote>
<p>The interesting aspect of this messaging-based approach is that it should be scalable not only across multiple processes on the <strong>same</strong> machine, but also across multiple machines, if <strong>pipes</strong>, for example, were replaced by <strong>sockets</strong>.</p>
</blockquote>
<h4 id="messaging-based-design">Messaging-based design</h4>
<p>All 3 previous methods shared a similar design. Each process, or thread, works on a different segment of the corpus, reading and writing tokens. A messaging-based method must be designed differently. I will have 2 types of processes: one that reads, and one that writes. Tokens are sent as small messages via a pipe from a corpus-reading-process to a <strong>hash-table-writing-process</strong>.</p>
<h4 id="asynchronous-inter-process-communication">Asynchronous inter process communication</h4>
<p>One advantage of pipes is that they work fully <strong>asynchronous</strong>. The sender’s rate of <strong>writing</strong> into the pipe is not limited by the recipient’s rate of reading from the pipe. The pipe serves as a buffer and never loses a message. Huh. I can have different designs where there are either more senders or more receivers, depending on where I suspect a bottleneck. I could, for example, have only 4 processes that read the corpus (because I suspect this to be faster) and have 8 processes create the dictionary (because I suspect this to be slower). But how many pipes would I need in this case?</p>
<p>To avoid overlaps between processes I split the hash table into multiple segments and assign each hash-table-writing-process to one particular segment. Each process only receives the tokens that fit into its respective hash table segment.</p>
<p>Therefore, the number of pipes should match the number of processes that write to the hash table – which are the processes that read from the pipe BTW.</p>
<blockquote>
<p>Be careful with the terms <em>read</em> and <em>write</em> in this context. <em>Reading</em> from the corpus means <em>writing</em> into the pipe. <em>Reading</em> from the pipe means <em>writing</em> into the hash table.</p>
</blockquote>
<p>The processes that read the corpus know which pipe to send a token into by determining its hash segment via a reverse lookup. The following diagram summarizes this design – using an example of 4 processes that read the corpus, and 8 processes that write into the hash table.</p>
<p><figure>
  <picture>

    
      
        
        
        
        
        
        
    <img
      loading="lazy"
      decoding="async"
      alt="TEXT2DICT: Inter process communication via pipes"
      
        class="image_figure image_internal image_unprocessed"
        src="pipes_ipc_design_diagram.png"
      
      
    />

    </picture>
</figure>
</p>
<p>Alright. Done the design, moving on to implementation. I add the following 4 functions to the code: create pipes, open and close pipes, send a token into a pipe, and read a token from a pipe.</p>
<h4 id="create-pipes">Create pipes</h4>
<p>A pipe is defined as an array of 2 integers. The 2 integers represent the 2 <strong>“channels”</strong> of the <strong>pipe</strong>. The 1st channel is for messages to <strong>come in</strong>, and the 2nd channel is for messages to <strong>go out</strong>. When the sender and receiver exchange information unidirectional, which is normally the case, I need only one of the channels and must close the other. I’ll come back to that later.</p>
<p>For coding convenience, I define pipes via below <code>typedef</code> which helps to access the incoming and outgoing channel of the <strong>pipe</strong> via a <code>.in</code> and <code>.out</code> attribute. I feel this keeps the code easier to read and avoids the usage of multi-dimensional arrays.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">pipe_arr_t</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pipe_t</span><span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">    <span class="kt">int</span> <span class="n">in</span><span class="p">;</span>     <span class="c1">// incoming
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">out</span><span class="p">;</span>    <span class="c1">// outgoing
</span></span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">pipe_t</span><span class="p">;</span>
</span></span></code></pre></div><p>The downside of this <code>typedef</code>fing is an ugly cast for creating the pipes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">pipe_t</span> <span class="o">*</span><span class="nf">create_pipes</span><span class="p">(</span><span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="c1">// check that 80% capacity of the file descriptor limit is still available
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">npipes</span><span class="o">&gt;</span><span class="n">MAX_FILE_DESCRIPTORS</span><span class="o">*</span><span class="mf">0.8</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Max limit for file descriptors is not sufficient. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">npipes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pipe_t</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pipe_arr_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when creating pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">return</span> <span class="n">pipes</span><span class="p">;</span>   
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="open-and-close-pipes">Open and close pipes</h4>
<p>After the pipes have been created and <code>fork</code>ed, each process carries a copy of all pipes. The key to the usage of pipes is that <strong>all</strong> pipe copies need to be closed properly for the pipe to work. And for each pipe copy, each channel (the incoming and the outgoing) must be closed <strong>separately</strong>. Not closing all pipes' in- and out-channels is a frequent source of errors.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">close_pipes_in</span><span class="p">(</span><span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when closing &#39;in&#39; pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="kt">void</span> <span class="nf">close_pipes_out</span><span class="p">(</span><span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>   
</span></span><span class="line"><span class="ln">7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when closing &#39;in&#39; pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="send-a-token-into-a-pipe">Send a token into a pipe</h4>
<p>When I send tokens into the pipe, I need to use the out channel. That’s obvious. What’s less obvious though is that, and I know I’m repeating myself here, I should therefore <strong>close</strong> the <em><strong>in</strong></em>-channel right away. Below function shows how this looks like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">read_corpus_and_send_tokens_into_pipe_mp</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">close_pipes_in</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">size_t</span> <span class="n">str_pos</span> <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="n">size_t</span> <span class="n">str_end</span> <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">str_pos</span> <span class="o">&lt;</span> <span class="n">str_end</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str_pos</span><span class="p">,</span> <span class="n">str_end</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        
</span></span><span class="line"><span class="ln">12</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="c1">// find the index of the pipe/hash-segment that should be used for this token
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="c1"></span>            <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="kt">long</span> <span class="n">seg_idx</span> <span class="o">=</span> <span class="n">get_segment_index</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">MAX_HASH_LENGTH</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="c1">// send the token into the selected pipe
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error sending token into the pipe!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="read-a-token-from-a-pipe">Read a token from a pipe</h4>
<p>Reading the pipe is straight forward. I simply loop a <code>read</code> function scanning the in channel until the other end of the pipe gets closed.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">read_pipe_and_write_tokens_into_htab</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="c1">// read the pipe of this process until all sending is closed
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="c1"></span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tok</span><span class="p">)))</span> <span class="n">insert_token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="n">close_pipes_in</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>And again, I must close the unused channel, in this case, the out channel, in the beginning of the function. Similarly, at the end of the function, I need to close all in channels as well, since they are not used anymore. (Ok. I’m not mentioning closing pipes anymore.)</p>
<p>That’s it. All that’s left is to add these 2 functions into a multiprocessing loop. I call the respective function <code>process_corpus_pipes</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="n">PROCESS_COUNT_READ_CORPUS</span> <span class="o">=</span> <span class="n">PROCESS_COUNT</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">// half of the processes read the corpus
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="c1"></span><span class="n">PROCESS_COUNT_WRITE_HASH</span>  <span class="o">=</span> <span class="n">PROCESS_COUNT</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">// half of the processes write the hash table
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="kt">void</span> <span class="nf">process_corpus_pipes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">htab_segs</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">PROCESS_COUNT</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="n">process_corpus_mp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="k">return</span><span class="p">;}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span> <span class="o">=</span> <span class="n">create_pipes</span><span class="p">(</span><span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">   
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="c1">// Part 1 -- Kick-off the reading-corpus-processes
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT_READ_CORPUS</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">            <span class="n">read_corpus_and_send_tokens_into_pipe_mp</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">corp_segs</span><span class="p">,</span> <span class="n">pipes</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="c1">// Part 2 -- Kick-off the write-hash-processes
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">
</span></span><span class="line"><span class="ln">27</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">            <span class="n">read_pipe_and_write_tokens_into_htab</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">pipes</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">
</span></span><span class="line"><span class="ln">35</span><span class="cl">    <span class="c1">// close parent process pipes
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="c1"></span>    <span class="n">close_pipes_in</span> <span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">    <span class="n">wait_for_child_processes</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">    
</span></span><span class="line"><span class="ln">41</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><blockquote>
<p>Note that the <code>wait_for_child_processes()</code> occurs <em><strong>after</strong></em> closing the pipes. If the parent process does not also close all of its pipes the child processes won’t exit. (Oops. Another ‘closing pipes’. I promise this is the last one.)</p>
</blockquote>
<p>Ok. Now let me run it and see how <em><strong>multiprocessing with pipes</strong></em> compares to the previous methods.</p>
<p>Ta-dah. As expected. Sending tokens as messages back and forth between processes is slower than accessing shared memory. Nevertheless, it’s nothing to sneeze at. The pipes take ‘only’ 1,704 seconds on my computer to create the dictionary which is a little longer than the second Python script. And what I cherish about this option is its decentralized, messaging-based architecture. How about processing a text across multiple machines via a distributed system? Sounds like another enthralling project to come.</p>
<p>Here’s a summary of the pipes testing:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Multiprocessing with pipes for IPC</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number of processes</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Processing time in seconds</td>
<td style="text-align:right">2,903</td>
<td style="text-align:right">2,363</td>
<td style="text-align:right">1.704</td>
<td style="text-align:right"><strong>958</strong></td>
<td style="text-align:right">1,636</td>
<td style="text-align:right">4,500</td>
<td style="text-align:right">10,229</td>
<td style="text-align:right">13,637</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
</tr>
</tbody>
</table>
<ul>
<li>I did not test pipes with more than 64 cores on the VM128 since performance clearly deteriorated rapidly with a higher process count.</li>
</ul>
<p>Huh… almost done. I finished my testing of 4 methods of parallel processing:</p>
<ul>
<li>2 of them performed splendidly (mutexes and multiple hashes),</li>
<li>1 of them reasonably well (pipes) and</li>
<li>1 of them fell flat (semaphores).</li>
</ul>
<p>Yet, none of them scaled. I had expected that for at least one of the methods adding cores would always further increase performance. Obviously, this is not the case. The overhead of managing and coordinating multiple processes, be it memory management, locking and unlocking registers, or sending and receiving messages, eventually outweighs the benefits of parallel processing.</p>
<p>Hmmm.. wait. This leaves one question open. If it’s the overhead that’s preventing the scaling, and the overhead only exists because of our task of creating a dictionary, then how about if I simply read the corpus. No deduplication, no hash table, just read the text, word by word.</p>
<h4 id="last-but-not-least-just-read">Last but not least: just read</h4>
<p>Before I conclude my testing I’m adding another option, just for fun. And curiosity. I want to confirm whether multiprocessing or multithreading can scale at all. Is running multiple processes or threads burdened with inherent overhead? If I simply read the Wikipedia text, without deduplicating tokens and creating a dictionary, will performance consistently improve all the way to 128 cores?</p>
<p>Before I conclude my adventure, I thus create a simple function <code>process_corpus_reading_only</code> and test it on all 3 machines.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">process_corpus_reading_only</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">create_corpus_segments</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">PROCESS_COUNT</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">            <span class="n">size_t</span> <span class="n">pos</span> <span class="o">=</span><span class="n">segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">            <span class="n">size_t</span> <span class="n">end</span> <span class="o">=</span><span class="n">segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">            <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">                <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">    <span class="n">wait_for_child_processes</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="n">free</span><span class="p">(</span><span class="n">segs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Wow! Finally. 2 processes run faster than 6, which run faster than 12, which run faster than 32, etc. All the way to 128 processes which take a mere 6 seconds to read through the full 17 GB English Wikipedia corpus with approx. 2.8 billion words. That’s a whopping 460 million words per second. To put this in perspective: if an average novel nowadays comprises 90,000 words, then <code>text2dict</code> is <em>reading</em> 5,000 books ... per second.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Simply reading the corpus, without creating a dictionary</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Number of processes</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Processing time in seconds</td>
<td style="text-align:right">75</td>
<td style="text-align:right">63</td>
<td style="text-align:right">60</td>
<td style="text-align:right">31</td>
<td style="text-align:right">22</td>
<td style="text-align:right">12</td>
<td style="text-align:right">9</td>
<td style="text-align:right">8</td>
<td style="text-align:right">7</td>
<td style="text-align:right">6</td>
</tr>
</tbody>
</table>
<p>At this point, I’m wondering how long this would take on the VM416 that I didn’t get to test on. With more than 3 times the number of cores than the VM128, could the VM416 reduce the processing time further ... to 2 seconds?</p>
<p>Here is the summary of all of the above results, consolidated in one table:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Processing time in seconds</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">MacMini</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM64</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
<th style="text-align:right">VM128</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"># of processes / threads</td>
<td style="text-align:right">2</td>
<td style="text-align:right">6</td>
<td style="text-align:right">12</td>
<td style="text-align:right">12</td>
<td style="text-align:right">16</td>
<td style="text-align:right">32</td>
<td style="text-align:right">64</td>
<td style="text-align:right">64</td>
<td style="text-align:right">96</td>
<td style="text-align:right">128</td>
</tr>
<tr>
<td style="text-align:left">Semaphores</td>
<td style="text-align:right"><strong>3,762</strong></td>
<td style="text-align:right">3,866</td>
<td style="text-align:right">3,987</td>
<td style="text-align:right">3,987</td>
<td style="text-align:right">4,127</td>
<td style="text-align:right">12,833</td>
<td style="text-align:right">14,398</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
</tr>
<tr>
<td style="text-align:left">Pipes</td>
<td style="text-align:right">2,903</td>
<td style="text-align:right">2,363</td>
<td style="text-align:right">1.704</td>
<td style="text-align:right"><strong>958</strong></td>
<td style="text-align:right">1,636</td>
<td style="text-align:right">4,500</td>
<td style="text-align:right">10,229</td>
<td style="text-align:right">13,637</td>
<td style="text-align:right">n/a*</td>
<td style="text-align:right">n/a*</td>
</tr>
<tr>
<td style="text-align:left">Mutexes</td>
<td style="text-align:right">346</td>
<td style="text-align:right">145</td>
<td style="text-align:right">122</td>
<td style="text-align:right">119</td>
<td style="text-align:right"><strong>118</strong></td>
<td style="text-align:right">138</td>
<td style="text-align:right">159</td>
<td style="text-align:right">204</td>
<td style="text-align:right">227</td>
<td style="text-align:right">246</td>
</tr>
<tr>
<td style="text-align:left">Multiples hashes</td>
<td style="text-align:right">314</td>
<td style="text-align:right">126</td>
<td style="text-align:right">111</td>
<td style="text-align:right">73</td>
<td style="text-align:right">62</td>
<td style="text-align:right"><strong>50</strong></td>
<td style="text-align:right">68</td>
<td style="text-align:right">72</td>
<td style="text-align:right">97</td>
<td style="text-align:right">121</td>
</tr>
<tr>
<td style="text-align:left">Reading corpus</td>
<td style="text-align:right">175</td>
<td style="text-align:right">63</td>
<td style="text-align:right">60</td>
<td style="text-align:right">31</td>
<td style="text-align:right">22</td>
<td style="text-align:right">12</td>
<td style="text-align:right">9</td>
<td style="text-align:right">8</td>
<td style="text-align:right">7</td>
<td style="text-align:right"><strong>6</strong></td>
</tr>
</tbody>
</table>
<p>* I did not test semaphores and pipes on more than 64 cores since performance clearly deteriorated rapidly with a higher process count.|||||||||||</p>
<h2 id="summary-and-conclusion">Summary and conclusion</h2>
<p>Given the simple task of creating a dictionary from the Wikipedia corpus, I detoured into insightful analysis and comparison of 4 different methods of parallel processing large text files. On this journey, I learned about the power and potential of multiprocessing and multithreading, but also its challenges and limitations.</p>
<p>Working with large data sources has become the norm. File sizes that developers and data scientists work on grow exponentially. And large is never large enough. While the usage of GPUs has become very popular through deep learning, the effective utilization of multiple CPUs to enhance processing performance is still lingering.</p>
<p>Bigger machines with more memory will hopefully enable and motivate more developers to embrace parallel processing. As I’ve shown in this post, the challenge of handling race conditions can be addressed in different ways. And sometimes, the most effective one is simply ‘throwing memory at the problem’.</p>
<blockquote>
<h4 id="lessons-learned">Lessons learned</h4>
<p>These are some of the key technical lessons I learned from this exercise. Some of them expected, some other less so:</p>
<ul>
<li>Reading a file fully into memory is not faster than mmap. On the contrary, mmap performed consistently better, albeit only slightly.</li>
<li>Multiprocessing and multithreading have roughly the same performance. On average, running multiple processes (i.e. using fork) was somewhat faster than running the same number of threads.</li>
<li>The fastest technique for addressing race conditions is to avoid them, e.g. by throwing memory at the problem.</li>
<li>The most efficient technique, in terms of memory usage and performance, is memory synchronization using mutexes.</li>
<li>Stay away from semaphores, at least for anything that requires usage on a large scale.</li>
<li>None of the methods scales really well with multiple cores. Peak performance is reached around 32 cores and then gradually decreases.</li>
<li>What does scale is simply reading the corpus without any process coordination whatsoever. How far this can be scaled is to be explored on bigger machines.</li>
</ul>
</blockquote>
<h4 id="processing-other-wikipedia-languages">Processing other Wikipedia languages</h4>
<p>At last, I used the fastest technique to see how long the process of creating a dictionary and of simply reading the Wikipedia corpus takes for other languages than English. Here’s a summary:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Wikipedia language</th>
<th>token type</th>
<th>file size</th>
<th>tokens in corpus</th>
<th>avg. token length</th>
<th>tokens in dict</th>
<th>fastest creation of dict</th>
<th>fastest read of corpus</th>
<th>top 10 tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">English</td>
<td>word</td>
<td>17.3 GB</td>
<td>2.8 billion</td>
<td>6.2</td>
<td>9.9 million</td>
<td>50 seconds</td>
<td>6 seconds</td>
<td>the, of, and, in, to, was, is, for, on, as</td>
</tr>
<tr>
<td style="text-align:left">German</td>
<td>word</td>
<td>7.5 GB</td>
<td>1.1 billion</td>
<td>7.0</td>
<td>7.8 million</td>
<td>29 seconds</td>
<td>2 seconds</td>
<td>der, und, die, in, von, im, des, den kategorie, mit</td>
</tr>
<tr>
<td style="text-align:left">French</td>
<td>word</td>
<td>6.3 GB</td>
<td>982 million</td>
<td>6.4</td>
<td>4.9 million</td>
<td>25 seconds</td>
<td>2 seconds</td>
<td>de, la, le, et, en, du, des, les, est, un</td>
</tr>
<tr>
<td style="text-align:left">Spanish</td>
<td>word</td>
<td>4.8 GB</td>
<td>743 million</td>
<td>6.4</td>
<td>4.1 million</td>
<td>21 seconds</td>
<td>1 second</td>
<td>de, la, en, el, del, que, los, se, por, un</td>
</tr>
<tr>
<td style="text-align:left">Italian</td>
<td>word</td>
<td>3.9 GB</td>
<td>584 million</td>
<td>6.7</td>
<td>3.7 million</td>
<td>19 seconds</td>
<td>1 second</td>
<td>di, il, la, in, del, un, che, della, per, nel</td>
</tr>
<tr>
<td style="text-align:left">Portuguese</td>
<td>word</td>
<td>2.2 GB</td>
<td>324 million</td>
<td>6.7</td>
<td>2.6 million</td>
<td>15 seconds</td>
<td>1 second</td>
<td>de, em, do, da, que, no, um, com, uma, para</td>
</tr>
<tr>
<td style="text-align:left">Russian</td>
<td>word</td>
<td>7.8 GB</td>
<td>554 million</td>
<td>14.1</td>
<td>6.6 million</td>
<td>26 seconds</td>
<td>2 seconds</td>
<td>на, года, категория, по, году, из, не, был, от, за</td>
</tr>
<tr>
<td style="text-align:left">Japanese</td>
<td>character</td>
<td>3.1 GB</td>
<td>944 million</td>
<td>3.3</td>
<td>1.6 million</td>
<td>26 seconds</td>
<td>1 second</td>
<td>の, ー, ン, に, は, ス, た, ル, る, と</td>
</tr>
<tr>
<td style="text-align:left">Chinese</td>
<td>character</td>
<td>1.3 GB</td>
<td>406 million</td>
<td>3.3</td>
<td>1.4 million</td>
<td>48 seconds</td>
<td>&lt;1 second</td>
<td>的, 中, 一, 年, 大, 在, 人, 是, 有, 行</td>
</tr>
</tbody>
</table>
<p>P.S.: It’s interesting to see that the average token length in European languages is almost the same. They also share very similar words in their top 10 of the most frequently used words. One could argue that the top 10 shows how ‘inefficient’ these languages are given that most top 10 words are ‘low-value’ prepositions. In contrast, in Chinese, you can find nouns, verbs, and adjectives among the top 10 which arguably indicates a higher efficiency in the language.</p>
<h4 id="source-code">Source code</h4>
<p>I have consolidated all code from this blog post into a project called <strong>text2dict</strong>. Here is the <a href="https://github.com/mmlind/text2dict/">Github repository</a>.</p>
<blockquote>
<p><strong>text2dict</strong> supports a command-line interface for easily converting text files to a dictionary using a user-defined number of parallel processes. It supports all methods introduced in this post. Feel free to compare results for your own hardware.</p>
</blockquote>
<p>Thanks for reading. Feel free to share your comments or raise any questions below.</p>
<p>Happy coding!</p>

    </div>
<div class="post_comments">
  
  
    
 <script src="https://utteranc.es/client.js"
         repo="https://github.com/mmlind/mmlind.github.io"
         issue-term="pathname"
         theme="github-dark"
         
         label="blog comments ✨💬✨"
         
         crossorigin="anonymous"
         async>
 </script>
 
  
  
</div>




  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <br>
    
  
  <div class="search">
    <input type="search" class="search_field form_field" placeholder='Search...' id="find" autocomplete="off" data-scope='post'>
    <label for="find" class="search_label"><svg class="icon">
  <title>search</title>
  <use xlink:href="#search"></use>
</svg>

    </label>
    
    <div class="search_results results"></div>
  </div>

        <h2>Matt Lind</h2>
      <div class="author_bio">
        Tech geek, command-line aficionado, AI enthusiast, life-long learner.
      </div>
      <a href='https://mmlind.github.io/about/' class="button mt-1" role="button" title='Read More'>Read More</a>

    
    
    <h2 class="mt-4">Featured Posts</h2>
    <ul>
      <li>
        <a href="https://mmlind.github.io/post/2023-05-14-how_to_setup_your_own_chatgpt_and_connect_it_to_your_own_data/" class="nav-link" title="How to setup your own ChatGPT and connect it to your own data">How to setup your own ChatGPT and connect it to your own data</a>
      </li>
    </ul>
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      <li>
        <a href="https://mmlind.github.io/post/2020-10-16-reading_all_of_wikipedia_in_6_seconds_how_to_utilize_multiple_cores_to_process_very_large_text_files/" class="nav-link" title="Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files">Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2020-10-05-how_to_simultaneously_write_to_shared_memory_with_multiple_processes/" class="nav-link" title="How to simultaneously write to shared memory with multiple processes">How to simultaneously write to shared memory with multiple processes</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2020-09-29-migrating_my_github-pages_blog_from_jekyl_to_hugo/" class="nav-link" title="Migrating my GitHub pages blog from Jekyl to Hugo">Migrating my GitHub pages blog from Jekyl to Hugo</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2017-12-26-using_logistic_regression_to_classify_images/" class="nav-link" title="Using logistic regression to classify images">Using logistic regression to classify images</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2017-03-05-understanding_linear_regression/" class="nav-link" title="Understanding linear regression">Understanding linear regression</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2016-02-12-deep_neural_network_for_mnist_handwriting_recognition/" class="nav-link" title="Deep Neural Network for MNIST Handwriting Recognition">Deep Neural Network for MNIST Handwriting Recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/post/2015-08-09-simple_3-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link" title="Simple 3-Layer Neural Network for MNIST Handwriting Recognition">Simple 3-Layer Neural Network for MNIST Handwriting Recognition</a>
      </li>
    </ul>
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://mmlind.github.io/tags/machine-learning/' class="post_tag button button_translucent" title="machine-learning">
          MACHINE-LEARNING
          <span class="button_tally">6</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/computer-vision/' class="post_tag button button_translucent" title="computer-vision">
          COMPUTER-VISION
          <span class="button_tally">4</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/blogging/' class="post_tag button button_translucent" title="blogging">
          BLOGGING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/c/' class="post_tag button button_translucent" title="c">
          C
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/math/' class="post_tag button button_translucent" title="math">
          MATH
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/multiprocessing/' class="post_tag button button_translucent" title="multiprocessing">
          MULTIPROCESSING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/natural-language-processing/' class="post_tag button button_translucent" title="natural-language-processing">
          NATURAL-LANGUAGE-PROCESSING
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/nlp/' class="post_tag button button_translucent" title="nlp">
          NLP
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/python/' class="post_tag button button_translucent" title="python">
          PYTHON
          <span class="button_tally">2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/chat-gpt/' class="post_tag button button_translucent" title="chat-gpt">
          CHAT-GPT
          <span class="button_tally">1</span>
        </a>
        
        
      </nav>
    </div>
  </section>
</aside>

  
</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 212 212" id="gitlab">
    <path d="M12.3 74.7h54L43.3 3c-1-3.6-6.4-3.6-7.6 0L12.3 74.8z" />
    <path d="M12.3 74.7L.5 111c-1 3.2 0 6.8 3 8.8l101.6 74-92.5-119z"/>
    <path d="M105 193.7l-38.6-119h-54l92.7 119z"/>
    <path d="M105 193.7l38.7-119H66.4l38.7 119z"/>
    <path d="M105 193.7l38.7-119H198l-93 119z"/>
    <path d="M198 74.7l11.6 36.2c1 3 0 6.6-3 8.6l-101.5 74 93-119z"/>
    <path d="M198 74.7h-54.3L167 3c1.2-3.6 6.4-3.6 7.6 0L198 74.8z"/>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="to-top">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M23 2.75A2.75 2.75 0 0 0 20.25 0H8.75A2.75 2.75 0 0 0 6 2.75v13.5A2.75 2.75 0 0 0 8.75 19h11.5A2.75 2.75 0 0 0 23 16.25zM18.25 14.5h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5zm0-3h-7.5a.75.75 0 0 1 0-1.5h7.5a.75.75 0 0 1 0 1.5z"></path>
    <path d="M8.75 20.5a4.255 4.255 0 0 1-4.25-4.25V2.75c0-.086.02-.166.025-.25H3.75A2.752 2.752 0 0 0 1 5.25v16A2.752 2.752 0 0 0 3.75 24h12a2.752 2.752 0 0 0 2.75-2.75v-.75z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="stackoverflow">
    <path d="M21 27v-8h3v11H0V19h3v8h18z"></path><path d="M17.1.2L15 1.8l7.9 10.6 2.1-1.6L17.1.2zm3.7 14.7L10.6 6.4l1.7-2 10.2 8.5-1.7 2zM7.2 12.3l12 5.6 1.1-2.4-12-5.6-1.1 2.4zm-1.8 6.8l13.56 1.96.17-2.38-13.26-2.55-.47 2.97zM19 25H5v-3h14v3z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="xing">
    <path d="M18.188 0c-.517 0-.741.325-.927.66 0 0-7.455 13.224-7.702 13.657.015.024 4.919 9.023 4.919 9.023.17.308.436.66.967.66h3.454c.211 0 .375-.078.463-.22.089-.151.089-.346-.009-.536l-4.879-8.916c-.004-.006-.004-.016 0-.022L22.139.756c.095-.191.097-.387.006-.535C22.056.078 21.894 0 21.686 0h-3.498zM3.648 4.74c-.211 0-.385.074-.473.216-.09.149-.078.339.02.531l2.34 4.05c.004.01.004.016 0 .021L1.86 16.051c-.099.188-.093.381 0 .529.085.142.239.234.45.234h3.461c.518 0 .766-.348.945-.667l3.734-6.609-2.378-4.155c-.172-.315-.434-.659-.962-.659H3.648v.016z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 71 55" id="discord">
    <path d="M60.1045 4.8978C55.5792 2.8214 50.7265 1.2916 45.6527 0.41542C45.5603 0.39851 45.468 0.440769 45.4204 0.525289C44.7963 1.6353 44.105 3.0834 43.6209 4.2216C38.1637 3.4046 32.7345 3.4046 27.3892 4.2216C26.905 3.0581 26.1886 1.6353 25.5617 0.525289C25.5141 0.443589 25.4218 0.40133 25.3294 0.41542C20.2584 1.2888 15.4057 2.8186 10.8776 4.8978C10.8384 4.9147 10.8048 4.9429 10.7825 4.9795C1.57795 18.7309 -0.943561 32.1443 0.293408 45.3914C0.299005 45.4562 0.335386 45.5182 0.385761 45.5576C6.45866 50.0174 12.3413 52.7249 18.1147 54.5195C18.2071 54.5477 18.305 54.5139 18.3638 54.4378C19.7295 52.5728 20.9469 50.6063 21.9907 48.5383C22.0523 48.4172 21.9935 48.2735 21.8676 48.2256C19.9366 47.4931 18.0979 46.6 16.3292 45.5858C16.1893 45.5041 16.1781 45.304 16.3068 45.2082C16.679 44.9293 17.0513 44.6391 17.4067 44.3461C17.471 44.2926 17.5606 44.2813 17.6362 44.3151C29.2558 49.6202 41.8354 49.6202 53.3179 44.3151C53.3935 44.2785 53.4831 44.2898 53.5502 44.3433C53.9057 44.6363 54.2779 44.9293 54.6529 45.2082C54.7816 45.304 54.7732 45.5041 54.6333 45.5858C52.8646 46.6197 51.0259 47.4931 49.0921 48.2228C48.9662 48.2707 48.9102 48.4172 48.9718 48.5383C50.038 50.6034 51.2554 52.5699 52.5959 54.435C52.6519 54.5139 52.7526 54.5477 52.845 54.5195C58.6464 52.7249 64.529 50.0174 70.6019 45.5576C70.6551 45.5182 70.6887 45.459 70.6943 45.3942C72.1747 30.0791 68.2147 16.7757 60.1968 4.9823C60.1772 4.9429 60.1437 4.9147 60.1045 4.8978ZM23.7259 37.3253C20.2276 37.3253 17.3451 34.1136 17.3451 30.1693C17.3451 26.225 20.1717 23.0133 23.7259 23.0133C27.308 23.0133 30.1626 26.2532 30.1066 30.1693C30.1066 34.1136 27.28 37.3253 23.7259 37.3253ZM47.3178 37.3253C43.8196 37.3253 40.9371 34.1136 40.9371 30.1693C40.9371 26.225 43.7636 23.0133 47.3178 23.0133C50.9 23.0133 53.7545 26.2532 53.6986 30.1693C53.6986 34.1136 50.9 37.3253 47.3178 37.3253Z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 18" id="mastodon">
    <path
    fill="#ffffff"
    d="m 15.054695,9.8859583 c -0.22611,1.1632697 -2.02517,2.4363497 -4.09138,2.6830797 -1.0774504,0.12856 -2.1382704,0.24673 -3.2694704,0.19484 -1.84996,-0.0848 -3.30971,-0.44157 -3.30971,-0.44157 0,0.1801 0.0111,0.35157 0.0333,0.51194 0.24051,1.82571 1.81034,1.93508 3.29737,1.98607 1.50088,0.0514 2.8373104,-0.37004 2.8373104,-0.37004 l 0.0617,1.35686 c 0,0 -1.0498104,0.56374 -2.9199404,0.66742 -1.03124,0.0567 -2.3117,-0.0259 -3.80308,-0.42069 -3.23454998,-0.85613 -3.79081998,-4.304 -3.87592998,-7.8024197 -0.026,-1.03871 -0.01,-2.01815 -0.01,-2.83732 0,-3.57732 2.34385998,-4.62587996 2.34385998,-4.62587996 1.18184,-0.54277 3.20976,-0.77101 5.318,-0.7882499985409 h 0.0518 C 9.8267646,0.01719834 11.856025,0.24547834 13.037775,0.78824834 c 0,0 2.34377,1.04855996 2.34377,4.62587996 0,0 0.0294,2.63937 -0.32687,4.47183"/>
 <path
    fill="#000000"
    d="m 12.616925,5.6916583 v 4.3315297 h -1.71607 V 5.8189683 c 0,-0.88624 -0.37289,-1.33607 -1.1187604,-1.33607 -0.82467,0 -1.23799,0.53361 -1.23799,1.58875 v 2.30122 h -1.70594 v -2.30122 c 0,-1.05514 -0.4134,-1.58875 -1.23808,-1.58875 -0.74587,0 -1.11876,0.44983 -1.11876,1.33607 v 4.2042197 h -1.71607 V 5.6916583 c 0,-0.88527 0.22541,-1.58876 0.67817,-2.10922 0.46689,-0.52047 1.07833,-0.78727 1.83735,-0.78727 0.87816,0 1.54317,0.33752 1.98288,1.01267 l 0.42744,0.71655 0.42753,-0.71655 c 0.43961,-0.67515 1.10463,-1.01267 1.9828704,-1.01267 0.75893,0 1.37037,0.2668 1.83735,0.78727 0.45268,0.52046 0.67808,1.22395 0.67808,2.10922"/>
  </symbol>
</svg>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<footer class="footer">
  <div class="footer_inner wrap pale">
    <img src='https://mmlind.github.io/icons/cli.png' class="icon icon_2 transparent" alt="Matt&#39;s Tech Blog">
    <p>Copyright&nbsp;2015-&nbsp;<span class="year"></span>&nbsp;MATT&#39;S TECH BLOG. All Rights Reserved</p><a class="to_top" href="#documentTop">
  <svg class="icon">
  <title>to-top</title>
  <use xlink:href="#to-top"></use>
</svg>

</a>

  </div>
</footer>

<script type="text/javascript" src="https://mmlind.github.io/en/js/bundle.f4da32c64ece1e7d5a836039ceed09b7e4f3592da2a593a2c0e74dd8b24aef5d873eea6fcf180b171a60c193c271d3f845628a40d93531f8e49a553ed23162cd.js" integrity="sha512-9Noyxk7OHn1ag2A5zu0Jt&#43;TzWS2ipZOiwOdN2LJK712HPupvzxgLFxpgwZPCcdP4RWKKQNk1MfjkmlU&#43;0jFizQ==" crossorigin="anonymous"></script>

  <script src="https://mmlind.github.io/js/search.min.441534ebca8f29b72ee98c817c1d9c475fc24ae0a88f1c2eb4deacb203fccebce3c0eee3c758545c399671772a0bc025c7e45b2b1396a19a6dff7ead9c73f066.js"></script>

  </body>
</html>
