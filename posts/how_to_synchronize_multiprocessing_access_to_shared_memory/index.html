
<!DOCTYPE html>
<html lang="en" data-figures="" class="page">
  <head>  <title>How to simultaneously write to shared memory with multiple processes | Matt&#39;s Tech Blog</title>
  <meta charset='utf-8'>
  <meta name="generator" content="Hugo 0.75.1" />
  <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
  <meta http-equiv = 'X-UA-Compatible' content = 'IE=edge'>
<meta property = "og:locale" content = "en_US" />
<meta property="og:type" content="article">
<meta name="description" content="How to synchronize multiprocessing access to shared memory using semaphores">
<meta name = "twitter:card" content = "summary" />
<meta name = "twitter:creator" content = "@">
<meta name = "twitter:title" content = "How to simultaneously write to shared memory with multiple processes" />
<meta property = "og:url" content = "https://mmlind.github.io/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/" />
<meta property = "og:title" content = "How to simultaneously write to shared memory with multiple processes" />
<meta property = "og:description" content = "How to synchronize multiprocessing access to shared memory using semaphores" />
<meta property = "og:image" content = "https://mmlind.github.io/images/multiprocess_memory.png" />
<link rel='apple-touch-icon' sizes='180x180' href='https://mmlind.github.io/icons/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='https://mmlind.github.io/icons/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='https://mmlind.github.io/icons/favicon-16x16.png'>
<link rel='manifest' href='https://mmlind.github.io/icons/site.webmanifest'>
<link rel="mask-icon" href= 'https://mmlind.github.io/safari-pinned-tab.svg' color="#002538">
<meta name="msapplication-TileColor" content="#002538">
<meta name="theme-color" content="#002538">

  
  <link rel='canonical' href='https://mmlind.github.io/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/'>

    

    
    
    <link rel="preload" href="https://mmlind.github.io/css/styles.a5262c7798fc304069e7ad8c0884d94b91fa5f203c3219735fe37309b7080d17f29fc1a7be9842862d1a86cf9bca26cdf5eb570f6ad2d44bf92219908c2c44b4.css" integrity = "sha512-pSYsd5j8MEBp562MCITZS5H6XyA8MhlzX&#43;NzCbcIDRfyn8GnvphChi0ahs&#43;byibN9etXD2rS1Ev5IhmQjCxEtA==" as="style" crossorigin="anonymous">
    <link rel="preload" href="https://mmlind.github.io/js/bundle.min.7333d63e045f01aaa61cad70ba4e3060064949b5a64c00b840c4e0c664bcdb02869222e7bde3800fe4911ccad719c06a19cb5f48c60048c0e382631fbd17cece.js" as="script" integrity=
    "sha512-czPWPgRfAaqmHK1wuk4wYAZJSbWmTAC4QMTgxmS82wKGkiLnveOAD&#43;SRHMrXGcBqGctfSMYASMDjgmMfvRfOzg==" crossorigin="anonymous">

    
    <link rel="stylesheet" type="text/css" href="https://mmlind.github.io/css/styles.a5262c7798fc304069e7ad8c0884d94b91fa5f203c3219735fe37309b7080d17f29fc1a7be9842862d1a86cf9bca26cdf5eb570f6ad2d44bf92219908c2c44b4.css" integrity="sha512-pSYsd5j8MEBp562MCITZS5H6XyA8MhlzX&#43;NzCbcIDRfyn8GnvphChi0ahs&#43;byibN9etXD2rS1Ev5IhmQjCxEtA==" crossorigin="anonymous">
	  
  </head>
  
  
    
  
  <body data-code="7" data-lines="false" id="documentTop">

<header class = 'nav_header' >
  <nav class = 'nav'>
    <a href='https://mmlind.github.io/' class = 'nav_brand nav_item'>
      <img src="https://mmlind.github.io/logos/matt_blog_logo2020.png" class="logo">
      <div class = 'nav_close'>
        <div>
          <svg class="icon">
            <use xlink:href="#open-menu"></use>
          </svg>
          <svg class="icon">
            <use xlink:href="#closeme"></use>
          </svg>
        </div>
      </div>
    </a>
    <div class = 'nav_body nav_body_left'>
      
      
      <div class = 'nav_parent'>
        <a href = 'https://mmlind.github.io/' class = 'nav_item'>Blog </a>
      </div>
      <div class = 'nav_parent'>
        <a href = 'https://mmlind.github.io/about/' class = 'nav_item'>About </a>
      </div>
      
<div class='follow'>
  <a href='https://github.com/mmlind'>
    <svg class="icon">
      <use xlink:href="#github"></use>
    </svg>
  </a>
  
  <a href='https://www.linkedin.com/in/mmlind'>
    <svg class="icon">
      <use xlink:href="#linkedin"></use>
    </svg>
  </a>
<div class = 'color_mode'>
  <input type = 'checkbox' class = 'color_choice' id = 'mode'>
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class = 'grid-inverse wrap content'>
  <article class='post_content'>
    <h1 class='post_title'>How to simultaneously write to shared memory with multiple processes</h1><div class = 'post_meta'>
  <svg class="icon">
    <use xlink:href="#calendar"></use>
  </svg>
  <span class="post_date">
    Oct 5, 2020</span>
  <a href = 'https://mmlind.github.io/tags/multiprocessing' class = 'post_tag button button_translucent'>Multiprocessing
  </a>
  <a href = 'https://mmlind.github.io/tags/c' class = 'post_tag button button_translucent'>C
  </a>
</div>

    <div class='post_share'>
  Share on:
  <a href="https://twitter.com/intent/tweet?text=How%20to%20simultaneously%20write%20to%20shared%20memory%20with%20multiple%20processes&url=https%3a%2f%2fmmlind.github.io%2fposts%2fhow_to_synchronize_multiprocessing_access_to_shared_memory%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
    <svg class="icon">
      <use xlink:href="#twitter"></use>
    </svg>
  </a>
  
  <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fmmlind.github.io%2fposts%2fhow_to_synchronize_multiprocessing_access_to_shared_memory%2f&t=How%20to%20simultaneously%20write%20to%20shared%20memory%20with%20multiple%20processes" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
    <svg class="icon">
      <use xlink:href="#facebook"></use>
    </svg>
  </a>
  <script>
    function shareViaLinkedin() {
      window.open('http://www.linkedin.com/shareArticle?mini=true&url='+encodeURIComponent("https://mmlind.github.io/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/"), '', 'left=0,top=0,width=650,height=420,personalbar=0,toolbar=0,scrollbars=0,resizable=0');
    }
  </script>
  <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow" onclick="shareViaLinkedin()">
    <svg class="icon">
      <use xlink:href="#linkedin"></use>
    </svg>
  </a>
  <a href="https://mmlind.github.io/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/" title="Copy Link" class="link link_yank">
    <svg class="icon">
      <use xlink:href="#yank"></use>
    </svg>
  </a>
</div>

    
    <h1 id="heading"></h1>
<p>Most of our modern day computers have more than one processing unit. They are often referred to as <em>cores</em>. For a developer, effectively using multiple cores simultaneously to speed up program execution by parallel processing comes with challenges. One of them is changing the value of a variable in shared memory.</p>
<p>In this blog post I introduce one of the two most common methods to overcome this problem by <em>synchronizing</em>  access to shared memory: <code>fork</code> and <code>semaphores</code>. (The other option would be <code>pthreads</code> and <code>mutexes</code> .)</p>
<p><img src="/images/multiprocess_memory.png" alt=""></p>
<h3 id="parallel-processing">Parallel processing</h3>
<p>Most computers nowadays come with a multi-core processor. In fact, the Mac that I&rsquo;m using to write this blog on comes with 6 cores. At least that&rsquo;s what the system configuration menu tells me:</p>
<p><img src="/images/mac_sysinfo.png" alt=""></p>
<p>Does this mean that all software runs 6 times as fast? Unfortunately not.
Only a small subset of all software effectively leverages the enourmous computing power that modern laptops and desktops possess. Why? Writing software that executes multiple tasks in parallel is significantly more complex than solving the same problem sequentially.</p>
<h3 id="how-many-cores-does-my-computer-have">How many cores does my computer have?</h3>
<p>At this point, you may want to know how many cores or processing units your computer is equipped with. To retrieve the number of processing units you can use the following &lsquo;C&rsquo; code</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">long</span> <span class="n">nproc</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_NPROCESSORS_ONLN</span><span class="p">);</span>
</code></pre></div><p>which, in my case, returns &hellip;. <em><strong>12</strong></em>. Why the difference to the <em><strong>6</strong></em> cores that were reported by the system configuration above? <a href="https://de.wikipedia.org/wiki/Hyper-Threading">Hyperthreading</a>. 6 <em>physical</em> cores inside the computer are presented as 12 <em>virtual</em> cores to the operating system.</p>
<h3 id="multiprocessing-and-multithreading">Multiprocessing and multithreading</h3>
<p>The 2 main technical options for a developer to implement parallel processing are <code>multiprocessing</code> and <code>multithreading</code>. Both allow to execute multiple tasks simultaneously by spinning-off separate <code>processes</code> or <code>threads</code> that run independently of the main process.</p>
<p>Beware that in both methods tasks really run &ldquo;simultaneously&rdquo;, or in parallel, only if there is more than 1 processing unit. If you run multiple processes or threads on a single core computer, all tasks are in the end still executed <em><strong>sequentially</strong></em>, one after the other, by the same (aka. only) processor without any gain in performance.</p>
<p>Also, be aware that task scheduling is done by the operating system, not by the application. Thus, as a developer you cannot decide what task, no matter whether it&rsquo;s a <code>process</code> or a <code>thread</code>, is run by what core. In fact, if you run multiple tasks there is no guarantee at all that each of these tasks will actually run on a different processing unit. Fortunately, modern operating systems allocate the workload evenly, hence <em>in practice</em> your processes are typically allocated to <em>different</em> processing units.</p>
<h3 id="challenges-of-parallel-processing">Challenges of parallel processing</h3>
<p>To effectively use multiple cores in an application, the first thing a developer needs to do is to adapt the application logic or flow. Simply running the same algorithm on a multiple cores machine will <em><strong>not</strong></em> result in any performance improvement. Further down below I will provide an example for such a change in application logic.</p>
<p>Second, you will need your multiple <code>processes</code> or <code>threads</code> to exchange information or to communicate with each other. This is called IPC or <em><strong>inter process communication</strong></em>. The most common techniques to support IPC are typically either based on <em>messaging</em> or on <em>memory</em>. <em>Messaging</em> based techniques include <code>SIGNAL</code>s and <code>PIPE</code>s. Information is sent as messages from one task to another.</p>
<p>In this post I want to explore the <em>memory</em> based approach. Instead of multiple tasks exchanging messages they communicate by writing information to memory that can be read by other tasks. In most cases this method is faster than <em>messaging</em> via <code>PIPE</code>s or <code>SIGNAL</code>s.</p>
<p>Yet, this method comes with one big caveat. If multiple tasks write to the same shared memory at the same time they may conflict with each other. This is called a <em>race condition</em> because the tasks run in parallel, like multiple runners in a race, and you cannot predict which runner wins, i.e. you don&rsquo;t know the order in which these tasks are executed.</p>
<p>To overcome this problem of <em>race conditions</em> we therefore need to <em>synchronize</em> any write access to shared memory. Let&rsquo;s look at a simple example to demonstrate this:</p>
<h3 id="a-simple-problem----solved-with-a-single-process">A simple problem &ndash; solved with a single process</h3>
<p>Let&rsquo;s say we have a large <code>array</code> of random integers between 0-9 and we want to calculate the frequency of each digit. How many 1s, 2s, 3s&hellip;. etc are there in the array. It&rsquo;s a very simple problem that is solved in 2 steps.</p>
<p>First, create the array with the random numbers:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="c1">// create a large array of random numbers between 0-9
</span><span class="ln">2</span><span class="c1"></span>    
<span class="ln">3</span>    <span class="kt">long</span> <span class="n">arrlen</span>  <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>        <span class="c1">// arbitrary length of the array
</span><span class="ln">4</span><span class="c1"></span>    <span class="kt">int</span>  <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">// there are 10 digits [0-9]
</span><span class="ln">5</span><span class="c1"></span>
<span class="ln">6</span>    <span class="kt">long</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arrlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="ln">7</span>
<span class="ln">8</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">ndigits</span><span class="p">;</span>
</code></pre></div><p>Second, count the frequencies per digit:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="c1">// count the frequency of each digit in the array
</span><span class="ln">2</span><span class="c1"></span>
<span class="ln">3</span>    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_sp</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ndigits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span> <span class="c1">// frequency counter per digit [single process]
</span><span class="ln">4</span><span class="c1"></span>
<span class="ln">5</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">6</span>        <span class="n">freq_sp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
<span class="ln">7</span>        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln">8</span>    <span class="p">}</span>
</code></pre></div><p>Since this is a very simple calculation, it would take less than 1 second to complete. For the purpose of this demo, I simulate a more complex algorithm that takes longer to complete by simply adding a <code>usleep</code> pause of 0.1 milliseconds into the loop.</p>
<p>At the end, we want to confirm the calculation. The <code>sum</code> of all frequencies should match <code>arrlen</code>. Consider this a <em>checksum</em> that we want to refer to further later. Let&rsquo;s also time the calculation and output the number of seconds the whole algorithm took to complete:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="kt">long</span> <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">2</span>
<span class="ln">3</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln">4</span>
<span class="ln">5</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies: %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
<span class="ln">6</span>
</code></pre></div><p>If you put the pieces of code above together and run it your output should look similar to this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>
<span class="ln">2</span>Sum of all frequencies:        100,000 (13 sec)
<span class="ln">3</span>
</code></pre></div><p>A single process took about 13 seconds to complete this calculation. (The time on your computer may vary. But the time obviously will always be 10+ seconds since we added 100,000 times a pause of 0.1 milliseconds which translates into 10 seconds.)</p>
<h3 id="solving-the-problem-with-multiple-processes">Solving the problem with multiple processes</h3>
<p>Now, let&rsquo;s see whether we can speed-up this calculation if we use <em>multiprocessing</em>.</p>
<p>As I mentioned above, the first thing to do for <em>multiprocessing</em> is to adapt the logic or flow of the application. We need to find instructions that can be effectively run in parallel without affecting the result.</p>
<p>In our simple example we run a <code>for</code> loop from <code>1</code> to <code>ndigits</code>. If multiple processes all were to run this same loop we would not only get a different result but we would also likely end up with an even slower algorithm.</p>
<p>Instead, we split the array into segments and let each process calculate the digit frequencies of the numbers in that particular segment. So, if we assume we want to run 2 processes in parallel, then process #1 would work on segment [0..49,000] and process #2 would work on segment [50,000..99,999]. The same logic applies to any other number of processes that you may want to run in parallel.</p>
<p>The resulting code for this new logic should look something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>
<span class="ln"> 2</span>    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of processes to run simultaneously
</span><span class="ln"> 3</span><span class="c1"></span>
<span class="ln"> 4</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>        <span class="c1">// define a segment that each process works on independently
</span><span class="ln"> 7</span><span class="c1"></span>        <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln"> 8</span>        <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln"> 9</span>
<span class="ln">10</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">11</span>             <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span><span class="ln">12</span><span class="c1"></span>             <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln">13</span>         <span class="p">}</span>
<span class="ln">14</span>    <span class="p">}</span>
<span class="ln">15</span>
</code></pre></div><p>So, almost there. But something is still missing. Above code is still executed by a single process. How to create 2 or more processes that run in parallel, and then make each process work on a different segment of the array?</p>
<p>The 2 most common techniques to run multiple tasks in parallel are <code>fork</code> and <code>pthread</code>. While the former basically clones your whole program (aka. <em>process</em>), the latter spins off a new <code>thread</code> <em>within</em> the current process. Therefore, when we&rsquo;re using <code>fork</code> we&rsquo;re talking about <code>multiprocessing</code>, and when we&rsquo;re using <code>pthread</code> we&rsquo;re talking about <code>multithreading</code>.</p>
<p>I won&rsquo;t go into much detail about the difference between the two. There are abundant online resources on this topic. Put simply, you can think of the following analogy: Think of your program as a worker. <code>fork</code> clones this worker and gives you 2 independent workers that both handle the workload in parallel. <code>pthread</code> on the other side grows your worker a new pair of arms, each pair works independently but is still part of the same body and controlled by the same brain.</p>
<h3 id="multiprocessing-using-fork">Multiprocessing using <em>fork()</em></h3>
<p>Citing from its <a href="https://www.man7.org/linux/man-pages/man2/fork.2.html">man page</a> <code>fork()</code> &ldquo;<em>creates a new process by duplicating the calling process. The new process is referred to as the child process.  The calling process is referred to as the parent process.</em>&rdquo;</p>
<p>I recommend reading the man page and doing some of the many online tutorials on <code>fork</code> before you continue. The usage of <code>fork</code> and understanding the resulting program logic can be a bit tricky in the beginning, especially if you <code>fork</code> multiple times.</p>
<p>Below code shows a useful generic structure that can be widely applied whenever you want to do <em>multiprocessing</em>. It runs any task <code>nproc</code> times in parallel by creating <code>nproc</code> child processes:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 4</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 5</span>         
<span class="ln"> 6</span>         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 7</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8</span>             
<span class="ln"> 9</span>             <span class="c1">// code that shall be executed by each child process
</span><span class="ln">10</span><span class="c1"></span>             
<span class="ln">11</span>             <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello! I am process [%d].</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
<span class="ln">12</span>
<span class="ln">13</span>             <span class="c1">/// ...
</span><span class="ln">14</span><span class="c1"></span>             
<span class="ln">15</span>             
<span class="ln">16</span>             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">17</span>         <span class="p">}</span>
<span class="ln">18</span>         
<span class="ln">19</span>     <span class="p">}</span>
<span class="ln">20</span>
<span class="ln">21</span>    <span class="c1">// wait for all child processes to finish
</span><span class="ln">22</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">23</span>    
<span class="ln">24</span>    <span class="c1">// parent process proceeds....
</span></code></pre></div><p>Please note that at the end the <code>parent</code> process <code>waits</code> until all child processes have <code>exit</code>ed and only then resumes the program flow. Not waiting for child processes to finish is often a source of errors.</p>
<p>The <code>wait</code> command also gives you the opportunity to bring the application logic back into a single process. Often this is needed, for example when only a certain part of your application logic can be parallelized. When this part is completed, you want to proceed sequentially. Using <code>while(wait(NULL) != -1);</code> allows you to do so.</p>
<p>Also, beware that in above generic code structure <code>nproc</code> represents the number of <em>processes</em>, not the number of <em>processors</em>. You could run more processes than there are actual processing units.</p>
<h3 id="simple-problem-using-multiprocessing">Simple problem using multiprocessing</h3>
<p>Now, let&rsquo;s put it all together. Let&rsquo;s apply the above multiprocessing code structure to our problem of calculating the frequencies of random digits:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of child processes to run simultaneously
</span><span class="ln"> 2</span><span class="c1"></span>
<span class="ln"> 3</span>    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 6</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 7</span>         
<span class="ln"> 8</span>         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>  <span class="c1">// exit if fork was not successful
</span><span class="ln"> 9</span><span class="c1"></span>
<span class="ln">10</span>        <span class="c1">// define what each child process will do
</span><span class="ln">11</span><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">12</span>             
<span class="ln">13</span>             <span class="c1">// define a segment that each child process works on independently
</span><span class="ln">14</span><span class="c1"></span>             <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln">15</span>             <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln">16</span>             
<span class="ln">17</span>             <span class="c1">// sum up the frequencies in this segment of the array
</span><span class="ln">18</span><span class="c1"></span>             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">19</span>                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span><span class="ln">20</span><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln">21</span>             <span class="p">}</span>
<span class="ln">22</span>              
<span class="ln">23</span>             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">24</span>         <span class="p">}</span>
<span class="ln">25</span>         
<span class="ln">26</span>     <span class="p">}</span>
<span class="ln">27</span>
<span class="ln">28</span>    <span class="c1">// wait for all child processes to finish
</span><span class="ln">29</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">30</span>
<span class="ln">31</span>    <span class="c1">// calculating the sum of all frequencies to check     
</span><span class="ln">32</span><span class="c1"></span>    <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">33</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_mp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln">34</span>    
<span class="ln">35</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies: %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
</code></pre></div><p>If you add this code to your previous code and run it alltogether you should see something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>Sum of all frequencies (single process) :        100,000 (13 sec)
<span class="ln">2</span>Sum of all frequencies (multiprocessing):              0 (6 sec)
</code></pre></div><p>The second calculation, using multiprocessing, required only 6 seconds versus 13 seconds for the single process calculation. However, the sum of the frequencies, which serves as our checksum to verify that our calculation worked correctly, now returns a 0 instead of the expected 100,000. Why?</p>
<h3 id="shared-memory-for-ipc">Shared memory for IPC</h3>
<p>In the above code I purposely didn&rsquo;t include the definition of the <code>freq_mp</code> variable. If you defined it using <code>malloc</code>, same as we did previously for a single process, you will end up with this wrong result. The problem is that once you <code>fork</code>ed the current process, each resulting child process will have a separate copy of all variables of the parent process. If the child process changes any of those variables, those changes have no impact on the original variable in the parent process. So when the child processes were incrementing <code>freq_mp</code> those changes did not affect the copy of <code>freq_mp</code> in the parent process which however is the one that we sum up at the end.</p>
<p>To solve this problem, we need to define <code>freq_mp</code> as <em>shared memory</em> that can be accessed, and in particular written to, by <em><strong>both</strong></em> parent <em><strong>and</strong></em> child process. I do this with <code>mmap</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="c1">// define a shared memory to store the frequency counters
</span><span class="ln">2</span><span class="c1"></span>
<span class="ln">3</span>    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_mp</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">4</span>    <span class="k">if</span> <span class="p">(</span><span class="n">freq_mp</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;mmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
</code></pre></div><p>Now, all child processes can write to <code>freq_mp</code> and their changes can be read by the parent process. Actually, not only by the parent process but also by all other child processes.</p>
<p>When the shared memory is not used anymore you don&rsquo;t <code>free</code> it as you would for <code>malloc</code> allocated variables. Instead, the corresponding method for shared memory created with <code>mmap</code> is <code>munmap</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">freq_mp</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;munmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>   
</code></pre></div><p>Therefore, make sure you add the above at the end of your code.</p>
<p>Great. So let&rsquo;s see what happens. Let&rsquo;s run the code again, using <em>multiprocessing</em> and this time using <em>shared memory</em>. If you do so, you will see an output that looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>Sum of all frequencies (single process) :        100,000 (13 sec)
<span class="ln">2</span>Sum of all frequencies (multiprocessing):         99,988 (6 sec)
</code></pre></div><p>Wow! What is this?! Now, our multiprocessing <em>did</em> calculate the frequencies, however the sum of those frequencies mystically is <em>not</em> correct. The sum that was calculated by multiple processes in parallel is <em><strong>not</strong></em> equal to the sum that a single process calculated. (In your own testing you may see a smaller or larger difference, or in fact, you may see no difference at all. But, in general, very likely you will see a difference, and the larger the array the larger the difference.)</p>
<p>What happened?</p>
<h3 id="remember-race-conditions">Remember <em><strong>race conditions</strong></em>?</h3>
<p>The problem with the above code is that multiple processes try to write to the same shared memory at the same time. This causes some of the <code>writes</code> getting <em>lost</em> or <em>cancelled out</em>.</p>
<p>To avoid this problem we need to <em>synchronize</em> the <em>writes</em>. Without synchronization there is no guarantee that all <em>writes</em> are successfully completed.</p>
<h2 id="synchronizing-memory-writes-for-multiprocessing">Synchronizing memory writes for multiprocessing</h2>
<p>Synchronizing writes means that if one process writes to a variable in shared memory, this process <em>locks</em> the variable first so that no other process can write to it. After the writing is complete, the process <em>unlocks</em> or <em>releases</em> the shared memory and only then another process will be able to write to it. In short, what we need is a <em><strong>mut</strong></em>ually <em><strong>ex</strong></em>clusive write.</p>
<p>The 2 most common techniques to synchronize memory access are <code>semaphores</code> and <code>mutexes</code>. You can think of both as some low-level registers that can be set to a certain value, and then depending on that value either allow or block access to a resource. While <code>semaphores</code> are more powerful, can be used <em>across</em> processes, and support incrementing values instead of a simple binary 0 or 1, in our example here I only use them as simple on/off switches, similar to <code>mutexes</code>.</p>
<p>You can think of <code>semaphores</code> as counting locks that only open if their value is 1. They are defined in sets of arbitrary length. Each set is identified by its unique ID. Altogether, we need the following 5 steps to use <code>semaphores</code> effectively:</p>
<h5 id="step-1-define">Step 1: Define</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span><span class="ln">2</span><span class="c1"></span><span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</code></pre></div><p>This will create a new semaphore set with 1 semaphore.</p>
<h5 id="step-2-initialize">Step 2: Initialize</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released/unlocked
</span><span class="ln">2</span><span class="c1"></span><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
</code></pre></div><p>This will set the initial value of the semaphore to 1, which means it&rsquo;s unlocked.</p>
<h5 id="step-3-lock">Step 3: Lock</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">2</span>
<span class="ln">3</span><span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// lock the semaphore
</span><span class="ln">4</span><span class="c1"></span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div><p>Before any process writes to the shared variable, use <code>semop</code> to lock the semaphore. This will automatically block other processes that attempt to write to this variable. Those processes are made wait until the semaphore is unlocked.</p>
<h5 id="step-4-releaseunlock">Step 4: Release/Unlock</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span>
<span class="ln">2</span>
<span class="ln">3</span><span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// release/unlock the semaphore
</span><span class="ln">4</span><span class="c1"></span><span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div><p>After a process has completed writing to the shared variable, use <code>semop</code> to unlock the semaphore.</p>
<h5 id="step-5-remove">Step 5: Remove</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">);</span>
</code></pre></div><p>Whenever a semaphore set is not needed anymore it should be properly removed. This cleanup process is important because semaphores continue to exist even when the calling program is completed.</p>
<p>There is also a limit to the amount of semaphores that can be created and that can exist at any given time. Hence, if you don&rsquo;t remove garbage you may at some point reach the given limit of your computer which makes any subsequent call to <code>semget</code> fail.</p>
<p>You can see a list of open semaphores via the console using:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>$ ipcs -s
</code></pre></div><p>The limit of the maximum number of semaphores that can exist at any given time can be checked via</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">long</span> <span class="n">max_nsem</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_SEM_NSEMS_MAX</span><span class="p">);</span>
</code></pre></div><p>or in the console via</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln"> 1</span>$ ipcs -S
<span class="ln"> 2</span>
<span class="ln"> 3</span>	semmap:     30	(# of entries in semaphore map)
<span class="ln"> 4</span>	semmni:      0	(# of semaphore identifiers)
<span class="ln"> 5</span>	semmns:      0	(# of semaphores in system)
<span class="ln"> 6</span>	semmnu:      0	(# of undo structures in system)
<span class="ln"> 7</span>	semmsl:  87381	(max # of semaphores per id)
<span class="ln"> 8</span>	semopm:      5	(max # of operations per semop call)
<span class="ln"> 9</span>	semume:     10	(max # of undo entries per process)
<span class="ln">10</span>	semusz:     32	(size in bytes of undo structure)
<span class="ln">11</span>	semvmx:  32767	(semaphore maximum value)
<span class="ln">12</span>	semaem:  16384	(adjust on exit max value)
</code></pre></div><p>on Mac OS or via</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>$ cat /proc/sys/kernel/sem
</code></pre></div><p>on Linux.</p>
<h2 id="synchronizing-memory-writes-with-semaphores">Synchronizing memory writes with semaphores</h2>
<p>Now, let&rsquo;s put all of the above together and use semaphores to ensure that our multiprocessing calculation ends up with the correct frequency counts.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">  1</span>    <span class="c1">// create a very large array of random numbers between 0-9
</span><span class="ln">  2</span><span class="c1"></span>    
<span class="ln">  3</span>    <span class="kt">long</span> <span class="n">arrlen</span>  <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>        <span class="c1">// arbitrary length of the array
</span><span class="ln">  4</span><span class="c1"></span>    <span class="kt">int</span>  <span class="n">ndigits</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>            <span class="c1">// there are 10 digits [0-9]
</span><span class="ln">  5</span><span class="c1"></span>    <span class="kt">long</span> <span class="o">*</span><span class="n">arr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">arrlen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span>
<span class="ln">  6</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="n">ndigits</span><span class="p">;</span>
<span class="ln">  7</span>
<span class="ln">  8</span>    
<span class="ln">  9</span>    <span class="c1">// PART I -- counting frequencies with a single processes
</span><span class="ln"> 10</span><span class="c1"></span>
<span class="ln"> 11</span>    <span class="n">time_t</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 12</span>    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_sp</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">ndigits</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">));</span> <span class="c1">// frequency counter per digit (single process)
</span><span class="ln"> 13</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arrlen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 14</span>        <span class="n">freq_sp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 15</span>        <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln"> 16</span>    <span class="p">}</span>
<span class="ln"> 17</span>
<span class="ln"> 18</span>    
<span class="ln"> 19</span>    <span class="c1">// calculate the sum of all frequencies to check that the calculation is correct
</span><span class="ln"> 20</span><span class="c1"></span>
<span class="ln"> 21</span>    <span class="kt">long</span> <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 22</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_sp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 23</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies (single process) : %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
<span class="ln"> 24</span>
<span class="ln"> 25</span>    <span class="n">free</span><span class="p">(</span><span class="n">freq_sp</span><span class="p">);</span>
<span class="ln"> 26</span>
<span class="ln"> 27</span>    
<span class="ln"> 28</span>    <span class="c1">// PART II -- counting frequencies with multiple processes
</span><span class="ln"> 29</span><span class="c1"></span>
<span class="ln"> 30</span>    
<span class="ln"> 31</span>    <span class="c1">// define a shared memory to store the frequency counters
</span><span class="ln"> 32</span><span class="c1"></span>    <span class="kt">long</span> <span class="o">*</span><span class="n">freq_mp</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">),</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span><span class="p">,</span> <span class="n">MAP_ANONYMOUS</span> <span class="o">|</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln"> 33</span>    <span class="k">if</span> <span class="p">(</span><span class="n">freq_mp</span> <span class="o">==</span> <span class="n">MAP_FAILED</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;mmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 34</span>
<span class="ln"> 35</span>    <span class="c1">// define a semaphore set for synchronizing write access to shared memory
</span><span class="ln"> 36</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span><span class="ln"> 37</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
<span class="ln"> 38</span>    
<span class="ln"> 39</span>    
<span class="ln"> 40</span>    <span class="c1">// initialize the semaphore
</span><span class="ln"> 41</span><span class="c1"></span>    <span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released/unlocked
</span><span class="ln"> 42</span><span class="c1"></span>    <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
<span class="ln"> 43</span>    
<span class="ln"> 44</span>    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span> <span class="o">=</span> <span class="p">{.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">sem_flg</span><span class="o">=</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// struct to feed into semaphore functions
</span><span class="ln"> 45</span><span class="c1"></span>    
<span class="ln"> 46</span>    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// the number of child processes to run simultaneously
</span><span class="ln"> 47</span><span class="c1"></span>
<span class="ln"> 48</span>    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>    <span class="c1">// reset the time counter
</span><span class="ln"> 49</span><span class="c1"></span>
<span class="ln"> 50</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 51</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 52</span>         
<span class="ln"> 53</span>         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>  <span class="c1">// exit if fork was not successful
</span><span class="ln"> 54</span><span class="c1"></span>
<span class="ln"> 55</span>        <span class="c1">// define what each child process will do
</span><span class="ln"> 56</span><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 57</span>             
<span class="ln"> 58</span>             <span class="c1">// define a segment that each child process works on independently
</span><span class="ln"> 59</span><span class="c1"></span>             <span class="kt">long</span> <span class="n">from_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>       <span class="o">?</span> <span class="mi">0</span>      <span class="o">:</span>  <span class="n">p</span>    <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln"> 60</span>             <span class="kt">long</span> <span class="n">to_idx</span>   <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">nproc</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="nl">arrlen</span> <span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arrlen</span><span class="o">/</span><span class="n">nproc</span><span class="p">);</span>
<span class="ln"> 61</span>             
<span class="ln"> 62</span>             <span class="c1">// sum up the numbers in this segment of the array
</span><span class="ln"> 63</span><span class="c1"></span>             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 64</span>
<span class="ln"> 65</span>                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// lock the semaphore
</span><span class="ln"> 66</span><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 67</span>                 
<span class="ln"> 68</span>                 
<span class="ln"> 69</span>                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span><span class="ln"> 70</span><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln"> 71</span>
<span class="ln"> 72</span>                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// release/unlock the semaphore
</span><span class="ln"> 73</span><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 74</span>
<span class="ln"> 75</span>                 
<span class="ln"> 76</span>             <span class="p">}</span>
<span class="ln"> 77</span>              
<span class="ln"> 78</span>             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln"> 79</span>         <span class="p">}</span>
<span class="ln"> 80</span>         
<span class="ln"> 81</span>     <span class="p">}</span>
<span class="ln"> 82</span>
<span class="ln"> 83</span>    <span class="c1">// wait for all child processes to finish
</span><span class="ln"> 84</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln"> 85</span>
<span class="ln"> 86</span>    
<span class="ln"> 87</span>    <span class="c1">// calculate the sum of all frequencies to check that the calculation is correct
</span><span class="ln"> 88</span><span class="c1"></span>
<span class="ln"> 89</span>    <span class="n">arrsum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 90</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">arrsum</span> <span class="o">+=</span> <span class="n">freq_mp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="ln"> 91</span>        
<span class="ln"> 92</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Sum of all frequencies (multiprocessing): %&#39;14ld (%.0f sec)</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">arrsum</span><span class="p">,</span><span class="n">difftime</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span> <span class="n">start_time</span><span class="p">));</span>
<span class="ln"> 93</span>
<span class="ln"> 94</span>
<span class="ln"> 95</span>    <span class="c1">// cleanup
</span><span class="ln"> 96</span><span class="c1"></span>
<span class="ln"> 97</span>    <span class="k">if</span> <span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semctl remove&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>        <span class="c1">// remove semaphore
</span><span class="ln"> 98</span><span class="c1"></span>    
<span class="ln"> 99</span>    <span class="k">if</span> <span class="p">(</span><span class="n">munmap</span><span class="p">(</span><span class="n">freq_mp</span><span class="p">,</span> <span class="n">ndigits</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;munmap&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>   <span class="c1">// unmap shared memory
</span><span class="ln">100</span><span class="c1"></span>
<span class="ln">101</span>    <span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span>
<span class="ln">102</span>
</code></pre></div><p>Running above code will output something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>Sum of all frequencies (single process) :        100,000 (13 sec)
<span class="ln">2</span>Sum of all frequencies (multiprocessing):        100,000 (13 sec)
</code></pre></div><p>Great. The <code>semaphores</code> work. Write access to shared memory is now synchronized and all processes' writes are successfully completed. However, please note that this synchronization came at a cost. All of the performance gain achieved via multiprocessing seems to be lost. Now, multiprocessing takes the same 13 seconds as did a single process.</p>
<h3 id="memory-synchronization-comes-at-a-cost">Memory synchronization comes at a cost</h3>
<p>That&rsquo;s disappointing, isn&rsquo;t it? It was for me when I first noticed the enormous negative performance impact <code>semaphores</code> can have. Every time a lock is set or unset, a low-level call to the OS is made which is slow. Let&rsquo;s understand in more detail what&rsquo;s happening and whether there is any option to improve performance.</p>
<p>Based on our current logic, both/all processes lock the same semaphore every time they need to write. This means that the probability that a process that wants to write to the shared variable needs to wait until the semaphore is unlocked is very high. Basically the probability is 100% because all processes use the same lock.</p>
<p>Therefore, if we were to use <em>multiple</em> locks, for example a <em>different</em> lock for each digit (remember, we want to count the frequencies per digit 0-9) then the probability of encountering locked memory would decrease to only 10% since we have 10 different locks.</p>
<p>As <code>semaphores</code> are defined in <em>sets</em> this can be implemented very easily. We need to make 3 changes:</p>
<p>First, when we <em>define</em> the <code>semaphore</code> we make the size of the set equal to the number of digits, i.e. 10.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="kt">int</span> <span class="n">nsems</span> <span class="o">=</span> <span class="n">ndigits</span><span class="p">;</span> <span class="c1">// number of semaphores in this set
</span><span class="ln">2</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">nsems</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">);</span>
</code></pre></div><p>With this change, the same <code>semid</code> now refers to a <em>set</em> of 10 <code>semaphores</code> instead of a single <code>semaphore</code>.</p>
<p>Second, we need to initialize <em>all</em> of the <code>semaphores</code> in the set. Therefore, we put the <code>semctl</code> initialization into a loop. (Alternatively, you could also use the <code>SETALL</code> option instead of a loop. Please refer to the <code>semctl</code> man page.)</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span>    <span class="c1">//    semctl(semid, 0, SETVAL, semun);
</span><span class="ln">2</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">ndigits</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">semctl</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">);</span>
</code></pre></div><p>Third, when we lock or release the <code>semaphore</code> we need to define which <code>semaphore</code> in the set we refer to. This is done by adding</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> 
</code></pre></div><p>as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>             <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="n">from_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">to_idx</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span>                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>   <span class="c1">// pick the semaphore in the set
</span><span class="ln"> 4</span><span class="c1"></span>
<span class="ln"> 5</span>                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>       <span class="c1">// lock the semaphore
</span><span class="ln"> 6</span><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 7</span>                 
<span class="ln"> 8</span>                 <span class="n">freq_mp</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>     <span class="c1">// increment frequency counter per digit [multi process]
</span><span class="ln"> 9</span><span class="c1"></span>                 <span class="n">usleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="ln">10</span>
<span class="ln">11</span>                 <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// release/unlock the semaphore
</span><span class="ln">12</span><span class="c1"></span>                 <span class="n">semop</span><span class="p">(</span><span class="n">semid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln">13</span>                 
<span class="ln">14</span>             <span class="p">}</span>
</code></pre></div><p>If you apply all of these changes, i.e. you now use 10 semaphores instead of 1, and run above code again you should see something like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>Sum of all frequencies (single process) :        100,000 (13 sec)
<span class="ln">2</span>Sum of all frequencies (multiprocessing):        100,000 (7 sec)
</code></pre></div><p>Voila! The multiprocessing result is still correct (i.e. memory synchronization via <code>semaphores</code> works) <em>and</em> we see some performance improvement from <em>multiprocessing</em> compared to a single process.</p>
<h3 id="conclusion">Conclusion</h3>
<p><em>Multiprocessing</em> requires a completely new consideration, or redesign, of the application logic. Processes need to communicate with each other (IPC) to share the result of their work. When <em>shared memory</em> is used for IPC, memory access needs to be <em>synchronized</em> to avoid unpredictable outcomes caused by <em>race conditions</em>. Synchronization, no matter whether via <code>semaphores</code> or <code>mutexes</code>, comes at a cost that often negatively compensates any performance gain from <em>multiprocessing</em>. To reduce the cost a developer has to carefully weigh different options for the <em>design</em> of <code>semaphores</code> (or <code>mutexes</code>).</p>
<p>&ndash;</p>

    <script src="https://utteranc.es/client.js"
        repo="mmlind/mmlind.github.io"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <h2>Matt Lind</h2>
    <div>
      CTO, freelancer, and passionate software engineer. Azure cloud and M365 global admin. Excited about parellel processing and distributed systems. AI enthusiast with special interest in natural language processing (NLP)...
    </div>
    <a href = 'https://mmlind.github.io/about/' class="button mt-1" role="button">Read More</a>
    <h2 class="mt-4">Featured Posts</h2>
    <ul>
    
    
    </ul>
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      
      <li>
        <a href="https://mmlind.github.io/posts/migrating_blog_from_jekyl_hugo/" class="nav-link">Migrating my GitHub pages blog from Jekyl to Hugo</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/using_logistic_regression_to_solve_mnist/" class="nav-link">Using logistic regression to classify images</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/linear_regression/" class="nav-link">Understanding linear regression</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/deep_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Deep neural network for MNIST handwriting recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/simple_3-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Simple 3-layer neural network for MNIST handwriting recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/simple_1-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Simple 1-layer neural network for MNIST handwriting recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/what_is_a_neural_network/" class="nav-link">What is a neural network?</a>
      </li>
    </ul> 
    
    
    
    
    
    
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://mmlind.github.io/tags/machine-learning/' class=" post_tag button button_translucent">
          MACHINE-LEARNING
          <span class='button_tally'>6</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/computer-vision/' class=" post_tag button button_translucent">
          COMPUTER-VISION
          <span class='button_tally'>4</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/blogging/' class=" post_tag button button_translucent">
          BLOGGING
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/math/' class=" post_tag button button_translucent">
          MATH
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/c/' class=" post_tag button button_translucent">
          C
          <span class='button_tally'>1</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/multiprocessing/' class=" post_tag button button_translucent">
          MULTIPROCESSING
          <span class='button_tally'>1</span>
        </a>
        
        
      </nav>
    </div>
    
    
  </section>
</aside>

</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol viewBox="-21 0 512 512" xmlns="http://www.w3.org/2000/svg" id="yank">
    <path d="M410.668 405.332H165.332c-32.363 0-58.664-26.3-58.664-58.664v-288c0-32.363 26.3-58.668 58.664-58.668h181.504c21.059 0 41.687 8.535 56.555 23.445l42.496 42.496c15.125 15.125 23.445 35.223 23.445 56.575v224.152c0 32.363-26.3 58.664-58.664 58.664zM165.332 32c-14.7 0-26.664 11.969-26.664 26.668v288c0 14.7 11.965 26.664 26.664 26.664h245.336c14.7 0 26.664-11.965 26.664-26.664V122.516c0-12.82-4.992-24.871-14.059-33.942l-42.496-42.496C371.84 37.121 359.488 32 346.836 32zm0 0"></path>
    <path d="M314.668 512h-256C26.305 512 0 485.695 0 453.332V112c0-32.363 26.305-58.668 58.668-58.668h10.664c8.832 0 16 7.168 16 16s-7.168 16-16 16H58.668C43.968 85.332 32 97.301 32 112v341.332C32 468.032 43.969 480 58.668 480h256c14.7 0 26.664-11.969 26.664-26.668v-10.664c0-8.832 7.168-16 16-16s16 7.168 16 16v10.664c0 32.363-26.3 58.668-58.664 58.668zM368 181.332H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0"></path>
    <path d="M368 245.332H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 64H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="arrow">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="copy">
    <path d="M366.345 406.069H66.207c-9.751 0-17.655-7.904-17.655-17.655V17.655C48.552 7.904 56.456 0 66.207 0h300.138C376.096 0 384 7.904 384 17.655v370.759c0 9.751-7.904 17.655-17.655 17.655z" fill="#f1f4fb"></path>
    <path d="M384 388.414v-76.992c-.907.322-1.869.494-2.751.882-6.307-6.593-14.733-11.025-24.111-11.964a40.49 40.49 0 0 0-8.448.039v-92.93c0-21.903-17.82-39.723-39.723-39.724a40.5 40.5 0 0 0-4.036.202c-20.012 2.004-35.689 19.916-35.689 40.781v101.773l-21.581 21.581c-15.241 15.241-21.393 36.866-16.456 57.847l3.802 16.16h131.338c9.75 0 17.655-7.905 17.655-17.655z"
      fill="#d5dced"></path>
    <circle cx="128" cy="105.931" r="26.483" fill="#b4e66e"></circle>
    <circle cx="128" cy="203.034" r="26.483" fill="#dae169"></circle>
    <circle cx="128" cy="300.138" r="26.483" fill="#ffdc64"></circle>
    <path d="M331.034 229.517H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h141.241c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 194.207H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h105.931a8.826 8.826 0 0 1 8.828 8.828 8.826 8.826 0 0 1-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M331.034 326.621H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h141.241c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 291.31H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h105.931c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M331.034 132.414H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h141.241a8.826 8.826 0 0 1 8.828 8.828 8.826 8.826 0 0 1-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 97.103H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h105.931a8.826 8.826 0 0 1 8.828 8.828 8.825 8.825 0 0 1-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M443.656 335.563c-13.21-1.323-24.345 9.015-24.345 21.954v-7.569c0-11.544-8.306-22.063-19.794-23.213-13.209-1.323-24.344 9.015-24.344 21.954v-7.569c0-11.544-8.306-22.063-19.794-23.213-13.209-1.323-24.344 9.015-24.344 21.954V207.448c0-12.939-11.135-23.277-24.345-21.954-11.486 1.15-19.793 11.669-19.793 23.213v109.086l-26.752 26.752a44.14 44.14 0 0 0-11.754 41.32l18.47 78.495c6.567 27.913 31.475 47.64 60.15 47.64h74.645c34.127 0 61.793-27.666 61.793-61.793v-91.431c-.001-11.544-8.306-22.063-19.793-23.213z"
      fill="#f0c087"></path>
    <path d="M339.862 361.377a8.829 8.829 0 0 0 8.828-8.828v-34.194c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zM384 370.205a8.829 8.829 0 0 0 8.828-8.828v-34.194c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zm44.138 8.827a8.829 8.829 0 0 0 8.828-8.828V336.01c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zM288.885 464.36l-20.467-86.985a28.482 28.482 0 0 1 7.585-26.663l10.893-10.894v22.113a8.829 8.829 0 0 0 17.656 0V185.933c-10.344 2.173-17.655 11.972-17.655 22.773v109.087l-26.752 26.752a44.14 44.14 0 0 0-11.754 41.32l18.47 78.495c6.567 27.913 31.475 47.64 60.15 47.64h22.026c-28.677 0-53.584-19.727-60.152-47.64z"
      fill="#e6af78"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
</svg>
<footer class = 'footer'>
  <div class = 'footer_inner wrap pale'>
    <img src = 'https://mmlind.github.io/icons/apple-touch-icon.png' class = 'icon icon_2 transparent'>
    <p>&lt;/&gt; &copy;&nbsp;<span class = 'year'>2020</span>&nbsp;MATT&#39;S TECH BLOG. &lt;/&gt;</p>
<a class='to_top' href="#documentTop">
  <svg class="icon">
    <use xlink:href="#arrow"></use>
  </svg>
</a>

  </div>
</footer>
    <script type="text/javascript" src = "https://mmlind.github.io/js/bundle.min.7333d63e045f01aaa61cad70ba4e3060064949b5a64c00b840c4e0c664bcdb02869222e7bde3800fe4911ccad719c06a19cb5f48c60048c0e382631fbd17cece.js" integrity=
    "sha512-czPWPgRfAaqmHK1wuk4wYAZJSbWmTAC4QMTgxmS82wKGkiLnveOAD&#43;SRHMrXGcBqGctfSMYASMDjgmMfvRfOzg==" crossorigin="anonymous"></script>
  </body>
</html>
