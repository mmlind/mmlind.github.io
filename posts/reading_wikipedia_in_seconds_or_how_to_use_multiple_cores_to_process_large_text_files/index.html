
<!DOCTYPE html>
<html lang="en" data-figures="" class="page">
  <head>  <title>Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files | Matt&#39;s Tech Blog</title>
  <meta charset='utf-8'>
  <meta name="generator" content="Hugo 0.75.1" />
  <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
  <meta http-equiv = 'X-UA-Compatible' content = 'IE=edge'>
<meta property = "og:locale" content = "en_US" />
<meta property="og:type" content="article">
<meta name="description" content="Reading all of Wikipedia in 6 seconds or how to utilize multiple cores to process very large text files">
<meta name = "twitter:card" content = "summary" />
<meta name = "twitter:creator" content = "@">
<meta name = "twitter:title" content = "Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files" />
<meta property = "og:url" content = "https://mmlind.github.io/posts/reading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files/" />
<meta property = "og:title" content = "Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files" />
<meta property = "og:description" content = "Reading all of Wikipedia in 6 seconds or how to utilize multiple cores to process very large text files" />
<meta property = "og:image" content = "https://mmlind.github.io/images/nlp.png" />
<link rel='apple-touch-icon' sizes='180x180' href='https://mmlind.github.io/icons/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='https://mmlind.github.io/icons/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='https://mmlind.github.io/icons/favicon-16x16.png'>
<link rel='manifest' href='https://mmlind.github.io/icons/site.webmanifest'>
<link rel="mask-icon" href= 'https://mmlind.github.io/safari-pinned-tab.svg' color="#002538">
<meta name="msapplication-TileColor" content="#002538">
<meta name="theme-color" content="#002538">

  
  <link rel='canonical' href='https://mmlind.github.io/posts/reading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files/'>

    

    
    
    <link rel="preload" href="https://mmlind.github.io/css/styles.a5262c7798fc304069e7ad8c0884d94b91fa5f203c3219735fe37309b7080d17f29fc1a7be9842862d1a86cf9bca26cdf5eb570f6ad2d44bf92219908c2c44b4.css" integrity = "sha512-pSYsd5j8MEBp562MCITZS5H6XyA8MhlzX&#43;NzCbcIDRfyn8GnvphChi0ahs&#43;byibN9etXD2rS1Ev5IhmQjCxEtA==" as="style" crossorigin="anonymous">
    <link rel="preload" href="https://mmlind.github.io/js/bundle.min.7333d63e045f01aaa61cad70ba4e3060064949b5a64c00b840c4e0c664bcdb02869222e7bde3800fe4911ccad719c06a19cb5f48c60048c0e382631fbd17cece.js" as="script" integrity=
    "sha512-czPWPgRfAaqmHK1wuk4wYAZJSbWmTAC4QMTgxmS82wKGkiLnveOAD&#43;SRHMrXGcBqGctfSMYASMDjgmMfvRfOzg==" crossorigin="anonymous">

    
    <link rel="stylesheet" type="text/css" href="https://mmlind.github.io/css/styles.a5262c7798fc304069e7ad8c0884d94b91fa5f203c3219735fe37309b7080d17f29fc1a7be9842862d1a86cf9bca26cdf5eb570f6ad2d44bf92219908c2c44b4.css" integrity="sha512-pSYsd5j8MEBp562MCITZS5H6XyA8MhlzX&#43;NzCbcIDRfyn8GnvphChi0ahs&#43;byibN9etXD2rS1Ev5IhmQjCxEtA==" crossorigin="anonymous">
	  
  </head>
  
  
    
  
  <body data-code="7" data-lines="false" id="documentTop">

<header class = 'nav_header' >
  <nav class = 'nav'>
    <a href='https://mmlind.github.io/' class = 'nav_brand nav_item'>
      <img src="https://mmlind.github.io/logos/matt_blog_logo2020.png" class="logo">
      <div class = 'nav_close'>
        <div>
          <svg class="icon">
            <use xlink:href="#open-menu"></use>
          </svg>
          <svg class="icon">
            <use xlink:href="#closeme"></use>
          </svg>
        </div>
      </div>
    </a>
    <div class = 'nav_body nav_body_left'>
      
      
      <div class = 'nav_parent'>
        <a href = 'https://mmlind.github.io/' class = 'nav_item'>Blog </a>
      </div>
      <div class = 'nav_parent'>
        <a href = 'https://mmlind.github.io/about/' class = 'nav_item'>About </a>
      </div>
      
<div class='follow'>
  <a href='https://github.com/mmlind'>
    <svg class="icon">
      <use xlink:href="#github"></use>
    </svg>
  </a>
  
  <a href='https://www.linkedin.com/in/mmlind'>
    <svg class="icon">
      <use xlink:href="#linkedin"></use>
    </svg>
  </a>
<div class = 'color_mode'>
  <input type = 'checkbox' class = 'color_choice' id = 'mode'>
</div>

</div>

    </div>
  </nav>
</header>

    <main>
  
<div class = 'grid-inverse wrap content'>
  <article class='post_content'>
    <h1 class='post_title'>Reading all of Wikipedia in 6 seconds: how to utilize multiple cores to process very large text files</h1><div class = 'post_meta'>
  <svg class="icon">
    <use xlink:href="#calendar"></use>
  </svg>
  <span class="post_date">
    Oct 16, 2020</span>
  <a href = 'https://mmlind.github.io/tags/natural-language-processing-nlp' class = 'post_tag button button_translucent'>Natural Language Processing (NLP)
  </a>
  <a href = 'https://mmlind.github.io/tags/multiprocessing' class = 'post_tag button button_translucent'>Multiprocessing
  </a>
  <a href = 'https://mmlind.github.io/tags/c' class = 'post_tag button button_translucent'>C
  </a>
  <a href = 'https://mmlind.github.io/tags/python' class = 'post_tag button button_translucent'>Python
  </a>
</div>

    <div class='post_share'>
  Share on:
  <a href="https://twitter.com/intent/tweet?text=Reading%20all%20of%20Wikipedia%20in%206%20seconds%3a%20how%20to%20utilize%20multiple%20cores%20to%20process%20very%20large%20text%20files&url=https%3a%2f%2fmmlind.github.io%2fposts%2freading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files%2f&tw_p=tweetbutton" class="twitter" title="Share on Twitter" target="_blank" rel="nofollow">
    <svg class="icon">
      <use xlink:href="#twitter"></use>
    </svg>
  </a>
  
  <a href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fmmlind.github.io%2fposts%2freading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files%2f&t=Reading%20all%20of%20Wikipedia%20in%206%20seconds%3a%20how%20to%20utilize%20multiple%20cores%20to%20process%20very%20large%20text%20files" class="facebook" title="Share on Facebook" target="_blank" rel="nofollow">
    <svg class="icon">
      <use xlink:href="#facebook"></use>
    </svg>
  </a>
  <script>
    function shareViaLinkedin() {
      window.open('http://www.linkedin.com/shareArticle?mini=true&url='+encodeURIComponent("https://mmlind.github.io/posts/reading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files/"), '', 'left=0,top=0,width=650,height=420,personalbar=0,toolbar=0,scrollbars=0,resizable=0');
    }
  </script>
  <a href="#linkedinshare" id = "linkedinshare" class="linkedin" title="Share on LinkedIn" rel="nofollow" onclick="shareViaLinkedin()">
    <svg class="icon">
      <use xlink:href="#linkedin"></use>
    </svg>
  </a>
  <a href="https://mmlind.github.io/posts/reading_wikipedia_in_seconds_or_how_to_use_multiple_cores_to_process_large_text_files/" title="Copy Link" class="link link_yank">
    <svg class="icon">
      <use xlink:href="#yank"></use>
    </svg>
  </a>
</div>

    
    <h1 id="heading"></h1>
<p>I was about to do some basic natural language processing (NLP) task on a large text file: create a dictionary of unique words and count how many times each word occurs. Easy peasy. This should only take me a minute. So I thought. While coding <em>did</em> not take more than 2 zips of coffee, I needed to wait almost an hour for the task to complete. That was unacceptable. There must be a way to accelerate this process. So I detoured, digging into parallel processing with multi-core computers. Along the way, I learned about semaphores, mutexes, pipes, and parallel hash tables. I knew I was cracking the nut with a sledgehammer. But hey, data files are only getting bigger. Remember anyone complaining &ldquo;the data source is <em>too big</em> for our model!&rdquo;? Me neither.</p>
<p><img src="/images/nlp.png" alt=""></p>
<p>A friend asked me for help to assess a new algorithm for building word embeddings. Remember those numerical representations of words that allow you to do arithmetic calculations such as the (in)famous</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>King - Man + Woman = Queen
</code></pre></div><p>equation? In a typical machine learning manner, he emphasized that we would need a <em><strong>very</strong></em> large text corpus for building and training the model. Otherwise, the algorithm wouldn&rsquo;t work.</p>
<p>So, off I go to look for freely available large text corpora. One of the first potential sources that come to my mind is &hellip; Wikipedia. As of October 2020, the English Wikipedia text spans <a href="http://wikicount.net">more than 6 million articles</a>. With an average of 1,324 words per article the whole corpus should provide us with 8 billion words. That seemed like a good start.</p>
<p><a href="http://wikicount.net"><img src="/images/wikicount_202010.png" alt=""></a></p>
<h2 id="reading-large-wikipedia-files">Reading large Wikipedia files</h2>
<p>Regular backups are available at <a href="https://dumps.wikimedia.org/">dumps.wikimedia.org</a>, and the latest dumps of the <em>English</em> site can be downloaded <a href="https://dumps.wikimedia.org/enwiki/latest/">here</a>. Simply look for a file <em>enwiki-latest-pages-articles.xml.bz2</em> which includes all current articles.</p>
<p>Naturally, these files are not small. The current version of the English Wikipedia dump file is a whopping 17.7 GB, <em><strong>compressed</strong></em>. One of the reasons for the enormous file size is that all dump files come in a clumsy XML format which carries a lot of extra baggage.</p>
<p>I download the version dated October 2, 2020. Since I&rsquo;m interested in a plain text corpus, I need to strip off the XML markup and all the metadata that is included. Fortunately, there are tools that convert the files in a breeze, such as <a href="https://www.kdnuggets.com/2017/11/building-wikipedia-text-corpus-nlp.html">Building a Wikipedia Text Corpus for Natural Language Processing</a> or <a href="https://github.com/yohasebe/wp2txt">WP2TXT</a>.</p>
<h2 id="creating-a-dictionary-from-a-text-corpus">Creating a dictionary from a text corpus</h2>
<p>After conversion to plain text, the dump file of the English Wikipedia still weighs a staggering 17.3 GB. (After decompression, the original dump file exploded to 78 GB of XML which then get stripped down to 17 GB.) I call it <code>enwiki.txt</code>. This is the file that I am going to work on.</p>
<p>My first task is to build a dictionary of its unique words and count their respective occurrences. The tool I&rsquo;m using to create the dictionary is <em>Python</em>, the de facto weapon of choice nowadays for many machine learning practitioners, data scientists, and anyone else who wants to get stuff done quickly.</p>
<h3 id="processing-with-python">Processing with Python</h3>
<p>Python is amazing. The language empowers a developer to achieve complex tasks with little code. Creating a dictionary from a text corpus requires only a few lines:</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="ln"> 1</span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span><span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
<span class="ln"> 6</span><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;corpus/corpus.txt&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
<span class="ln"> 7</span>    <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
<span class="ln"> 8</span>        <span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="ln"> 9</span>    <span class="k">else</span><span class="p">:</span>
<span class="ln">10</span>        <span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="ln">11</span>
<span class="ln">12</span><span class="n">top</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
<span class="ln">13</span>
<span class="ln">14</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Execution time: </span><span class="si">%.0f</span><span class="s2"> seconds&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
<span class="ln">15</span>
<span class="ln">16</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Number of words in the dictionary: </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">))</span>
<span class="ln">17</span>
<span class="ln">18</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Top 10 words:&#34;</span><span class="p">)</span>
<span class="ln">19</span>
<span class="ln">20</span><span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
<span class="ln">21</span>    <span class="k">print</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">dic</span><span class="p">[</span><span class="n">word</span><span class="p">])</span>
</code></pre></div><p>Yes, this is elementary school syntax. Hold on. We&rsquo;re just getting started. If you&rsquo;re a devoted Pythonista you must know at least 27.5 other ways to do this. If you want to highlight any method in particular, please leave a comment below.</p>
<p>Running this script on my computer takes 3,430 seconds to complete. That&rsquo;s me waiting for more than 53 mins. Or almost one hour. Just to tell me the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln"> 1</span>Execution time: 3,430 seconds
<span class="ln"> 2</span>
<span class="ln"> 3</span>Number of words in the dictionary: 9,969,783
<span class="ln"> 4</span>
<span class="ln"> 5</span>Top 10 words:
<span class="ln"> 6</span>the  187,815,597
<span class="ln"> 7</span>of    94,989,314
<span class="ln"> 8</span>and   79,019,333
<span class="ln"> 9</span>in    76,509,632
<span class="ln">10</span>to    52,986,068
<span class="ln">11</span>was   30,276,734
<span class="ln">12</span>is    23,444,605
<span class="ln">13</span>for   23,133,442
<span class="ln">14</span>on    22,621,322
<span class="ln">15</span>as    22,363,717
</code></pre></div><p>Huh. I&rsquo;m going to end up with a caffeine addiction if I don&rsquo;t speed this up. Come on, Python. You can do better than that.</p>
<p>The simple <code>split()</code> method doesn&rsquo;t cut it. And, I want to include some pre-processing such as converting all words to lower case. So I plugin the <a href="https://stackoverflow.com/questions/35857519/efficiently-count-word-frequencies-in-python">following method</a> next, using Python&rsquo;s <code>counter</code> function.</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="ln"> 1</span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="ln"> 2</span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="ln"> 3</span><span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">punctuation</span>
<span class="ln"> 4</span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span><span class="k">def</span> <span class="nf">count_words_in_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="ln"> 7</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="ln"> 8</span>        <span class="n">linewords</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">punctuation</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
<span class="ln"> 9</span>        <span class="k">return</span> <span class="n">Counter</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">linewords</span><span class="p">))</span>
<span class="ln">10</span>
<span class="ln">11</span>
<span class="ln">12</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
<span class="ln">13</span>
<span class="ln">14</span><span class="n">dic</span> <span class="o">=</span> <span class="n">count_words_in_file</span><span class="p">(</span><span class="s1">&#39;corpus/enwiki_short.txt&#39;</span><span class="p">)</span>
<span class="ln">15</span><span class="n">top</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="ln">16</span>
<span class="ln">17</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Execution time: </span><span class="si">%.0f</span><span class="s2"> seconds&#34;</span> <span class="o">%</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">())</span>
<span class="ln">18</span>
<span class="ln">19</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Number of words in the dictionary: </span><span class="si">%d</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">dic</span><span class="p">))</span>
<span class="ln">20</span>
<span class="ln">21</span><span class="k">print</span><span class="p">(</span><span class="s2">&#34;Top 10 words:&#34;</span><span class="p">)</span>
<span class="ln">22</span>
<span class="ln">23</span><span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">top</span><span class="p">:</span>
<span class="ln">24</span>    <span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div><p>That&rsquo;s a few libraries to import, but it&rsquo;s concise, elegant, and even covers the pre-processing. Nice. And more importantly, this method performs better, taking <em>only</em> 1,402 seconds or about 23+ minutes on my computer to complete. Yeah. This saves me half an hour.</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln"> 1</span>Execution time: 1,402 seconds
<span class="ln"> 2</span>
<span class="ln"> 3</span>Number of words in the dictionary: 10,148,725
<span class="ln"> 4</span>
<span class="ln"> 5</span>Top 10 words:
<span class="ln"> 6</span>(&#39;the&#39;, 187,814,291)
<span class="ln"> 7</span>(&#39;of&#39;,   94,986,720)
<span class="ln"> 8</span>(&#39;and&#39;,  79,017,578)
<span class="ln"> 9</span>(&#39;in&#39;,   76,500,162)
<span class="ln">10</span>(&#39;to&#39;,   52,983,623)
<span class="ln">11</span>(&#39;was&#39;,  30,276,660)
<span class="ln">12</span>(&#39;is&#39;,   23,444,109)
<span class="ln">13</span>(&#39;for&#39;,  23,132,718)
<span class="ln">14</span>(&#39;on&#39;,   22,619,230)
<span class="ln">15</span>(&#39;as&#39;,   22,363,452)
</code></pre></div><blockquote>
<p>Both methods return the same top 10 words. The exact token counts yet differ because they use different word boundaries.</p>
</blockquote>
<p>I&rsquo;m grateful for the additional half an hour that my life just gained. I&rsquo;m celebrating for a few seconds, then my mind wanders off. Come on. It&rsquo;s 2020. Almost every home computer comes with multiple cores, running at &gt;3 Ghz. The Mac Mini I&rsquo;m using to write this blog on boasts 6 cores. With that much computing power is it not possible to speed up the processing of large text files? And how can I effectively use <em><strong>all</strong></em> cores and process the file <em>in parallel</em>?</p>
<p>Questions demand answers. I decide to do some investigation into multiprocessing and multithreading. I want to assess how any such techniques could help me to process the Wikipedia file faster.</p>
<h3 id="sequential-processing-with-c">Sequential processing with C</h3>
<p>I start my investigation by developing a simple C program that processes the text corpus on a single core, sequentially.</p>
<p>Writing C code is clearly not as efficient and elegant as coding in Python. The idea of the sledgehammer begins to form. But hey, for this kind of operation I need a scalpel, not a kitchen knife. And I just love the power and precision of the C language.</p>
<p>I break down the algorithm for creating the dictionary into 4 main steps:</p>
<ol>
<li>Map the corpus file to memory</li>
<li>Read the corpus word by word</li>
<li>Deduplicate all words</li>
<li>Sort the words by count in descending order</li>
</ol>
<p>Wow. Just mapping out my to-do list already takes more lines of writing than coding the whole piece in Python. This better works.</p>
<h4 id="1-map-the-corpus-file-to-memory">1. Map the corpus file to memory</h4>
<p>Given the monstrous size of Wikipedia dump files, I want to ensure they can be read on computers that do not have sufficient memory to load the complete file at once. Therefore, I use <code>mmap</code> to map the physical file into memory. The loading into memory happens dynamically and the operating system helps to cache pages which further improves performance.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="o">*</span><span class="nf">map_shared_file</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fname</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">fsize</span><span class="p">){</span>
<span class="ln"> 2</span>        
<span class="ln"> 3</span>    <span class="k">struct</span> <span class="n">stat</span> <span class="n">fstat</span><span class="p">;</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fstat</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[STAT] Error getting file stats! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="o">*</span><span class="n">fsize</span> <span class="o">=</span> <span class="n">fstat</span><span class="p">.</span><span class="n">st_size</span><span class="p">;</span>
<span class="ln"> 8</span>    
<span class="ln"> 9</span>    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
<span class="ln">10</span>    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[OPEN] Error opening file for shared use! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">11</span>    
<span class="ln">12</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">mmap</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">fsize</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="ln">13</span>    
<span class="ln">14</span>    <span class="k">if</span> <span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[MMAP] Error creating shared memory for file reading! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">15</span>    
<span class="ln">16</span>    <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;[CLOSE] Error closing mapped file! ABORT. &#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">17</span>
<span class="ln">18</span>    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="ln">19</span>
<span class="ln">20</span><span class="p">}</span>
</code></pre></div><p>Using <code>mmap</code> is simple and straight forward. I create the above function <code>map_shared_file()</code> to do and hide all the usual error handling. The function returns a pointer which allows reading the file simply by accessing the pointer. The function also returns the file size of the corpus which I will need later.</p>
<blockquote>
<p>BTW: I also tested loading the corpus file into memory. Surprisingly, this did <em><strong>not</strong></em> result in any measurable performance improvement. On the contrary, in some scenarios loading the file into memory was somewhat slower than mapping the file.</p>
</blockquote>
<h4 id="2-read-the-corpus-word-by-word">2. Read the corpus word by word</h4>
<p>To process the corpus word by word, I first introduce an object for representing a <em>word</em> that I can use throughout the program. I call it the <code>corpus_token_t</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">// basic structure to represent a &#39;word/token&#39; that exists in the corpus
</span><span class="ln">2</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">corpus_token_t</span><span class="p">{</span>
<span class="ln">3</span>    <span class="n">size_t</span> <span class="n">off</span><span class="p">;</span>                 <span class="c1">// offset of 1st occurrence in corpus
</span><span class="ln">4</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>                    <span class="c1">// length of the token, not null-terminated
</span><span class="ln">5</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">count</span><span class="p">;</span>               <span class="c1">// counter for how many times this token is found
</span><span class="ln">6</span><span class="c1"></span><span class="p">}</span> <span class="n">corpus_token_t</span><span class="p">;</span>
</code></pre></div><p>If you have worked on NLP you&rsquo;re familiar with the <em>token</em> terminology. It&rsquo;s neither a coin nor a password. And has no relationship to cryptocurrencies. In some languages, such as Chinese or other Asian languages, the most basic element of a sentence or a text is not a <em>word</em> but a <em>character</em>. A <em>token</em> represents an element of the written language: either a single <em>character</em> or a series of characters, i.e. a <em>word</em>.</p>
<p>To maximize performance my <code>corpus_token_t</code> object does <em><strong>not</strong></em> include a <code>string</code> or the actual character representation of the token. (Yes, I know. C doesn&rsquo;t have a <code>string</code> in the first place. But you know what I mean.) Instead, I only store the <em>offset</em> of the first occurrence of this token in the corpus. Plus its <em>length</em> and a <em>count</em>er for how many times this token appeared in the corpus.</p>
<p>Now, I can stroll along and read the file. But wait. What&rsquo;s that? I see 2 bumps in this walk in the park: multi-byte sequences and word boundaries.</p>
<h5 id="multi-byte-sequences">Multi-byte sequences</h5>
<p>I want to be able to read Wikipedia dumps (or any other text files for that matter) of <em>any</em> language. Therefore, I can&rsquo;t read the file simply <code>char</code> by <code>char</code> because in many languages a single &lsquo;letter&rsquo;, or character, uses more than a single byte <code>char</code>.</p>
<p><em>UTF8</em> has become a de facto standard in the digital world. Unfortunately, in <em>UTF8</em> there is no fixed character length. Characters may range in size from 1 to 4 bytes which makes handling UTF8 in C a bit of a pain.</p>
<p>Fortunately, there are some small libraries to come to the rescue. Jeff Bezanson&rsquo;s early groundwork for UTF8 processing called &lsquo;<a href="https://github.com/JeffBezanson/cutef8">cutef8</a>&rsquo;, for example. I grab his macro for identifying whether a <code>char</code> is UTF8&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="cp">#define IS_UTF8(c) (((c)&amp;0xC0)!=0x80)
</span></code></pre></div><p>&hellip; and pump up his original <code>u8_memchr</code> function to create the following <code>get_next_token</code> function to read a text segment of given length token by token:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">bool</span> <span class="n">USE_SINGLE_CHARS_AS_TOKENS</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// set to &#39;true&#39; for Asian languages
</span><span class="ln"> 2</span><span class="c1"></span>
<span class="ln"> 3</span><span class="n">corpus_token_t</span> <span class="nf">get_next_token</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">end</span><span class="p">){</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln"> 6</span>    <span class="n">size_t</span> <span class="n">start_idx</span> <span class="o">=</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
<span class="ln"> 7</span>    
<span class="ln"> 8</span>    <span class="c1">// move IDX forward in case it points INSIDE of a multibyte character
</span><span class="ln"> 9</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_UTF8</span><span class="p">(</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">])</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="ln">10</span>    
<span class="ln">11</span>    <span class="c1">// move IDX gradually forward
</span><span class="ln">12</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="o">&lt;</span><span class="n">MAX_TOKEN_STRING_LENGTH</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]</span> <span class="p">){</span>
<span class="ln">13</span>        
<span class="ln">14</span>        <span class="n">uint32_t</span> <span class="n">u8_char_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">15</span>        <span class="kt">int</span>      <span class="n">u8_char_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">16</span>        
<span class="ln">17</span>        <span class="k">do</span> <span class="p">{</span>
<span class="ln">18</span>            <span class="n">u8_char_code</span> <span class="o">&lt;&lt;=</span> <span class="mi">6</span><span class="p">;</span>
<span class="ln">19</span>            <span class="n">u8_char_code</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">];</span>
<span class="ln">20</span>            <span class="n">u8_char_size</span><span class="o">++</span><span class="p">;</span>
<span class="ln">21</span>            <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
<span class="ln">22</span>        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_UTF8</span><span class="p">(</span><span class="n">corpus</span><span class="p">[</span><span class="o">*</span><span class="n">idx</span><span class="p">]));</span>
<span class="ln">23</span>
<span class="ln">24</span>        <span class="n">u8_char_code</span> <span class="o">-=</span> <span class="n">UTF8_OFFSETS</span><span class="p">[</span><span class="n">u8_char_size</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
<span class="ln">25</span>
<span class="ln">26</span>        <span class="c1">// 3 exit conditions: (1) multi-byte character, (2) end of text, (3) token delimiter
</span><span class="ln">27</span><span class="c1"></span>        <span class="kt">bool</span> <span class="n">is_del</span> <span class="o">=</span> <span class="n">is_token_delimiter</span><span class="p">(</span><span class="n">u8_char_code</span><span class="p">);</span>
<span class="ln">28</span>        <span class="k">if</span> <span class="p">(</span><span class="n">is_del</span> <span class="o">||</span> <span class="o">*</span><span class="n">idx</span><span class="o">==</span><span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">USE_SINGLE_CHARS_AS_TOKENS</span> <span class="o">&amp;&amp;</span> <span class="n">u8_char_size</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
<span class="ln">29</span>            <span class="n">tok</span><span class="p">.</span><span class="n">len</span>   <span class="o">=</span> <span class="n">is_del</span> <span class="o">?</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span> <span class="o">-</span> <span class="n">u8_char_size</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="p">);</span>
<span class="ln">30</span>            <span class="n">tok</span><span class="p">.</span><span class="n">off</span>   <span class="o">=</span> <span class="n">start_idx</span><span class="p">;</span>
<span class="ln">31</span>            <span class="n">tok</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">32</span>            <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">33</span>        <span class="p">}</span>
<span class="ln">34</span>        
<span class="ln">35</span>    <span class="p">}</span>
<span class="ln">36</span>    
<span class="ln">37</span>    <span class="c1">// if no token was found, return empty token reference
</span><span class="ln">38</span><span class="c1"></span>    <span class="n">tok</span><span class="p">.</span><span class="n">len</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">39</span>    <span class="n">tok</span><span class="p">.</span><span class="n">off</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">40</span>    <span class="n">tok</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">41</span>    
<span class="ln">42</span>    <span class="k">return</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">43</span><span class="p">}</span>
</code></pre></div><p>Good. This takes care of bump #1. Moving on.</p>
<h5 id="word-boundaries">Word boundaries</h5>
<p>What constitutes a <em>&lsquo;word&rsquo;</em>? In most Western languages one obvious answer is a whitespace between two characters. Sure. But there are plenty of other characters and cases to consider. I wrap all such characters into a function <code>is_token delimiter</code>. Whenever a <em>token delimiter</em> is read, the end, or boundary, of a token has been reached.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">bool</span> <span class="nf">is_token_delimiter</span><span class="p">(</span><span class="n">u_int32_t</span> <span class="n">utf_code</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="k">return</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">(</span>
<span class="ln"> 4</span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">32</span>    <span class="o">||</span> <span class="c1">// &#34; &#34; space
</span><span class="ln"> 5</span><span class="c1"></span>
<span class="ln"> 6</span>                   <span class="n">utf_code</span> <span class="o">==</span>  <span class="mi">9</span>    <span class="o">||</span> <span class="c1">// &#34; &#34; tab
</span><span class="ln"> 7</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">10</span>    <span class="o">||</span> <span class="c1">// &#34;\n&#34; linefeed
</span><span class="ln"> 8</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">13</span>    <span class="o">||</span> <span class="c1">// &#34;&#34; carriage return
</span><span class="ln"> 9</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">33</span>    <span class="o">||</span> <span class="c1">// &#39;!&#39;
</span><span class="ln">10</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">34</span>    <span class="o">||</span> <span class="c1">// &#39;&#34;&#39;
</span><span class="ln">11</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">35</span>    <span class="o">||</span> <span class="c1">// &#39;#&#39;
</span><span class="ln">12</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">39</span>    <span class="o">||</span> <span class="c1">// &#39;&#39;&#39;
</span><span class="ln">13</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">40</span>    <span class="o">||</span> <span class="c1">// &#39;(&#39;
</span><span class="ln">14</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">41</span>    <span class="o">||</span> <span class="c1">// &#39;)&#39;
</span><span class="ln">15</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">42</span>    <span class="o">||</span> <span class="c1">// &#39;*&#39;
</span><span class="ln">16</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">43</span>    <span class="o">||</span> <span class="c1">// &#39;+&#39;
</span><span class="ln">17</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">44</span>    <span class="o">||</span> <span class="c1">// &#39;,&#39;
</span><span class="ln">18</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">46</span>    <span class="o">||</span> <span class="c1">// &#39;.&#39;
</span><span class="ln">19</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">47</span>    <span class="o">||</span> <span class="c1">// &#39;/&#39;
</span><span class="ln">20</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">58</span>    <span class="o">||</span> <span class="c1">// &#39;:&#39;
</span><span class="ln">21</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">59</span>    <span class="o">||</span> <span class="c1">// &#39;;&#39;
</span><span class="ln">22</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">60</span>    <span class="o">||</span> <span class="c1">// &#39;&lt;&#39;
</span><span class="ln">23</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">61</span>    <span class="o">||</span> <span class="c1">// &#39;=&#39;
</span><span class="ln">24</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">62</span>    <span class="o">||</span> <span class="c1">// &#39;&gt;&#39;
</span><span class="ln">25</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">63</span>    <span class="o">||</span> <span class="c1">// &#39;?&#39;
</span><span class="ln">26</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">91</span>    <span class="o">||</span> <span class="c1">// &#39;[&#39;
</span><span class="ln">27</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">92</span>    <span class="o">||</span> <span class="c1">// &#39;\&#39;
</span><span class="ln">28</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">93</span>    <span class="o">||</span> <span class="c1">// &#39;]&#39;
</span><span class="ln">29</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">95</span>    <span class="o">||</span> <span class="c1">// &#39;_&#39;
</span><span class="ln">30</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">123</span>   <span class="o">||</span> <span class="c1">// &#39;{&#39;
</span><span class="ln">31</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">124</span>   <span class="o">||</span> <span class="c1">// &#39;|&#39;
</span><span class="ln">32</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">125</span>   <span class="o">||</span> <span class="c1">// &#39;}&#39;
</span><span class="ln">33</span><span class="c1"></span>
<span class="ln">34</span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8212</span>  <span class="o">||</span> <span class="c1">// &#39;—&#39;&#39;
</span><span class="ln">35</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8216</span>  <span class="o">||</span> <span class="c1">// &#39;‘&#39;
</span><span class="ln">36</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8217</span>  <span class="o">||</span> <span class="c1">// &#39;’&#39;
</span><span class="ln">37</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8220</span>  <span class="o">||</span> <span class="c1">// &#39;“&#39;
</span><span class="ln">38</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">8221</span>  <span class="o">||</span> <span class="c1">// &#39;”&#39;
</span><span class="ln">39</span><span class="c1"></span>
<span class="ln">40</span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">12289</span> <span class="o">||</span>  <span class="c1">// u8&#34;、&#34;
</span><span class="ln">41</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">12290</span> <span class="o">||</span>  <span class="c1">// u8&#34;。&#34;
</span><span class="ln">42</span><span class="c1"></span>                   
<span class="ln">43</span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65281</span> <span class="o">||</span>  <span class="c1">// u8&#34;！&#34;
</span><span class="ln">44</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65288</span> <span class="o">||</span>  <span class="c1">// u8&#34;（&#34;
</span><span class="ln">45</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65289</span> <span class="o">||</span>  <span class="c1">// u8&#34;）&#34;
</span><span class="ln">46</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65292</span> <span class="o">||</span>  <span class="c1">// u8&#34;，&#34;
</span><span class="ln">47</span><span class="c1"></span>                   
<span class="ln">48</span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65306</span> <span class="o">||</span>  <span class="c1">// u8&#34;：&#34;
</span><span class="ln">49</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65307</span> <span class="o">||</span>  <span class="c1">// u8&#34;；&#34;
</span><span class="ln">50</span><span class="c1"></span>                   <span class="n">utf_code</span> <span class="o">==</span> <span class="mi">65311</span> <span class="o">||</span>  <span class="c1">// u8&#34;？&#34;
</span><span class="ln">51</span><span class="c1"></span>
<span class="ln">52</span>                   <span class="p">(</span><span class="n">utf_code</span>  <span class="o">&gt;=</span>  <span class="mi">917600</span> <span class="o">&amp;&amp;</span> <span class="n">utf_code</span>  <span class="o">&lt;=</span>  <span class="mi">917699</span><span class="p">)</span> <span class="o">||</span>
<span class="ln">53</span>                   <span class="p">(</span><span class="n">utf_code</span>  <span class="o">&gt;=</span> <span class="mi">1113000</span> <span class="o">&amp;&amp;</span> <span class="n">utf_code</span>  <span class="o">&lt;=</span> <span class="mi">1113100</span><span class="p">)</span>
<span class="ln">54</span>
<span class="ln">55</span>                   <span class="p">);</span>
<span class="ln">56</span>    
<span class="ln">57</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>The definition of <em>token delimiters</em> impacts the number of tokens put into the dictionary and their respective counts. If the raw text version of the Wikipedia dump file does not include punctuation then you don&rsquo;t need this many token delimiters because most of these characters have already been removed during XML to TXT conversion.</p>
</blockquote>
<p>Equipped with these two functions I can now loop through the file and pick up all its tokens as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">char</span> <span class="n">CORPUS_FILE_NAME</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;enwiki.txt&#34;</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span><span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">;</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">map_shared_file</span><span class="p">(</span><span class="n">CORPUS_FILE_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_fsize</span><span class="p">);</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span><span class="n">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8</span><span class="n">size_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">corpus_fsize</span><span class="p">;</span>
<span class="ln"> 9</span>
<span class="ln">10</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">11</span>
<span class="ln">12</span><span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
<span class="ln">13</span>    <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="ln">14</span>
<span class="ln">15</span>    <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">16</span>
<span class="ln">17</span>        <span class="c1">// do something with this token....
</span><span class="ln">18</span><span class="c1"></span>                
<span class="ln">19</span>    <span class="p">}</span>
<span class="ln">20</span>
<span class="ln">21</span><span class="p">}</span>
</code></pre></div><p>Straight forward and painless. So far, so good. What&rsquo;s next? What do I <em>do</em> with the tokens read from the corpus?</p>
<h4 id="3-deduplicate-all-words">3. Deduplicate all words</h4>
<p>A dictionary is a list of all the <em>unique</em> words, or tokens, in a text. Therefore, I need to <em>deduplicate</em> the tokens. And do so at the speed of light.</p>
<p>Enter hash tables. One of the most efficient tools for deduplication and quick lookups is a <a href="https://en.wikipedia.org/wiki/Hash_table"><em>hash table</em></a>. The <em>string</em> of a token shall serve as my hash key. I&rsquo;m sketching down the main steps I need to implement:</p>
<ol>
<li>Create the hash table</li>
<li>Hash a string</li>
<li>Compare tokens</li>
<li>Insert a token into the hash table</li>
</ol>
<h5 id="create-the-hash-table">Create the hash table</h5>
<p>The hash table itself is nothing but an <em>array</em> of <code>corpus_token_t</code> objects. Not a fan of dynamically resized arrays, I wonder about its size. There is no agreed definition of the <em>ideal</em> or <em>best</em> size of a hash table. <a href="https://stackoverflow.com/questions/22741966/how-to-choose-size-of-hash-table">Some</a> argue its load factor &ndash; the share of hash table entries, or buckets, that are filled &ndash; should not exceed 70%. Sounds like a reasonable metric to start from.</p>
<p>But wait. The size of the hash table depends on the size of the dictionary, which in return depends on the size of the corpus text. Would it not be ideal to link the size of the hash table directly to &hellip; say &hellip; corpus file size? After all, if the table is too big, I&rsquo;ll be wasting lots of memory. If it&rsquo;s too small, I&rsquo;ll have lots of hash &lsquo;misses&rsquo; which will slow down performance.</p>
<p>I decide to sacrifice a few bits for the sake of performance, and come up with the following, somewhat arbitrary, formula that defines hash size based on file size:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">=</span> <span class="mi">30000</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">log10</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">));</span>
<span class="ln">2</span><span class="c1">//    MAX_HASH_LENGTH = 13727587;
</span><span class="ln">3</span><span class="c1">//    MAX_HASH_LENGTH = 18303449;
</span><span class="ln">4</span><span class="c1">//    MAX_HASH_LENGTH = 36606883;
</span><span class="ln">5</span><span class="c1">//    MAX_HASH_LENGTH = 53150323;
</span><span class="ln">6</span><span class="c1">//    MAX_HASH_LENGTH = 80000023;
</span><span class="ln">7</span><span class="c1"></span>
<span class="ln">8</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok_htab</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">MAX_HASH_SIZE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</code></pre></div><p>The function includes, as comments, some of the <em>fixed</em> sizes that I used. They&rsquo;re all prime numbers which arguably make better hashes. And if you wonder how do I get a prime number above, say, 50 million? No, I didn&rsquo;t calculate them. I used <a href="http://compoasso.free.fr/primelistweb/page/prime/liste_online_en.php">this online tool</a> to simply look them up.</p>
<h5 id="hash-a-string">Hash a string</h5>
<p>Next, I need to hash each token to obtain a unique code. Remember that our <code>corpus_token_t</code> object does not include the actual character representation (aka <code>string</code>) of this token?</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">get_token_string</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">memcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">corpus</span> <span class="o">+</span> <span class="n">tok</span><span class="p">.</span><span class="n">off</span><span class="p">,</span> <span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
<span class="ln"> 4</span>    <span class="n">memset</span><span class="p">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="c1">// convert to lower case
</span><span class="ln"> 7</span><span class="c1"></span>    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span>
<span class="ln"> 8</span>    <span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)))</span> <span class="o">++</span><span class="n">p</span><span class="p">;</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="k">return</span><span class="p">;</span>
<span class="ln">11</span><span class="p">}</span>
</code></pre></div><p>I first need to obtain the string before I can create a hash. I also convert all tokens to lowercase to more efficiently utilize the hash table. And for most NLP tasks the <em>case</em> of a word is insignificant.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">size_t</span> <span class="nf">get_token_hash</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="c1">// create a character representation of the token
</span><span class="ln"> 4</span><span class="c1"></span>    <span class="kt">char</span> <span class="n">tok_str</span><span class="p">[</span><span class="n">MAX_TOKEN_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="ln"> 5</span>    <span class="n">get_token_string</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">tok_str</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="c1">// hash the token string
</span><span class="ln"> 8</span><span class="c1"></span>    
<span class="ln"> 9</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">tok_str</span><span class="p">;</span>
<span class="ln">10</span>    
<span class="ln">11</span>    <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">5381</span><span class="p">;</span>
<span class="ln">12</span>    
<span class="ln">13</span>    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
<span class="ln">14</span>
<span class="ln">15</span>    <span class="k">while</span> <span class="p">((</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">str</span><span class="o">++</span><span class="p">))</span> <span class="n">hash</span> <span class="o">=</span> <span class="p">((</span><span class="n">hash</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="n">hash</span><span class="p">)</span> <span class="o">^</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// hash * 33 XOR c 
</span><span class="ln">16</span><span class="c1"></span>
<span class="ln">17</span>    <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
<span class="ln">18</span>        
<span class="ln">19</span><span class="p">}</span>
</code></pre></div><p>For the actual hashing, I use <a href="https://en.wikipedia.org/wiki/Daniel_J._Bernstein">Daniel J. Bernstein&rsquo;s</a> DJB2 hash function which is simple and works well for strings. Feel free to try <a href="http://www.cse.yorku.ca/~oz/hash.html">others</a>.</p>
<h5 id="compare-tokens">Compare tokens</h5>
<p>When I insert a token into the hash table, I need to check for potential collisions. Therefore, I need a comparison function to assess whether two tokens are equal.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="c1">// compare two integers and return the smaller one
</span><span class="ln"> 2</span><span class="c1"></span><span class="cp">#define MIN_OF_TWO(a,b) ({ __typeof__ (a) _a = (a); __typeof__ (b) _b = (b);  _a &lt; _b ? _a : _b; })
</span><span class="ln"> 3</span><span class="cp"></span>
<span class="ln"> 4</span><span class="kt">int</span> <span class="nf">compare_corpus_tokens</span><span class="p">(</span><span class="k">const</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok1</span><span class="p">,</span> <span class="k">const</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">tok2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 5</span>    
<span class="ln"> 6</span>    <span class="kt">int</span> <span class="n">len1</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">tok1</span><span class="p">).</span><span class="n">len</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="kt">int</span> <span class="n">len2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">tok2</span><span class="p">).</span><span class="n">len</span><span class="p">;</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">MIN_OF_TWO</span><span class="p">(</span><span class="n">len1</span><span class="p">,</span> <span class="n">len2</span><span class="p">);</span>
<span class="ln">10</span>    
<span class="ln">11</span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str1</span> <span class="o">=</span> <span class="n">corpus</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tok1</span><span class="p">).</span><span class="n">off</span><span class="p">;</span>
<span class="ln">12</span>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str2</span> <span class="o">=</span> <span class="n">corpus</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">tok2</span><span class="p">).</span><span class="n">off</span><span class="p">;</span>
<span class="ln">13</span>
<span class="ln">14</span>    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">strncasecmp</span><span class="p">(</span><span class="n">str1</span><span class="p">,</span> <span class="n">str2</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="ln">15</span>    
<span class="ln">16</span>    <span class="c1">// both strings differ in the first &#39;len&#39; chars
</span><span class="ln">17</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="ln">18</span>    
<span class="ln">19</span>    <span class="c1">// both strings are the same
</span><span class="ln">20</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">len1</span> <span class="o">==</span> <span class="n">len2</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">21</span>    
<span class="ln">22</span>    <span class="c1">// if both strings have a different length but share the first &#39;len&#39; characters
</span><span class="ln">23</span><span class="c1"></span>    <span class="c1">// the shorter one is the smaller one
</span><span class="ln">24</span><span class="c1"></span>    
<span class="ln">25</span>    <span class="k">if</span> <span class="p">(</span><span class="n">len1</span> <span class="o">&lt;</span> <span class="n">len2</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln">26</span>    
<span class="ln">27</span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">28</span><span class="p">}</span>
</code></pre></div><p>The above function does that efficiently using <em>pointers</em> only.</p>
<h5 id="insert-a-token-into-the-hash-table">Insert a token into the hash table</h5>
<p>At last, I insert the token into the hash table. If the token already exists, its counter will be incremented. If the assigned seat number on the hash table bus is taken already, let the token move on and find the next empty spot.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">insert_token</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6</span>        <span class="c1">// check if this bucket is empty
</span><span class="ln"> 7</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8</span>            
<span class="ln"> 9</span>            <span class="c1">// if the same token already exists in the hash table increment its counter
</span><span class="ln">10</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">11</span>                <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="ln">12</span>                <span class="k">return</span><span class="p">;</span>
<span class="ln">13</span>                
<span class="ln">14</span>            <span class="p">}</span>
<span class="ln">15</span>            <span class="c1">// otherwise move forward to the next bucket
</span><span class="ln">16</span><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
<span class="ln">17</span>                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
<span class="ln">18</span>                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
<span class="ln">19</span>            <span class="p">}</span>
<span class="ln">20</span>            
<span class="ln">21</span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">22</span>            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span><span class="ln">23</span><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">24</span>            <span class="k">return</span><span class="p">;</span>
<span class="ln">25</span>        <span class="p">}</span>
<span class="ln">26</span>        
<span class="ln">27</span>    <span class="p">}</span>
<span class="ln">28</span>    
<span class="ln">29</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>Note to self: The function does not check whether the hash table is large enough to fit all tokens. In fact, if there were more tokens to put in the dictionary than there are buckets in the hash table the loop would run infinitely. @todo</p>
</blockquote>
<p>After all tokens are placed, the number of filled buckets tells me the number of unique tokens in the dictionary.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">size_t</span> <span class="nf">get_htab_token_count</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_HASH_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln"> 6</span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="ln"> 9</span><span class="p">}</span>
<span class="ln">10</span>
</code></pre></div><h4 id="4-sort-the-words-by-count-in-descending-order">4. Sort the words by count in descending order</h4>
<p>Almost there. I have read and deduplicated all tokens, and popped them into a gargantuan, sparsely populated hash table. I also calculated the word count. But how do I sort a hash table?</p>
<p>You don&rsquo;t. Instead, I first copy all unique tokens into a more compact representation: an <code>array</code> of tokens, a.k.a. the dictionary.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="nf">create_dictionary</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">dict_tok_count</span><span class="p">,</span> <span class="n">size_t</span> <span class="o">*</span><span class="n">corpus_tok_count</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="o">*</span><span class="n">corpus_tok_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">dict_tok_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>    <span class="n">size_t</span> <span class="n">didx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 8</span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">hidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">hidx</span><span class="o">&lt;</span><span class="n">MAX_HASH_SIZE</span><span class="p">;</span> <span class="n">hidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 9</span>    
<span class="ln">10</span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">11</span>            <span class="o">*</span><span class="n">corpus_tok_count</span> <span class="o">+=</span> <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>  <span class="c1">// calc overall token count
</span><span class="ln">12</span><span class="c1"></span>            <span class="n">dict</span><span class="p">[</span><span class="n">didx</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">];</span>              <span class="c1">// add token into dictionary
</span><span class="ln">13</span><span class="c1"></span>        <span class="p">}</span>
<span class="ln">14</span>        
<span class="ln">15</span>    <span class="p">}</span>
<span class="ln">16</span>        
<span class="ln">17</span>    <span class="n">assert</span><span class="p">(</span><span class="n">didx</span> <span class="o">==</span> <span class="n">dict_tok_count</span><span class="p">);</span>
<span class="ln">18</span>    
<span class="ln">19</span>    <span class="k">return</span> <span class="n">dict</span><span class="p">;</span>
<span class="ln">20</span><span class="p">}</span>
</code></pre></div><p>The dictionary can then be easily sorted using a standard <code>qsort</code> algorithm.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">int</span> <span class="nf">compare_token_counters</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">freq_a</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">).</span><span class="n">count</span><span class="p">;</span>
<span class="ln"> 4</span>    <span class="n">size_t</span> <span class="n">freq_b</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">).</span><span class="n">count</span><span class="p">;</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="k">if</span> <span class="p">(</span><span class="n">freq_a</span> <span class="o">&lt;</span> <span class="n">freq_b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="k">if</span> <span class="p">(</span><span class="n">freq_a</span> <span class="o">&gt;</span> <span class="n">freq_b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="ln"> 8</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9</span><span class="p">}</span>
<span class="ln">10</span>
<span class="ln">11</span>
<span class="ln">12</span><span class="kt">void</span> <span class="nf">sort_dict</span><span class="p">(</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">dict_tok_count</span><span class="p">){</span>
<span class="ln">13</span>    
<span class="ln">14</span>    <span class="n">qsort</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">dict_tok_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">),</span> <span class="n">compare_token_counters</span><span class="p">);</span>
<span class="ln">15</span>
<span class="ln">16</span><span class="p">}</span>   
</code></pre></div><p>That&rsquo;s it. The moment of truth. I put all the above together: process the corpus, deduplicate tokens, count their occurrences, and sort the dictionary. And while I&rsquo;m at it, I print out the top 10. Because I&rsquo;m curious.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">text2dict</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">;</span>
<span class="ln"> 4</span>    <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span> <span class="o">=</span> <span class="n">map_shared_file</span><span class="p">(</span><span class="n">CORPUS_FILE_NAME</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_fsize</span><span class="p">);</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="n">MAX_HASH_SIZE</span> <span class="o">=</span> <span class="mi">100000</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">log10</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">));</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span>  <span class="o">=</span> <span class="n">create_token_hash</span> <span class="n">table</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">);</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="n">size_t</span> <span class="n">dict_tok_count</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">11</span>    <span class="n">size_t</span> <span class="n">corpus_tok_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">12</span>    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">dict</span> <span class="o">=</span> <span class="n">create_dictionary</span><span class="p">(</span><span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dict_tok_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">corpus_tok_count</span><span class="p">);</span>
<span class="ln">13</span>    
<span class="ln">14</span>    <span class="n">sort_dict</span><span class="p">(</span><span class="n">dict</span><span class="p">,</span> <span class="n">dict_tok_count</span><span class="p">);</span>
<span class="ln">15</span>    
<span class="ln">16</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;# of tokens in corpus: [%&#39;15lu]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">corpus_tok_count</span><span class="p">);</span>
<span class="ln">17</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;# of tokens in dict:   [%&#39;15lu]</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">dict_tok_count</span><span class="p">);</span>
<span class="ln">18</span>
<span class="ln">19</span>    
<span class="ln">20</span>    <span class="kt">char</span> <span class="n">tok_str</span><span class="p">[</span><span class="n">MAX_TOKEN_SIZE</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="ln">21</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Top 10:</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">22</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">23</span>        <span class="n">get_token_string</span><span class="p">(</span><span class="n">dict</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tok_str</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln">24</span>        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;#%2d: %&#39;12zu = %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">dict</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">count</span><span class="p">,</span> <span class="n">tok_str</span><span class="p">);</span>
<span class="ln">25</span>    <span class="p">}</span>
<span class="ln">26</span>     
<span class="ln">27</span>    <span class="c1">// clean up
</span><span class="ln">28</span><span class="c1"></span>    <span class="n">free</span><span class="p">(</span><span class="n">dict</span><span class="p">);</span>
<span class="ln">29</span>    <span class="n">free</span><span class="p">(</span><span class="n">htab</span><span class="p">);</span>
<span class="ln">30</span>    <span class="n">unmap_shared_memory</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">);</span>
<span class="ln">31</span>
<span class="ln">32</span>    <span class="k">return</span><span class="p">;</span>
<span class="ln">33</span><span class="p">}</span>
</code></pre></div><p>I call the function <code>text2dict</code> which later turned into its own <a href="https://github.com/mmlind/text2dict/">Github project</a>. When I run the code I get the following result:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln"> 1</span>Execution time: 756 seconds
<span class="ln"> 2</span>
<span class="ln"> 3</span># of tokens in corpus: [  2,796,219,305]
<span class="ln"> 4</span># of tokens in dict:   [      9,925,231]
<span class="ln"> 5</span>
<span class="ln"> 6</span>Top 10:
<span class="ln"> 7</span># 1:  187,816,162 = the
<span class="ln"> 8</span># 2:   94,989,894 = of
<span class="ln"> 9</span># 3:   79,019,494 = and
<span class="ln">10</span># 4:   76,509,997 = in
<span class="ln">11</span># 5:   52,986,487 = to
<span class="ln">12</span># 6:   30,276,740 = was
<span class="ln">13</span># 7:   23,445,023 = is
<span class="ln">14</span># 8:   23,133,852 = for
<span class="ln">15</span># 9:   22,621,486 = on
<span class="ln">16</span>#10:   22,363,826 = as
</code></pre></div><p>I&rsquo;m getting pumped. Creating the dictionary sequentially via C takes 756 seconds, compared to 3,430 seconds from the first Python script, and 1,402 seconds from the second Python script. OMG. From now on, I will have to wait <em>only</em> 12 minutes each time I create the dictionary. Life is beautiful. Mine just extended another 10 minutes.</p>
<h2 id="parallel-processing-of-text-corpora">Parallel processing of text corpora</h2>
<p>After a short moment of rejoicing, I recall my original objective: utilizing <em>multiple</em> cores. Alright. Let&rsquo;s do this. I&rsquo;m rolling up the sleeves. What hardware shall I use for the ride?</p>
<h3 id="the-hardware">The hardware</h3>
<p>The first machine is my Mac Mini. I ordered it with full specs: 6 cores, 64 GB RAM.</p>
<p><img src="/images/mac_sysinfo.png" alt=""></p>
<p>Can I trust the system info? Let me check the number of processing units via code:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">long</span> <span class="n">nproc</span> <span class="o">=</span> <span class="n">sysconf</span><span class="p">(</span><span class="n">_SC_NPROCESSORS_ONLN</span><span class="p">);</span>
</code></pre></div><p>The <code>sysconf</code> returns &hellip;. <em><strong>12</strong></em>. Why the difference to the <em><strong>6</strong></em> cores that were reported by the system configuration window? <a href="https://de.wikipedia.org/wiki/Hyper-Threading">Hyperthreading</a>. 6 <em>physical</em> cores are presented as 12 <em>virtual</em> cores to the operating system.</p>
<p>Anyway. 6 or 12, not much of a difference, I&rsquo;m thinking. If I want to investigate the <em>scalability</em> of parallel processing I better prepare a bit more firepower.</p>
<h3 id="utilizing-azure-cloud-servers">Utilizing Azure cloud servers</h3>
<p>Enter Azure cloud servers. Microsoft&rsquo;s Azure cloud offering is immense. You can order servers ranging from 1 to 416 cores. Yes, that&rsquo;s <em>four hundred sixteen cores</em>.  And not only does the &lsquo;M416ms_v2&rsquo; come with a whopping 416 cores, but it also boasts 11 TB of RAM. What?! Yes, that&rsquo;s not a typo. It&rsquo;s a T, not a G. That&rsquo;s more than 5 times my hard drive capacity &hellip; in RAM.</p>
<p>Naturally, I want to include this beast in my testing and reach out to Azure support to get my hands on it. I am, however, advised that these servers require a corporate account. Why? Well, for one, I guess, because this machine runs at $95k per month. That&rsquo;s &ldquo;k&rdquo; as in kilo. Oops. I know some people like <a href="https://mijailovic.net/2020/03/28/azure-money-burning/">burning money on Azure</a> but this exceeds my budget just a tiny little bit.</p>
<p>Instead, I pick 2 other models. The first one is the &ldquo;F64s_v2&rdquo; with 64 cores and 128 GB RAM, running Debian Buster. I call it my &ldquo;VM64&rdquo;. I fire it up and print some system info from the console:</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="ln"> 1</span>$ lscpu
<span class="ln"> 2</span>
<span class="ln"> 3</span>Architecture:        x86_64
<span class="ln"> 4</span>CPU op-mode<span class="o">(</span>s<span class="o">)</span>:      32-bit, 64-bit
<span class="ln"> 5</span>Byte Order:          Little Endian
<span class="ln"> 6</span>Address sizes:       <span class="m">46</span> bits physical, <span class="m">48</span> bits virtual
<span class="ln"> 7</span>CPU<span class="o">(</span>s<span class="o">)</span>:              <span class="m">64</span>
<span class="ln"> 8</span>On-line CPU<span class="o">(</span>s<span class="o">)</span> list: 0-63
<span class="ln"> 9</span>Thread<span class="o">(</span>s<span class="o">)</span> per core:  <span class="m">2</span>
<span class="ln">10</span>Core<span class="o">(</span>s<span class="o">)</span> per socket:  <span class="m">16</span>
<span class="ln">11</span>Socket<span class="o">(</span>s<span class="o">)</span>:           <span class="m">2</span>
<span class="ln">12</span>NUMA node<span class="o">(</span>s<span class="o">)</span>:        <span class="m">2</span>
<span class="ln">13</span>Vendor ID:           GenuineIntel
<span class="ln">14</span>CPU family:          <span class="m">6</span>
<span class="ln">15</span>Model:               <span class="m">85</span>
<span class="ln">16</span>Model name:          Intel<span class="o">(</span>R<span class="o">)</span> Xeon<span class="o">(</span>R<span class="o">)</span> Platinum <span class="m">8168</span> CPU @ 2.70GHz
<span class="ln">17</span>Stepping:            <span class="m">4</span>
<span class="ln">18</span>CPU MHz:             2693.876
<span class="ln">19</span>BogoMIPS:            5387.75
<span class="ln">20</span>Virtualization:      VT-x
<span class="ln">21</span>Hypervisor vendor:   Microsoft
<span class="ln">22</span>Virtualization type: full
<span class="ln">23</span>L1d cache:           32K
<span class="ln">24</span>L1i cache:           32K
<span class="ln">25</span>L2 cache:            1024K
<span class="ln">26</span>L3 cache:            33792K
<span class="ln">27</span>NUMA node0 CPU<span class="o">(</span>s<span class="o">)</span>:   0-31
<span class="ln">28</span>NUMA node1 CPU<span class="o">(</span>s<span class="o">)</span>:   32-63
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="ln">1</span>$ free --giga
<span class="ln">2</span>
<span class="ln">3</span>              total        used        free      shared  buff/cache   available
<span class="ln">4</span>Mem:            <span class="m">135</span>           <span class="m">2</span>         <span class="m">132</span>           <span class="m">0</span>           <span class="m">0</span>         <span class="m">131</span>
<span class="ln">5</span>Swap:             <span class="m">0</span>           <span class="m">0</span>           <span class="m">0</span>
</code></pre></div><p>Yeah. Loading the Wikidump file into memory shouldn&rsquo;t be a problem on this one.</p>
<p>The second cloud server is the &ldquo;M128_s&rdquo; with 128 cores and 2 TB RAM, also running Debian Buster. I call it my &ldquo;VM128&rdquo;.</p>
<div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="ln"> 1</span>$ lscpu
<span class="ln"> 2</span>
<span class="ln"> 3</span>Architecture:        x86_64
<span class="ln"> 4</span>CPU op-mode<span class="o">(</span>s<span class="o">)</span>:      32-bit, 64-bit
<span class="ln"> 5</span>Byte Order:          Little Endian
<span class="ln"> 6</span>Address sizes:       <span class="m">46</span> bits physical, <span class="m">48</span> bits virtual
<span class="ln"> 7</span>CPU<span class="o">(</span>s<span class="o">)</span>:              <span class="m">128</span>
<span class="ln"> 8</span>On-line CPU<span class="o">(</span>s<span class="o">)</span> list: 0-127
<span class="ln"> 9</span>Thread<span class="o">(</span>s<span class="o">)</span> per core:  <span class="m">2</span>
<span class="ln">10</span>Core<span class="o">(</span>s<span class="o">)</span> per socket:  <span class="m">16</span>
<span class="ln">11</span>Socket<span class="o">(</span>s<span class="o">)</span>:           <span class="m">4</span>
<span class="ln">12</span>NUMA node<span class="o">(</span>s<span class="o">)</span>:        <span class="m">4</span>
<span class="ln">13</span>Vendor ID:           GenuineIntel
<span class="ln">14</span>CPU family:          <span class="m">6</span>
<span class="ln">15</span>Model:               <span class="m">85</span>
<span class="ln">16</span>Model name:          Intel<span class="o">(</span>R<span class="o">)</span> Xeon<span class="o">(</span>R<span class="o">)</span> Platinum 8280M CPU @ 2.70GHz
<span class="ln">17</span>Stepping:            <span class="m">7</span>
<span class="ln">18</span>CPU MHz:             2693.670
<span class="ln">19</span>BogoMIPS:            5387.34
<span class="ln">20</span>Virtualization:      VT-x
<span class="ln">21</span>Hypervisor vendor:   Microsoft
<span class="ln">22</span>Virtualization type: full
<span class="ln">23</span>L1d cache:           32K
<span class="ln">24</span>L1i cache:           32K
<span class="ln">25</span>L2 cache:            1024K
<span class="ln">26</span>L3 cache:            39424K
<span class="ln">27</span>NUMA node0 CPU<span class="o">(</span>s<span class="o">)</span>:   0-31
<span class="ln">28</span>NUMA node1 CPU<span class="o">(</span>s<span class="o">)</span>:   32-63
<span class="ln">29</span>NUMA node2 CPU<span class="o">(</span>s<span class="o">)</span>:   64-95
<span class="ln">30</span>NUMA node3 CPU<span class="o">(</span>s<span class="o">)</span>:   96-127
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-shell" data-lang="shell"><span class="ln">1</span>$ free --giga
<span class="ln">2</span>
<span class="ln">3</span>              total        used        free      shared  buff/cache   available
<span class="ln">4</span>Mem:           <span class="m">2164</span>           <span class="m">8</span>        <span class="m">2155</span>           <span class="m">0</span>           <span class="m">0</span>        <span class="m">2150</span>
<span class="ln">5</span>Swap:             <span class="m">0</span>           <span class="m">0</span>           <span class="m">0</span>
</code></pre></div><p>All set. Equipped with my cute Mac Mini and 2 potent cloud titans, I&rsquo;m ready to take on the parallel processing of Wikipedia.</p>
<h3 id="the-basic-design">The basic design</h3>
<p>I first assess each step of the overall algorithm from 2 angles: how does it impact performance, and how easy or difficult is it to run this step in parallel.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Steps for creating dictionary</th>
<th style="text-align:center">Impact on performance</th>
<th style="text-align:center">Difficulty to parallelize</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Reading corpus word by word</td>
<td style="text-align:center">High</td>
<td style="text-align:center">Low</td>
</tr>
<tr>
<td style="text-align:left">Inserting words into hash table</td>
<td style="text-align:center">High</td>
<td style="text-align:center">Middle</td>
</tr>
<tr>
<td style="text-align:left">Copying unique words into array</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">Middle</td>
</tr>
<tr>
<td style="text-align:left">Sorting array by word count</td>
<td style="text-align:center">Low</td>
<td style="text-align:center">High</td>
</tr>
</tbody>
</table>
<p>Good. Fortunately, the steps with a <em>high</em> impact on performance (reading the corpus, and inserting words into a hash table) are not difficult to parallelize. The steps with a <em>low</em> impact on performance (copying the words into an array and sorting the array) are not worthwhile spending a lot of extra time on. I just leave them as they are.</p>
<h3 id="reading-text-in-parallel">Reading text &lsquo;in parallel&rsquo;</h3>
<p>To read the corpus in parallel, via multiple cores, I need to divide the text into multiple segments and have each core read a different segment. Therefore, I define an object <code>range_t</code> that represents a corpus segment by its start and end <em><strong>offset</strong></em>.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="c1">// defines a segment via its first and last offset
</span><span class="ln">2</span><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">range_t</span><span class="p">{</span>
<span class="ln">3</span>    <span class="n">size_t</span> <span class="n">from</span><span class="p">;</span>    <span class="c1">// included
</span><span class="ln">4</span><span class="c1"></span>    <span class="n">size_t</span> <span class="n">to</span><span class="p">;</span>      <span class="c1">// excluded
</span><span class="ln">5</span><span class="c1"></span><span class="p">}</span> <span class="n">range_t</span><span class="p">;</span>
</code></pre></div><p>Yes. Both <code>from</code> and <code>to</code> are <em>offsets</em> relative to the corpus text and not memory addresses or pointers.</p>
<blockquote>
<p>Beware that while the <code>from</code> offset is included in the range, i.e. it&rsquo;s <em>part</em> of the segment, the <code>to</code> offset is not.</p>
</blockquote>
<p>Next, I divide the corpus into as many segments as there are cores, or processes, so that each process can work independently on a different text segment.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">range_t</span> <span class="o">*</span><span class="nf">create_segments</span><span class="p">(</span><span class="n">size_t</span> <span class="n">total_size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nsegs</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&lt;</span> <span class="n">nsegs</span><span class="p">){</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;Error creating segments. ABORT&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">nsegs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">range_t</span><span class="p">));</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="n">size_t</span> <span class="n">seg_size</span> <span class="o">=</span> <span class="n">total_size</span> <span class="o">/</span> <span class="n">nsegs</span><span class="p">;</span>
<span class="ln"> 8</span>    
<span class="ln"> 9</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">seg_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">&lt;</span><span class="n">nsegs</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">10</span>        
<span class="ln">11</span>        <span class="c1">//  divide into equally-sized segments
</span><span class="ln">12</span><span class="c1"></span>        <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="n">seg_idx</span> <span class="o">*</span> <span class="n">seg_size</span><span class="p">;</span>
<span class="ln">13</span>        <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">to</span>   <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span> <span class="o">+</span> <span class="n">seg_size</span><span class="p">;</span>
<span class="ln">14</span>        
<span class="ln">15</span>        <span class="c1">// always set the end of the last range to the end of the memory range
</span><span class="ln">16</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">==</span> <span class="n">nsegs</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">segs</span><span class="p">[</span><span class="n">nsegs</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">to</span> <span class="o">=</span> <span class="n">total_size</span><span class="p">;</span>
<span class="ln">17</span>        
<span class="ln">18</span>    <span class="p">}</span>
<span class="ln">19</span>    
<span class="ln">20</span>    <span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
<span class="ln">21</span><span class="p">}</span>
</code></pre></div><p>The problem with this approach is that I may mistakenly chop the file in the middle of a word, or possibly even in the middle of a character. Remember multi-byte characters in UTF8? Therefore, I adjust the split points between segments by simply moving each point forward to the beginning of the next token.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">range_t</span> <span class="o">*</span><span class="nf">create_corpus_segments</span><span class="p">(</span><span class="n">size_t</span> <span class="n">corpus_size</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nsegs</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="c1">// first use default, i.e. divide into equally-sized segments
</span><span class="ln"> 4</span><span class="c1"></span>    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">create_segments</span><span class="p">(</span><span class="n">corpus_size</span><span class="p">,</span> <span class="n">nsegs</span><span class="p">);</span>
<span class="ln"> 5</span>    
<span class="ln"> 6</span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="n">size_t</span> <span class="n">pos</span><span class="p">;</span>
<span class="ln"> 8</span>    
<span class="ln"> 9</span>    <span class="c1">// move the split point to the right to the start of the next token
</span><span class="ln">10</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">seg_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">&lt;</span><span class="n">nsegs</span><span class="p">;</span> <span class="n">seg_idx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">11</span>        
<span class="ln">12</span>        <span class="n">pos</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
<span class="ln">13</span>        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">corpus_size</span><span class="p">);</span>
<span class="ln">14</span>
<span class="ln">15</span>        <span class="c1">// don&#39;t shift the 1st segment since it always starts at 0
</span><span class="ln">16</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">seg_idx</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
<span class="ln">17</span>            <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span>  <span class="p">].</span><span class="n">from</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
<span class="ln">18</span>            <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">to</span>   <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
<span class="ln">19</span>        <span class="p">}</span>
<span class="ln">20</span>
<span class="ln">21</span>    <span class="p">}</span>
<span class="ln">22</span>
<span class="ln">23</span>    <span class="k">return</span> <span class="n">segs</span><span class="p">;</span>
<span class="ln">24</span><span class="p">}</span>
</code></pre></div><p>Ok. So far, so good. To read the text in parallel I won&rsquo;t need much else. I can reuse the other functions I built before. One critical piece though is missing.</p>
<h3 id="multiprocessing-and-multithreading">Multiprocessing and multithreading</h3>
<p>The 2 main technical options for a developer to implement parallel processing are <code>multiprocessing</code> and <code>multithreading</code>. Both execute multiple tasks simultaneously by spinning-off separate <code>processes</code> or <code>threads</code> that run independently of the main process.</p>
<p>For spinning-off multiple processes, I use the following general <code>fork</code> boilerplate code. All I need to add is my <code>get_next_token</code> function and tuck it into the loop.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>    <span class="kt">int</span> <span class="n">nproc</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 4</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">nproc</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 5</span>         
<span class="ln"> 6</span>         <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 7</span>         <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 8</span>             
<span class="ln"> 9</span>             <span class="c1">// code that shall be executed by each child process
</span><span class="ln">10</span><span class="c1"></span>             
<span class="ln">11</span>             <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello! I am process [%d].</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
<span class="ln">12</span>
<span class="ln">13</span>             <span class="c1">/// ...
</span><span class="ln">14</span><span class="c1"></span>             
<span class="ln">15</span>             
<span class="ln">16</span>             <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">17</span>         <span class="p">}</span>
<span class="ln">18</span>         
<span class="ln">19</span>     <span class="p">}</span>
<span class="ln">20</span>
<span class="ln">21</span>    <span class="c1">// wait for all child processes to finish
</span><span class="ln">22</span><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="ln">23</span>    
<span class="ln">24</span>    <span class="c1">// parent process proceeds....
</span></code></pre></div><p>At the end of the function, I need to make the parent process <code>wait</code> until all child processes have <code>exit</code>ed. Not waiting for child processes to finish is a frequent source of errors. The <code>wait</code> command also allows me to bring the application logic back into a single process.</p>
<blockquote>
<p>Beware that in the above <code>fork</code> boilerplate code <code>nproc</code> represents the number of <em>processes</em>, not the number of <em>processors</em>. You could run more processes than there are actual processing units or cores.</p>
</blockquote>
<h4 id="creating-the-dictionary-in-parallel">Creating the dictionary in parallel</h4>
<p>So. I finished reading the text, and feel tempted to pat myself on the back. After all, this was the heavy lifting, wasn&rsquo;t it? Surely not. I just enjoyed my appetizer, and am moving on to the main course.</p>
<p>When multiple processes simultaneously make changes to the same variable (a.k.a. they need to <a href="/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/"><em><strong>write</strong></em> to the same shared memory</a>), they may conflict, or overlap, with each other. So-called <em>race conditions</em> between processes will cause unpredictable results. Oh.</p>
<h4 id="how-to-address-race-conditions-between-multiple-tasks">How to address <em>race conditions</em> between multiple tasks?</h4>
<p>I can resolve the problem of <em>race conditions</em> in 3 ways:</p>
<ul>
<li>
<p><em><strong>Avoid</strong></em> race conditions in the first place. Do <em>not</em> have multiple processes write to the <em>same</em> memory. Instead, each process writes to a <em>different</em> memory section, and sections are merged via a <em>single</em> process at the end.</p>
</li>
<li>
<p><em><strong>Synchronize</strong></em> memory access by having each process first <em>lock</em> the memory that it wants to write to. Other processes cannot access memory that is <em>locked</em> and need to wait until the locking process <em>unlocks</em> the memory again.</p>
</li>
<li>
<p><em><strong>Communicate</strong></em> between different processes in other ways than through memory sharing, such as sending messages or <em>signals</em> to each other. (Note to self: remember this nice tutorial on IPC called <a href="http://beej.us/guide/bgipc/html/multi/">Beej&rsquo;s Guide to Unix IPC</a>.)</p>
</li>
</ul>
<p>I choose to test and compare all three, via different technical implementations. After some initial research, I jot down the following 4 methods for me to investigate: multiple hash tables (<em>avoid</em>), semaphores and mutexes (<em>synchronize</em>), and pipes (<em>communicate</em>). In particular, I want to examine these 4 methods from 2 perspectives: performance and scalability.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Parallel processing technique</th>
<th style="text-align:center">Avoid simultaneous memory access</th>
<th style="text-align:center">Synchronize simultaneous memory access</th>
<th style="text-align:center">Communicate between processes (IPC)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Multiprocessing with separate hashes</td>
<td style="text-align:center">✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Multiprocessing with semaphores</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Multithreading with mutexes</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">Multiprocessing with pipes for IPC</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
</tr>
</tbody>
</table>
<h3 id="methods-for-parallel-text-processing">Methods for parallel text processing</h3>
<p>Off I go to implement the four techniques one by one.</p>
<h4 id="1-multiprocessing-with-separate-hashes">1. Multiprocessing with separate hashes</h4>
<p>The easiest option to address <em>race conditions</em> is to avoid them. Instead of letting multiple processes write to the <em>same</em> memory, I can have each process write into its own <em>separate</em> hash table first and then merge the hash tables later. As easy as ABC. I only need to make 3 modifications to the previous code: (A) create <em>multiple</em> hash tables, (B) make each process insert tokens into a <em>different</em> hash table, and (C) merge all hash tables into <em>one</em> at the end.</p>
<h4 id="create-multiple-hash-tables">Create multiple hash tables</h4>
<p>Before I create more than one hash table I need to assess the memory impact. The length of the hash table I used before ranges from 14 to 80 million buckets. If a single <code>corpus_token_t</code> element occupies up to 24 bytes, my little friend <code>htab</code> demands a humongous 1.8 GB of RAM. And that&rsquo;s just for one. If I breed 12 of these guys, I&rsquo;ll have to kiss goodbye to 22 GB of memory. Running 128 processes? 230 GB of memory. Ouch.</p>
<p>A few seconds of silence. &hellip; &ldquo;So what!&rdquo; This is not my Sanyo MBC 550 anymore, coding Pascal on 128 KB of RAM. In only a few years, the average Mac or Surface laptop ships with at least several TB of RAM. Let&rsquo;s face it. Memory is &lsquo;cheap&rsquo;, and the machines I use for this exercise surely can handle the magnitude. I give it a go.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htabs</span> <span class="o">=</span> <span class="n">map_shared_memory</span><span class="p">(</span><span class="n">PROCESS_COUNT</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
</code></pre></div><p>This time, I cannot create the hash table simply via <code>malloc</code>. Instead, I define all of them as <em>shared</em> memory so that the parent process can later consolidate all individual tables into a single one.</p>
<h4 id="make-each-process-insert-tokens-into-a-different-hash-table">Make each process insert tokens into a different hash table</h4>
<p>Next, I need to slightly amend the function that inserts tokens into the hash table. I just add a process identifier <code>pidx</code> which I multiply by the hash size to determine the correct table for each process.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">insert_token_pp</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 4</span>    <span class="n">size_t</span> <span class="n">hidx_pp</span><span class="p">;</span>
<span class="ln"> 5</span>    
<span class="ln"> 6</span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 7</span>        
<span class="ln"> 8</span>        <span class="n">hidx_pp</span> <span class="o">=</span> <span class="p">(</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_SIZE</span><span class="p">)</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">;</span>   <span class="c1">//    &lt;-- pick the hash table for this process
</span><span class="ln"> 9</span><span class="c1"></span>        
<span class="ln">10</span>        <span class="c1">// check if this bucket is empty
</span><span class="ln">11</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">12</span>            
<span class="ln">13</span>            <span class="c1">// if the same token already exists in the hash table increment its counter
</span><span class="ln">14</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span> <span class="o">+</span> <span class="n">hidx_pp</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">15</span>                <span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="ln">16</span>                <span class="k">return</span><span class="p">;</span>
<span class="ln">17</span>                
<span class="ln">18</span>            <span class="p">}</span>
<span class="ln">19</span>            <span class="c1">// otherwise move forward to the next bucket
</span><span class="ln">20</span><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
<span class="ln">21</span>                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
<span class="ln">22</span>                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_SIZE</span><span class="p">;</span>
<span class="ln">23</span>            <span class="p">}</span>
<span class="ln">24</span>            
<span class="ln">25</span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">26</span>            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span><span class="ln">27</span><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx_pp</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">28</span>            <span class="k">return</span><span class="p">;</span>
<span class="ln">29</span>        <span class="p">}</span>
<span class="ln">30</span>        
<span class="ln">31</span>    <span class="p">}</span>
<span class="ln">32</span>    
<span class="ln">33</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>BTW: I am adding <code>_pp</code> at the end of a function to signal this function is processed in parallel by multiple processes or threads.</p>
</blockquote>
<h4 id="merge-all-hash-tables-into-one">Merge all hash tables into one</h4>
<p>After all processes have finished reading their corpus segment and adding the respective tokens into their process-specific hash table, I need to consolidate all hash tables into one.</p>
<p>For merging hash tables I cannot simply copy over the tokens and sum up their counts. The hash index of a token in one table may differ from the hash index of the same token in another table. Why? Remember that in case of a collision, the insert function moves the hash index gradually forward until an empty bucket is found. Therefore, the hash index for any given token depends on the timing. Specifically, it depends on what other tokens have been processed so far. I, therefore, merge the tables by simply using the previous <code>insert_token</code> function.</p>
<p>But how long is this going to take? Can I not <em>parallelize</em> the merging to further speed up the whole process? Sure. I divide the table into multiple segments, similar to what I did with the corpus text before. Then, I have each process merge tokens of a specific segment only. This ensures that there are no overlaps when a token is added. My merge function looks like this:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">corpus_token_t</span> <span class="o">*</span><span class="nf">merge_hashtables</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htabs</span><span class="p">){</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span>    <span class="c1">// create a new empty hash table that will hold the merged results of all processes&#39; hash tables
</span><span class="ln"> 4</span><span class="c1"></span>    <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span> <span class="o">=</span> <span class="n">map_shared_memory</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">));</span>
<span class="ln"> 5</span>    
<span class="ln"> 6</span>    <span class="n">range_t</span> <span class="o">*</span><span class="n">hsegs</span> <span class="o">=</span> <span class="n">create_segments</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span><span class="p">,</span> <span class="n">PROCESS_COUNT</span><span class="p">);</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">11</span>
<span class="ln">12</span>        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">13</span>
<span class="ln">14</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="ln">15</span>
<span class="ln">16</span>            <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">hidx</span><span class="o">=</span><span class="n">hsegs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span> <span class="n">hidx</span><span class="o">&lt;</span><span class="n">hsegs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span> <span class="n">hidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">17</span>
<span class="ln">18</span>                <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">hnum</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">hnum</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">hnum</span><span class="o">++</span><span class="p">){</span>
<span class="ln">19</span>                    <span class="n">corpus_token_t</span> <span class="n">tok</span> <span class="o">=</span> <span class="n">htabs</span><span class="p">[</span><span class="n">hnum</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">];</span>
<span class="ln">20</span>                    <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">insert_token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln">21</span>                <span class="p">}</span>
<span class="ln">22</span>            <span class="p">}</span>
<span class="ln">23</span>            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">24</span>        <span class="p">}</span>
<span class="ln">25</span>
<span class="ln">26</span>    <span class="p">}</span>
<span class="ln">27</span>
<span class="ln">28</span>    <span class="n">wait_for_child_processes</span><span class="p">();</span>
<span class="ln">29</span>
<span class="ln">30</span>    <span class="n">free</span><span class="p">(</span><span class="n">hsegs</span><span class="p">);</span>
<span class="ln">31</span>    
<span class="ln">32</span>    <span class="k">return</span> <span class="n">htab</span><span class="p">;</span>
<span class="ln">33</span><span class="p">}</span>
</code></pre></div><p>Done. I&rsquo;m putting the pieces together and am dying to see the result. How long will my first method for creating the dictionary via parallel processing take? I run the algorithm on my computer using all of its 12 virtual cores.</p>
<p>Yippee! 111 seconds. Wow! That&rsquo;s about 6 times faster than the single process C program and about 11 times faster than the second Python script. My wait time for creating a Wikipedia dictionary got slashed from 57 minutes to 23 minutes, to 13 minutes, to now less than 2 minutes. <em>Performance</em> &hellip; check. What about <em>scalability</em>? I continue and deploy my code on the 2 Azure cloud servers.</p>
<p>Nope. Lesson #1 in the limitations of multiprocessing. The VM64 reaches its peak performance at 32 processes with an execution time of 50 seconds. Adding more cores, either in the VM64 or in the VM128, does <em>not</em> yield better performance. At some point, the cost of managing memory gobbles up all benefits of multiprocessing. Scalability &hellip; X, beep.</p>
<table>
  <tr>
    <td>Multiprocessing with separate hashes</td>
    <td colspan="3" align="Center">MacMini</td>
    <td colspan="4" align="Center">VM64</td>
    <td colspan="3" align="Center">VM128</td>
  </tr>
  <tr>
    <td>Number of processes</td>
    <td align="right">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right">12</td>
    <td align="right">16</td>
    <td align="right" style="background:green;color:white">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right">128</td>
  </tr>
  <tr>
    <td>Processing time in seconds</td>
    <td align="right">314</td>
    <td align="right">126</td>
    <td align="right">111</td>
    <td align="right">73</td>
    <td align="right">62</td>
    <td align="right" style="background:green;color:white">50</td>
    <td align="right">68</td>
    <td align="right">72</td>
    <td align="right">97</td>
    <td align="right">121</td>
  </tr>
</table>
<p>And off to round two.</p>
<h4 id="2-multiprocessing-with-semaphores-for-memory-synchronization">2. Multiprocessing with semaphores for memory synchronization</h4>
<p>Next, I want to test using memory synchronization which should help to address the memory problem associated with the previous method. My first option for memory synchronization are <a href="https://en.wikipedia.org/wiki/Semaphore_%28programming%29">semaphores</a>.</p>
<p><em>Semaphores</em> are numeric registers that allow processes to make <em>atomic</em> operations. <em>Atomic</em> in this context means that an operation is guaranteed to be completed <em>in one piece</em> without interference from any other process. You can set a <em>semaphore</em> to a certain value, normally by incrementing or decrementing, and the operating system will ensure that only 1 process can access a defined resource, e.g. a memory address, at the same time.</p>
<p>Hhmmm&hellip; I&rsquo;ve played <a href="/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/">with semaphores before</a> and don&rsquo;t hold them dearly. Let&rsquo;s see. I want to give it a shot. To implement this technique I need to make only 2 changes: create and initialize one semaphore per hash table bucket, and lock (unlock) the respective semaphore before (after) I access the hash table.</p>
<h5 id="create-and-initialize-one-semaphore-per-hash-table-bucket">Create and initialize one semaphore per hash table bucket</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="cp">#define SEMAPHORES_PER_SET 10000
</span><span class="ln"> 2</span><span class="cp"></span>
<span class="ln"> 3</span><span class="kt">int</span> <span class="o">*</span><span class="nf">create_semaphore_sets</span><span class="p">(){</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="kt">int</span> <span class="n">semset_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">semset_count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="ln"> 8</span>    
<span class="ln"> 9</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln">10</span>        <span class="k">if</span> <span class="p">((</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">semget</span><span class="p">(</span><span class="n">IPC_PRIVATE</span><span class="p">,</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">,</span> <span class="mo">0666</span> <span class="o">|</span> <span class="n">IPC_CREAT</span><span class="p">))</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semget&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">11</span>    
<span class="ln">12</span>    
<span class="ln">13</span>    <span class="c1">// reset all counters and semaphores
</span><span class="ln">14</span><span class="c1"></span>    <span class="n">semun_t</span> <span class="n">semun</span> <span class="o">=</span> <span class="p">{.</span><span class="n">val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">};</span> <span class="c1">// initial semaphore value =&gt; 1 = released
</span><span class="ln">15</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">setid</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">setid</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">setid</span><span class="o">++</span><span class="p">)</span>
<span class="ln">16</span>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">semid</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">semid</span><span class="o">&lt;</span><span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span> <span class="n">semid</span><span class="o">++</span><span class="p">)</span>
<span class="ln">17</span>            <span class="k">if</span><span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="n">semid</span><span class="p">,</span> <span class="n">SETVAL</span><span class="p">,</span> <span class="n">semun</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;semctl init for set %d sem %d: error %d </span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span><span class="n">setid</span><span class="p">,</span> <span class="n">semid</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">18</span>
<span class="ln">19</span>    <span class="k">return</span> <span class="n">semset_ids</span><span class="p">;</span>
<span class="ln">20</span><span class="p">}</span>
<span class="ln">21</span>
<span class="ln">22</span><span class="kt">void</span> <span class="nf">remove_semaphore_sets</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">){</span>
<span class="ln">23</span>    
<span class="ln">24</span>    <span class="kt">int</span> <span class="n">semset_count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="ln">25</span>    
<span class="ln">26</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">semset_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln">27</span>        <span class="k">if</span> <span class="p">(</span><span class="n">semctl</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">IPC_RMID</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semctl remove&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">28</span>    
<span class="ln">29</span><span class="p">}</span>
</code></pre></div><h5 id="lock-and-unlock-the-semaphore-before-and-after-access">Lock and unlock the semaphore before and after access</h5>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">lock_semaphore</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">hidx</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="kt">int</span> <span class="n">setid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hidx</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">);</span>
<span class="ln"> 4</span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">hidx</span> <span class="o">%</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">semid</span><span class="p">;</span>
<span class="ln"> 8</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln"> 9</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="c1">// lock token
</span><span class="ln">10</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semop&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">11</span><span class="p">}</span>
<span class="ln">12</span>
<span class="ln">13</span><span class="kt">void</span> <span class="nf">unlock_semaphore</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">semset_ids</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">hidx</span><span class="p">){</span>
<span class="ln">14</span>    
<span class="ln">15</span>    <span class="kt">int</span> <span class="n">setid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">hidx</span> <span class="o">/</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">);</span>
<span class="ln">16</span>    <span class="kt">int</span> <span class="n">semid</span> <span class="o">=</span> <span class="n">hidx</span> <span class="o">%</span> <span class="n">SEMAPHORES_PER_SET</span><span class="p">;</span>
<span class="ln">17</span>
<span class="ln">18</span>    <span class="k">struct</span> <span class="n">sembuf</span> <span class="n">sb</span><span class="p">;</span>
<span class="ln">19</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_num</span> <span class="o">=</span> <span class="n">semid</span><span class="p">;</span>
<span class="ln">20</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_flg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="ln">21</span>    <span class="n">sb</span><span class="p">.</span><span class="n">sem_op</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// unlock token
</span><span class="ln">22</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">semop</span><span class="p">(</span><span class="n">semset_ids</span><span class="p">[</span><span class="n">setid</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;semop&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">23</span><span class="p">}</span>
</code></pre></div><p>With so many semaphores, I need to assign each semaphore to serve a particular token or hash table bucket. I use the token&rsquo;s hash index <code>hidx</code> to do so. But, for the design to work, I will require about 30-40 million semaphores in total.</p>
<p>In most operating systems, however, there is a limit to the number of semaphores. I&rsquo;m starting to wonder whether semaphores are the right tool for the job. While in Linux I can change the limit by editing:</p>
<div class="highlight"><pre class="chroma"><code class="language-fallback" data-lang="fallback"><span class="ln">1</span>/proc/sys/kernel/sem
</code></pre></div><p>I wasn&rsquo;t able to increase the limit high enough on my Mac to process the full corpus. Therefore, I proceed with testing this method on the Azure servers only. The result is devastating.</p>
<p>Slow as molasses, the semaphores keep crawling for 12,833 and 14,398 seconds to process the full English Wikipedia dump with 32 and 64 cores respectively. That&rsquo;s almost 4 hours compared to less than 1 minute using the previous method. OMG. What an epic fail. Or, to be fair, just the wrong tool for the job. Locking and unlocking a semaphore requires making a low-level operating system call each time which simply does not scale.</p>
<table>
  <tr>
    <td>Multiprocessing with semaphores</td>
    <td colspan="6" align="Center">VM64</td>
    <td colspan="4" align="Center">VM128</td>
  </tr>
  <tr>
    <td>Number of processes</td>
    <td align="right" style="background:green;color:white">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right">16</td>
    <td align="right">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right">128</td>
  </tr>
  <tr>
    <td>Processing time in seconds</td>
    <td align="right" style="background:green;color:white"> 3,762</td>
    <td align="right"> 3,866</td>
    <td align="right"> 3,987</td>
    <td align="right"> 4,127</td>
    <td align="right">12,833</td>
    <td align="right">14,398</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
  </tr>
  <tr>
    <td colspan="10"><sup>* I did not complete the testing for semaphores on the VM128 due to an increasingly slow performance with higher process count.</sup></td>
  </tr>
</table>
<blockquote>
<p>One of the reasons <em>semaphores</em> are rather slow is that they work across processes. You could communicate between entirely different programs on the same machine which goes beyond what I need here.</p>
</blockquote>
<h4 id="3-multithreading-with-mutexes-for-memory-synchronization">3. Multithreading with mutexes for memory synchronization</h4>
<p>Round 3. <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">Mutexes</a> are binary, process-specific registers that can be used to control access to a resource and support <em>atomic</em> operations in a multitask environment. Their usage is straight forward and the program design resembles what I&rsquo;ve done above for <em>semaphores</em>. With one important difference. <em>Mutexes</em> do not work <em>across</em> processes but only <em>within</em> a single process.</p>
<p>Therefore, I switch from <em>multiprocessing</em> to <em>multithreading</em> and make the following 4 changes to the code: introduce a &lsquo;thread object&rsquo;, create and initialize one mutex per hash table bucket, define a start function for each thread, and lock (unlock) each mutex before (after) accessing the respective token.</p>
<h5 id="introduce-a-new-thread-object">Introduce a new &lsquo;thread object&rsquo;</h5>
<p>One of the differences between using <code>pthread</code>s and <code>fork</code> is that when you send off a new thread you can only give it a <em>single</em> variable, or pointer, for the journey. Therefore, I create a <em>payload</em> object <code>corpus_thread_t</code>  which references all the variables each thread commands for its work.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">corpus_thread_t</span><span class="p">{</span>
<span class="ln">2</span>    <span class="kt">char</span>            <span class="o">*</span><span class="n">corpus</span><span class="p">;</span>        <span class="c1">// reference to corpus
</span><span class="ln">3</span><span class="c1"></span>    <span class="n">size_t</span>          <span class="n">from_off</span><span class="p">;</span>       <span class="c1">// reference to hash table
</span><span class="ln">4</span><span class="c1"></span>    <span class="n">size_t</span>          <span class="n">to_off</span><span class="p">;</span>         <span class="c1">// reference to mutexes array
</span><span class="ln">5</span><span class="c1"></span>    <span class="n">corpus_token_t</span>  <span class="o">*</span><span class="n">htab</span><span class="p">;</span>          <span class="c1">// reference to corpus segment start
</span><span class="ln">6</span><span class="c1"></span>    <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span><span class="p">;</span>          <span class="c1">// reference to corpus segment end
</span><span class="ln">7</span><span class="c1"></span><span class="p">}</span> <span class="n">corpus_thread_t</span><span class="p">;</span>
</code></pre></div><p>Before I can inject the payload into the start function of a thread I need to initialize it with all the required values:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">corpus_thread_t</span> <span class="o">*</span><span class="nf">create_corpus_threads</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">corpus_thread_t</span> <span class="o">*</span><span class="n">cts</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">PROCESS_COUNT</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_thread_t</span><span class="p">));</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 6</span>        
<span class="ln"> 7</span>        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">corpus</span>    <span class="o">=</span> <span class="n">corpus</span><span class="p">;</span>                  
<span class="ln"> 8</span>        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">htab</span>      <span class="o">=</span> <span class="n">htab</span><span class="p">;</span>                    
<span class="ln"> 9</span>        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mtxs</span>      <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>                    
<span class="ln">10</span>        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from_off</span>  <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>       
<span class="ln">11</span>        <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to_off</span>    <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>         
<span class="ln">12</span>    <span class="p">}</span>
<span class="ln">13</span>    
<span class="ln">14</span>    <span class="k">return</span> <span class="n">cts</span><span class="p">;</span>
<span class="ln">15</span><span class="p">}</span>
</code></pre></div><p>Ok. Each thread now receives an individualized <code>corpus_thread_t</code> payload object as a single variable. Only the <em>mutexes</em> are still missing. I add those in the next step.</p>
<h5 id="create-and-initialize-one-mutex-per-hash-table-bucket">Create and initialize one mutex per hash table bucket</h5>
<p>My design prescribes one <em>mutex</em> per hash table bucket. Fortunately, C offers a built-in <code>pthread_mutex_t</code> object so I do not need to dream up my own. I just create an array of these mutex objects matching the size of the hash table. Before I wave them off with <code>pthread_create</code> I quickly toss in the missing reference to the mutexes.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">process_corpus_multithreading</span><span class="p">(</span><span class="n">corpus_thread_t</span> <span class="o">*</span><span class="n">cts</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">MAX_HASH_LENGTH</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="p">));</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">MAX_HASH_LENGTH</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">pthread_mutex_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="n">pthread_t</span> <span class="n">threads</span><span class="p">[</span><span class="n">PROCESS_COUNT</span><span class="p">];</span>
<span class="ln"> 8</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 9</span>
<span class="ln">10</span>        <span class="c1">// add the mutexes pointer into the thread objects
</span><span class="ln">11</span><span class="c1"></span>        <span class="n">cts</span><span class="p">[</span><span class="n">t</span><span class="p">].</span><span class="n">mtxs</span> <span class="o">=</span> <span class="n">mtxs</span><span class="p">;</span>
<span class="ln">12</span>        
<span class="ln">13</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threads</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">process_corpus_pt</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cts</span><span class="p">[</span><span class="n">t</span><span class="p">]))</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;pthread_create&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">14</span>
<span class="ln">15</span>    <span class="p">}</span>
<span class="ln">16</span>    
<span class="ln">17</span>    <span class="c1">// wait for threads to exit
</span><span class="ln">18</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">t</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="n">pthread_join</span><span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">t</span><span class="p">],</span><span class="nb">NULL</span><span class="p">);</span>
<span class="ln">19</span>
<span class="ln">20</span>    <span class="c1">// remove the mutexes pointers
</span><span class="ln">21</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">cts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">mtxs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="ln">22</span>    <span class="n">free</span><span class="p">(</span><span class="n">mtxs</span><span class="p">);</span>
<span class="ln">23</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>Beware two differences of <em>multithreading</em> to <em>multiprocessing</em>: first, the hash table variable does not need to be a <code>mmap</code> shared memory. A simple <code>malloc</code> suffices since all threads share the same global memory space. Second, the parent process does not <code>wait</code> for a thread to finish but needs to <em>join</em> the thread. If you don&rsquo;t <code>pthread_join</code> threads at the end you may get unpredictable results.</p>
</blockquote>
<h5 id="define-a-start-function-for-each-thread">Define a start function for each thread</h5>
<p>Each thread requires a start function. If you reviewed the above code you will have noticed that it references a function <code>process_corpus_pt</code> and passes the payload <code>corpus_thread_t</code> struct in the form of <code>cts[t]</code> to it. This is what my start function looks like:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="o">*</span><span class="nf">process_corpus_pt</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="c1">// thread index
</span><span class="ln"> 4</span><span class="c1"></span>    <span class="n">corpus_thread_t</span> <span class="n">ct</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">corpus_thread_t</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
<span class="ln"> 5</span>
<span class="ln"> 6</span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="n">size_t</span> <span class="n">str_pos</span> <span class="o">=</span> <span class="n">ct</span><span class="p">.</span><span class="n">from_off</span><span class="p">;</span>
<span class="ln"> 8</span>    <span class="n">size_t</span> <span class="n">str_end</span> <span class="o">=</span> <span class="n">ct</span><span class="p">.</span><span class="n">to_off</span><span class="p">;</span>
<span class="ln"> 9</span>
<span class="ln">10</span>    <span class="k">while</span><span class="p">(</span><span class="n">str_pos</span> <span class="o">&lt;</span> <span class="n">str_end</span><span class="p">){</span>
<span class="ln">11</span>        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">ct</span><span class="p">.</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str_pos</span><span class="p">,</span> <span class="n">str_end</span><span class="p">);</span>
<span class="ln">12</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="n">insert_token_mt</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tok</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">htab</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">corpus</span><span class="p">,</span> <span class="n">ct</span><span class="p">.</span><span class="n">mtxs</span><span class="p">);</span>       
<span class="ln">13</span>    <span class="p">}</span>
<span class="ln">14</span>    <span class="n">pthread_exit</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>   
<span class="ln">15</span><span class="p">}</span>
</code></pre></div><p>I reference a new <code>insert_token_mt</code> function because the locking and unlocking for threads during a hash table insert work differently.</p>
<h5 id="lock-and-unlock-the-mutex-before-and-after-token-access">Lock and unlock the mutex before and after token access</h5>
<p>The <code>pthread</code> library generously offers a <em>lock</em> and <em>unlock</em> function. Awesome. Thank you. I simply add the locking and unlocking into the thread-specific <code>insert_token_mt</code> function.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">insert_token_mt</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mtxs</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">size_t</span> <span class="n">hidx</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="ln"> 6</span>
<span class="ln"> 7</span>        <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>        <span class="c1">// check if this bucket is empty
</span><span class="ln">10</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">len</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">11</span>            
<span class="ln">12</span>            <span class="c1">// if the same token already exists in the hash table increment its counter
</span><span class="ln">13</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">compare_corpus_tokens</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="o">+</span><span class="n">hidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">14</span>                <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">].</span><span class="n">count</span> <span class="o">+=</span> <span class="n">tok</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
<span class="ln">15</span>                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
<span class="ln">16</span>                <span class="k">return</span><span class="p">;</span>
<span class="ln">17</span>                
<span class="ln">18</span>            <span class="p">}</span>
<span class="ln">19</span>            <span class="c1">// otherwise move forward to the next bucket
</span><span class="ln">20</span><span class="c1"></span>            <span class="k">else</span> <span class="p">{</span>
<span class="ln">21</span>                <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
<span class="ln">22</span>                <span class="n">hidx</span><span class="o">++</span><span class="p">;</span>
<span class="ln">23</span>                <span class="n">hidx</span> <span class="o">%=</span> <span class="n">MAX_HASH_LENGTH</span><span class="p">;</span>
<span class="ln">24</span>            <span class="p">}</span>
<span class="ln">25</span>            
<span class="ln">26</span>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="ln">27</span>            <span class="c1">// if this token&#39;s bucket was empty (i.e. first time) add it into the hash table
</span><span class="ln">28</span><span class="c1"></span>            <span class="n">htab</span><span class="p">[</span><span class="n">hidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">29</span>            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mtxs</span><span class="p">[</span><span class="n">pidx</span> <span class="o">*</span> <span class="n">MAX_HASH_LENGTH</span> <span class="o">+</span> <span class="n">hidx</span><span class="p">]);</span>
<span class="ln">30</span>            <span class="k">return</span><span class="p">;</span>
<span class="ln">31</span>        <span class="p">}</span>   
<span class="ln">32</span>    <span class="p">}</span>   
<span class="ln">33</span><span class="p">}</span>
</code></pre></div><p>Voila. Contender #3 is entering the ring. I can hardly sit tight. Will mutexes knock-out semaphores? Well, that&rsquo;s not really the question, I hope. Running a BASIC script on a 286 can do that.</p>
<p>Yup. I&rsquo;m happy with what I see. Creating the dictionary for the English Wikipedia dump takes only 122 seconds running 12 threads on my Mac Mini. That&rsquo;s the second bests result so far. It&rsquo;s a notch slower than the multiple hash tables method but consumes by far less memory. Nice. But how does it scale?</p>
<p>It doesn&rsquo;t. Again. When I test this option on the cloud servers I find mutexes scale well to about 16 threads. At this point, performance hits a ceiling, and adding threads slows things down. Hmm. That&rsquo;s unexpected. The overhead for locking and unlocking, plus the wait time if more than one thread wants to access the same token, eat up all the time gained from parallel processing.</p>
<table>
  <tr>
    <td>Multithreading with mutexes</td>
    <td colspan="3" align="Center">MacMini</td>
    <td colspan="4" align="Center">VM64</td>
    <td colspan="3" align="Center">VM128</td>
  </tr>
  <tr>
    <td>Number of threads</td>
    <td align="right">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right">12</td>
    <td align="right" style="background:green;color:white">16</td>
    <td align="right">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right">128</td>
  </tr>
  <tr>
    <td>Processing time in seconds</td>
    <td align="right">346</td>
    <td align="right">145</td>
    <td align="right">122</td>
    <td align="right">119</td>
    <td align="right" style="background:green;color:white">118</td>
    <td align="right">138</td>
    <td align="right">159</td>
    <td align="right">204</td>
    <td align="right">227</td>
    <td align="right">246</td>
  </tr>
</table>
<h4 id="4-multiprocessing-with-pipes-for-ipc">4. Multiprocessing with pipes for IPC</h4>
<p>This leaves me with one last candidate to assess: <a href="http://www.gnu.org/software/libc/manual/html_node/Pipes-and-FIFOs.html">pipes</a>. Instead of communicating with each other by accessing the same memory, different processes send information in the form of messages to each other.</p>
<blockquote>
<p>The interesting aspect of this messaging-based approach is that it should be scalable not only across multiple processes on the <em>same</em> machine, but also across <em>multiple machines</em>, if <em>pipes</em>, for example, were replaced by <em>sockets</em>.</p>
</blockquote>
<h5 id="messaging-based-design">Messaging-based design</h5>
<p>All 3 previous methods shared a similar design. Each process, or thread, works on a different segment of the corpus, reading <em><strong>and</strong></em> writing tokens. A messaging-based method must be designed differently. I will have 2 types of processes: one that <em>reads</em>, and one that <em>writes</em>. Tokens are sent as small messages via a <em>pipe</em> from a <em>corpus-reading-process</em> to a <em>hash-table-writing-process</em>.</p>
<h5 id="asynchronous-inter-process-communication">Asynchronous inter process communication</h5>
<p>One advantage of <em>pipes</em> is that they work fully <em>asynchronous</em>. The sender&rsquo;s rate of <em>writing</em> into the pipe is not limited by the recipient&rsquo;s rate of <em>reading</em> from the <em>pipe</em>. The <em>pipe</em> serves as a buffer and never loses a message. Huh. I can have different designs where there are either more senders or more receivers, depending on where I suspect a bottleneck. I could, for example, have only 4 processes that read the corpus (because I suspect this to be faster) and have 8 processes create the dictionary (because I suspect this to be slower). But how many <em>pipes</em> would I need in this case?</p>
<p>To avoid overlaps between processes I split the hash table into multiple segments and assign each hash-table-writing-process to one particular segment. Each process only receives the tokens that fit into its respective hash table segment. Therefore, the number of pipes should match the number of processes that write to the hash table &ndash; which are the processes that <em>read</em> from the pipe BTW.</p>
<blockquote>
<p>Be careful with the terms <em>read</em> and <em>write</em> in this context. <em>Reading</em> from the corpus means <em>writing</em> into the pipe. <em>Reading</em> from the pipe means <em>writing</em> into the hash table.</p>
</blockquote>
<p>The processes that read the corpus know which pipe to send a token into by determining its hash segment via a reverse lookup. The following diagram summarizes this design &ndash; using an example of 4 processes that read the corpus, and 8 processes that write into the hash table.</p>
<p><img src="/images/pipes_ipc_design_diagram.png" alt="TEXT2DICT: Inter process communication via pipes"></p>
<p>Alright. Done the design, moving on to implementation. I add the following 4 functions to the code: create pipes, open and close pipes, send a token into a pipe, and read a token from a pipe.</p>
<h5 id="create-pipes">Create pipes</h5>
<p>A <em>pipe</em> is defined as an array of 2 integers. The 2 integers represent the 2 &ldquo;<em>channels</em>&rdquo; of the <em>pipe</em>. The 1st channel is for messages to <em><strong>come in</strong></em>, and the 2nd channel is for messages to <em><strong>go out</strong></em>. When the sender and receiver exchange information unidirectional, which is normally the case, I need only <em><strong>one</strong></em> of the channels and must close the other. I&rsquo;ll come back to that later.</p>
<p>For coding convenience, I define <em>pipes</em> via below <code>typedef</code> which helps to access the <em>incoming</em> and <em>outgoing</em> channel of the <em>pipe</em> via a <code>.in</code> and <code>.out</code> attribute. I feel this keeps the code easier to read and avoids the usage of multi-dimensional arrays.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">pipe_arr_t</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="ln">2</span>
<span class="ln">3</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">pipe_t</span><span class="p">{</span>
<span class="ln">4</span>    <span class="kt">int</span> <span class="n">in</span><span class="p">;</span>     <span class="c1">// incoming
</span><span class="ln">5</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">out</span><span class="p">;</span>    <span class="c1">// outgoing
</span><span class="ln">6</span><span class="c1"></span><span class="p">}</span> <span class="n">pipe_t</span><span class="p">;</span>
</code></pre></div><p>The downside of this <code>typedef</code>fing is an ugly <em>cast</em> for creating the pipes:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="n">pipe_t</span> <span class="o">*</span><span class="nf">create_pipes</span><span class="p">(</span><span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="c1">// check that 80% capacity of the file descriptor limit is still available
</span><span class="ln"> 4</span><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">npipes</span><span class="o">&gt;</span><span class="n">MAX_FILE_DESCRIPTORS</span><span class="o">*</span><span class="mf">0.8</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Max limit for file descriptors is not sufficient. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln"> 5</span>    
<span class="ln"> 6</span>    <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">npipes</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pipe_t</span><span class="p">));</span>
<span class="ln"> 7</span>    
<span class="ln"> 8</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln"> 9</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">pipe_arr_t</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when creating pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">10</span>    
<span class="ln">11</span>    <span class="k">return</span> <span class="n">pipes</span><span class="p">;</span>   
<span class="ln">12</span><span class="p">}</span>
</code></pre></div><h1 id="heading-1"></h1>
<h5 id="open-and-close-pipes">Open and close pipes</h5>
<p>After the pipes have been created and <code>fork</code>ed, each process carries a copy of all pipes. The key to the usage of pipes is that <em><strong>all</strong></em> pipe copies need to be closed properly for the pipe to work. And for each pipe copy, each channel (the incoming and the outgoing) must be closed <em><strong>separately</strong></em>. Not closing all pipes' in- and out-channels is a frequent source of errors.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln">1</span><span class="kt">void</span> <span class="nf">close_pipes_in</span><span class="p">(</span><span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>
<span class="ln">2</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln">3</span>        <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">in</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when closing &#39;in&#39; pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">4</span><span class="p">}</span>
<span class="ln">5</span>
<span class="ln">6</span><span class="kt">void</span> <span class="nf">close_pipes_out</span><span class="p">(</span><span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">,</span> <span class="kt">long</span> <span class="n">npipes</span><span class="p">){</span>   
<span class="ln">7</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">npipes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="ln">8</span>        <span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error when closing &#39;in&#39; pipes. ABORT</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">9</span><span class="p">}</span>
</code></pre></div><h1 id="heading-2"></h1>
<h5 id="send-a-token-into-a-pipe">Send a token into a pipe</h5>
<p>When I <em>send</em> tokens into the pipe, I need to use the <em>out</em> channel. That&rsquo;s obvious. What&rsquo;s less obvious though is that, and I know I&rsquo;m repeating myself here, I should therefore <em><strong>close</strong></em> the <em>in</em> channel right away. Below function shows how this looks like:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">read_corpus_and_send_tokens_into_pipe_mp</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">close_pipes_in</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="n">size_t</span> <span class="n">str_pos</span> <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
<span class="ln"> 6</span>    <span class="n">size_t</span> <span class="n">str_end</span> <span class="o">=</span> <span class="n">corp_segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
<span class="ln"> 7</span>
<span class="ln"> 8</span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln"> 9</span>    <span class="k">while</span><span class="p">(</span><span class="n">str_pos</span> <span class="o">&lt;</span> <span class="n">str_end</span><span class="p">){</span>
<span class="ln">10</span>        <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">str_pos</span><span class="p">,</span> <span class="n">str_end</span><span class="p">);</span>
<span class="ln">11</span>        
<span class="ln">12</span>        <span class="k">if</span> <span class="p">(</span><span class="n">tok</span><span class="p">.</span><span class="n">len</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="ln">13</span>
<span class="ln">14</span>            <span class="c1">// find the index of the pipe/hash-segment that should be used for this token
</span><span class="ln">15</span><span class="c1"></span>            <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">get_token_hash</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln">16</span>            <span class="kt">long</span> <span class="n">seg_idx</span> <span class="o">=</span> <span class="n">get_segment_index</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">MAX_HASH_LENGTH</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">17</span>
<span class="ln">18</span>            <span class="c1">// send the token into the selected pipe
</span><span class="ln">19</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">out</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">corpus_token_t</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Error sending token into the pipe!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
<span class="ln">20</span>        <span class="p">}</span>
<span class="ln">21</span>    <span class="p">}</span>
<span class="ln">22</span>    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">23</span><span class="p">}</span>
</code></pre></div><h1 id="heading-3"></h1>
<h5 id="read-a-token-from-a-pipe">Read a token from a pipe</h5>
<p>Reading the pipe is straight forward. I simply loop a <code>read</code> function scanning the <em>in</em> channel until the other end of the pipe gets closed.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">read_pipe_and_write_tokens_into_htab</span><span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span><span class="p">){</span>
<span class="ln"> 2</span>
<span class="ln"> 3</span>    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln"> 4</span>
<span class="ln"> 5</span>    <span class="c1">// read the pipe of this process until all sending is closed
</span><span class="ln"> 6</span><span class="c1"></span>    <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln"> 7</span>    <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">pipes</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">in</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tok</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tok</span><span class="p">)))</span> <span class="n">insert_token</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="n">close_pipes_in</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">10</span><span class="p">}</span>
</code></pre></div><p>And again, I must close the unused channel, in this case, the <em>out</em> channel, in the beginning of the function. Similarly, at the end of the function, I need to close all <em>in</em> channels as well, since they are not used anymore. (Ok. I&rsquo;m not mentioning closing pipes anymore.)</p>
<p>That&rsquo;s it. All that&rsquo;s left is to add these 2 functions into a <em>multiprocessing</em> loop. I call the respective function <code>process_corpus_pipes</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span>
<span class="ln"> 2</span><span class="n">PROCESS_COUNT_READ_CORPUS</span> <span class="o">=</span> <span class="n">PROCESS_COUNT</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">// half of the processes read the corpus
</span><span class="ln"> 3</span><span class="c1"></span><span class="n">PROCESS_COUNT_WRITE_HASH</span>  <span class="o">=</span> <span class="n">PROCESS_COUNT</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>  <span class="c1">// half of the processes write the hash table
</span><span class="ln"> 4</span><span class="c1"></span>
<span class="ln"> 5</span><span class="kt">void</span> <span class="nf">process_corpus_pipes</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">corp_segs</span><span class="p">,</span> <span class="n">corpus_token_t</span> <span class="o">*</span><span class="n">htab</span><span class="p">,</span> <span class="n">range_t</span> <span class="o">*</span><span class="n">htab_segs</span><span class="p">){</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="k">if</span> <span class="p">(</span><span class="n">PROCESS_COUNT</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="n">process_corpus_mp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span><span class="k">return</span><span class="p">;}</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>    <span class="n">pipe_t</span> <span class="o">*</span><span class="n">pipes</span> <span class="o">=</span> <span class="n">create_pipes</span><span class="p">(</span><span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">10</span>   
<span class="ln">11</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln">12</span>
<span class="ln">13</span>    <span class="c1">// Part 1 -- Kick-off the reading-corpus-processes
</span><span class="ln">14</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT_READ_CORPUS</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">15</span>
<span class="ln">16</span>        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">17</span>
<span class="ln">18</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="ln">19</span>            <span class="n">read_corpus_and_send_tokens_into_pipe_mp</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">corp_segs</span><span class="p">,</span> <span class="n">pipes</span><span class="p">);</span>
<span class="ln">20</span>            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">21</span>        <span class="p">}</span>
<span class="ln">22</span>    <span class="p">}</span>
<span class="ln">23</span>
<span class="ln">24</span>
<span class="ln">25</span>    <span class="c1">// Part 2 -- Kick-off the write-hash-processes
</span><span class="ln">26</span><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln">27</span>
<span class="ln">28</span>        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">29</span>
<span class="ln">30</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="ln">31</span>            <span class="n">read_pipe_and_write_tokens_into_htab</span><span class="p">(</span><span class="n">pidx</span><span class="p">,</span> <span class="n">corpus</span><span class="p">,</span> <span class="n">htab</span><span class="p">,</span> <span class="n">pipes</span><span class="p">);</span>
<span class="ln">32</span>            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">33</span>        <span class="p">}</span>
<span class="ln">34</span>    <span class="p">}</span>
<span class="ln">35</span>
<span class="ln">36</span>    <span class="c1">// close parent process pipes
</span><span class="ln">37</span><span class="c1"></span>    <span class="n">close_pipes_in</span> <span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">38</span>    <span class="n">close_pipes_out</span><span class="p">(</span><span class="n">pipes</span><span class="p">,</span> <span class="n">PROCESS_COUNT_WRITE_HASH</span><span class="p">);</span>
<span class="ln">39</span>
<span class="ln">40</span>    <span class="n">wait_for_child_processes</span><span class="p">();</span>
<span class="ln">41</span>    
<span class="ln">42</span>    <span class="n">free</span><span class="p">(</span><span class="n">pipes</span><span class="p">);</span>
<span class="ln">43</span><span class="p">}</span>
</code></pre></div><blockquote>
<p>Note that the <code>wait_for_child_processes()</code> occurs <em><strong>after</strong></em> closing the pipes. If the parent process does not also close all of its pipes the child processes won&rsquo;t exit. (Oops. Another &lsquo;closing pipes&rsquo;. I promise this is the last one.)</p>
</blockquote>
<p>Ok. Now let me run it and see how <em>multiprocessing with pipes</em> compares to the previous methods.</p>
<p>Ta-dah. As expected. Sending tokens as messages back and forth between processes is slower than accessing shared memory. Nevertheless, it&rsquo;s nothing to sneeze at. The pipes take &lsquo;only&rsquo; 1,704 seconds on my computer to create the dictionary which is a little longer than the second Python script. And what I cherish about this option is its decentralized, messaging-based architecture. How about processing a text across multiple machines via a distributed system? Sounds like another enthralling project to come.</p>
<p>Here&rsquo;s a summary of the <em>pipes</em> testing:</p>
<table>
  <tr>
    <td>Multiprocessing with pipes for IPC</td>
    <td colspan="3" align="Center">MacMini</td>
    <td colspan="4" align="Center">VM64</td>
    <td colspan="3" align="Center">VM128</td>
  </tr>
  <tr>
    <td>Number of processes</td>
    <td align="right">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right" style="background:green;color:white">12</td>
    <td align="right">16</td>
    <td align="right">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right">128</td>
  </tr>
  <tr>
    <td>Processing time in seconds</td>
    <td align="right">2,903</td>
    <td align="right">2,363</td>
    <td align="right">1.704</td>
    <td align="right" style="background:green;color:white">  958</td>
    <td align="right">1,636</td>
    <td align="right">4,500</td>
    <td align="right">10,229</td>
    <td align="right">13,637</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
  </tr>
  <tr>
    <td colspan="11"><sup>* I did not test pipes with more than 64 cores on the VM128 since performance clearly deteriorated rapidly with a higher process count.</sup></td>
  </tr>  
</table>
<p>Huh&hellip; almost done. I finished my testing of 4 methods of parallel processing: 2 of them performed splendidly (mutexes and multiple hashes), 1 of them reasonably well (pipes) and 1 of them fell flat (semaphores). Yet, <em>none</em> of them scaled. I had expected that for at least one of the methods adding cores would always further increase performance. Obviously, this is not the case. The overhead of managing and coordinating multiple processes, be it memory management, locking and unlocking registers, or sending and receiving messages, eventually outweighs the benefits of parallel processing.</p>
<p>Hmmm.. wait. This leaves one question open. If it&rsquo;s the overhead that&rsquo;s preventing the scaling, and the overhead only exists because of our task of creating a dictionary, then how about if I simply <em>read</em> the corpus. No deduplication, no hash table, just read the text, word by word.</p>
<h3 id="last-but-not-least-just-read">Last but not least: just read</h3>
<p>Before I conclude my testing I&rsquo;m adding another option, just for fun. And curiosity. I want to confirm whether multiprocessing or multithreading can scale <em>at all</em>. Is running multiple processes or threads burdened with inherent overhead? If I simply <em>read</em> the Wikipedia text, <em><strong>without</strong></em> deduplicating tokens and creating a dictionary, will performance consistently improve all the way to 128 cores?</p>
<p>Before I conclude my adventure, I thus create a simple function <code>process_corpus_reading_only</code> and test it on all 3 machines.</p>
<div class="highlight"><pre class="chroma"><code class="language-c" data-lang="c"><span class="ln"> 1</span><span class="kt">void</span> <span class="nf">process_corpus_reading_only</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">corpus</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">corpus_fsize</span><span class="p">){</span>
<span class="ln"> 2</span>    
<span class="ln"> 3</span>    <span class="n">range_t</span> <span class="o">*</span><span class="n">segs</span> <span class="o">=</span> <span class="n">create_corpus_segments</span><span class="p">(</span><span class="n">corpus_fsize</span><span class="p">,</span> <span class="n">PROCESS_COUNT</span><span class="p">,</span> <span class="n">corpus</span><span class="p">);</span>
<span class="ln"> 4</span>    
<span class="ln"> 5</span>    <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>
<span class="ln"> 6</span>    
<span class="ln"> 7</span>    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">pidx</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">pidx</span><span class="o">&lt;</span><span class="n">PROCESS_COUNT</span><span class="p">;</span> <span class="n">pidx</span><span class="o">++</span><span class="p">){</span>
<span class="ln"> 8</span>
<span class="ln"> 9</span>        <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="n">perror</span><span class="p">(</span><span class="s">&#34;fork&#34;</span><span class="p">);</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);}</span>
<span class="ln">10</span>
<span class="ln">11</span>        <span class="k">if</span> <span class="p">(</span><span class="n">pid</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
<span class="ln">12</span>
<span class="ln">13</span>            <span class="n">size_t</span> <span class="n">pos</span> <span class="o">=</span><span class="n">segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">from</span><span class="p">;</span>
<span class="ln">14</span>            <span class="n">size_t</span> <span class="n">end</span> <span class="o">=</span><span class="n">segs</span><span class="p">[</span><span class="n">pidx</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
<span class="ln">15</span>
<span class="ln">16</span>            <span class="n">corpus_token_t</span> <span class="n">tok</span><span class="p">;</span>
<span class="ln">17</span>            <span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
<span class="ln">18</span>                <span class="n">tok</span> <span class="o">=</span> <span class="n">get_next_token</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="ln">19</span>            <span class="p">}</span>
<span class="ln">20</span>            <span class="n">_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="ln">21</span>        <span class="p">}</span>
<span class="ln">22</span>    <span class="p">}</span>
<span class="ln">23</span>
<span class="ln">24</span>    <span class="n">wait_for_child_processes</span><span class="p">();</span>
<span class="ln">25</span>    <span class="n">free</span><span class="p">(</span><span class="n">segs</span><span class="p">);</span>
<span class="ln">26</span>    <span class="k">return</span><span class="p">;</span>
<span class="ln">27</span><span class="p">}</span>
</code></pre></div><p>Wow! Finally. 2 processes run faster than 6, which run faster than 12, which run faster than 32, etc. All the way to 128 processes which take a mere 6 seconds to read through the full 17 GB English Wikipedia corpus with approx. 2.8 billion words. That&rsquo;s a whopping 460 million words <em><strong>per second</strong></em>. To put this in perspective: if an average novel nowadays comprises 90,000 words, then <code>text2dict</code> is &lsquo;reading&rsquo; 5,000 books .. per second.</p>
<table>
  <tr>
    <td>Simply reading the corpus, without creating a dictionary</td>
    <td colspan="3" align="Center">MacMini</td>
    <td colspan="4" align="Center">VM64</td>
    <td colspan="3" align="Center">VM128</td>
  </tr>
  <tr>
    <td>Number of processes</td>
    <td align="right">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right">12</td>
    <td align="right">16</td>
    <td align="right">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right" style="background:green;color:white">128</td>
  </tr>
  <tr>
    <td>Processing time in seconds</td>
    <td align="right">175</td>
    <td align="right">63</td>
    <td align="right">60</td>
    <td align="right">31</td>
    <td align="right">22</td>
    <td align="right">12</td>
    <td align="right">9</td>
    <td align="right">8</td>
    <td align="right">7</td>
    <td align="right" style="background:green;color:white">6</td>
  </tr>
</table>
<p>At this point, I&rsquo;m wondering how long this would take on the VM416 that I didn&rsquo;t get to test on. With more than 3 times the number of cores than the VM128, could the VM416 reduce the processing time further &hellip; to 2 seconds?</p>
<p>Here is the summary of all of the above results, consolidated in one table:</p>
<table>
  <tr>
    <td>Processing time in seconds</td>
    <td colspan="3" align="Center">MacMini/VM64</td>
    <td colspan="4" align="Center">VM64</td>
    <td colspan="3" align="Center">VM128</td>
  </tr>
  <tr>
    <td># of processes / threads</td>
    <td align="right">2</td>
    <td align="right">6</td>
    <td align="right">12</td>
    <td align="right">12</td>
    <td align="right">16</td>
    <td align="right">32</td>
    <td align="right">64</td>
    <td align="right">64</td>
    <td align="right">96</td>
    <td align="right">128</td>
  </tr>
  <tr>
    <td>Semaphores<br/>&nbsp;</td>
    <td align="right" style="background:green;color:white"> 3,762</td>
    <td align="right"> 3,866</td>
    <td align="right"> 3,987</td>
    <td align="right"> 3,987</td>
    <td align="right"> 4,127</td>
    <td align="right">12,833</td>
    <td align="right">14,398</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
  </tr>
  <tr>
    <td>Pipes<br/>&nbsp;</td>
    <td align="right">2,903</td>
    <td align="right">2,363</td>
    <td align="right">1.704</td>
    <td align="right" style="background:green;color:white">  958</td>
    <td align="right">1,636</td>
    <td align="right">4,500</td>
    <td align="right">10,229</td>
    <td align="right">13,637</td>
    <td align="right">n/a*</td>
    <td align="right">n/a*</td>
  </tr>
  <tr>
    <td>Mutexes<br/>&nbsp;</td>
    <td align="right">346</td>
    <td align="right">145</td>
    <td align="right">122</td>
    <td align="right">119</td>
    <td align="right" style="background:green;color:white">118</td>
    <td align="right">138</td>
    <td align="right">159</td>
    <td align="right">204</td>
    <td align="right">227</td>
    <td align="right">246</td>
  </tr>
  <tr>
    <td>Multiples hashes<br/>&nbsp;</td>
    <td align="right">314</td>
    <td align="right">126</td>
    <td align="right">111</td>
    <td align="right">73</td>
    <td align="right">62</td>
    <td align="right" style="background:green;color:white">50</td>
    <td align="right">68</td>
    <td align="right">72</td>
    <td align="right">97</td>
    <td align="right">121</td>
  </tr>
 <tr>
    <td>Reading corpus</td>
    <td align="right">175</td>
    <td align="right">63</td>
    <td align="right">60</td>
    <td align="right">31</td>
    <td align="right">22</td>
    <td align="right">12</td>
    <td align="right">9</td>
    <td align="right">8</td>
    <td align="right">7</td>
    <td align="right" style="background:green;color:white">6</td>
  </tr>
  <tr>
    <td colspan="11"><sup>* I did not test semaphores and pipes on more than 64 cores since performance clearly deteriorated rapidly with a higher process count.</sup></td>
  </tr>
</table>
<h2 id="summary-and-conclusion">Summary and conclusion</h2>
<p>Given the simple task of creating a dictionary from the Wikipedia corpus, I detoured into insightful analysis and comparison of 4 different methods of parallel processing large text files. On this journey, I learned about the power and potential of multiprocessing and multithreading, but also its challenges and limitations.</p>
<p>Working with large data sources has become the norm. File sizes that developers and data scientists work on grow exponentially. And large is never large enough. While the usage of GPUs has become very popular through deep learning, the effective utilization of multiple CPUs to enhance processing performance is still lingering.</p>
<p>Bigger machines with more memory will hopefully enable and motivate more developers to embrace parallel processing. As I&rsquo;ve shown in this post, the challenge of handling <em>race conditions</em> can be addressed in different ways. And sometimes, the most effective one is simply &lsquo;throwing memory at the problem&rsquo;.</p>
<blockquote>
<h3 id="lessons-learned">Lessons learned</h3>
<p>These are some of the key technical lessons I learned from this exercise. Some of them expected, some other less so:</p>
<ul>
<li>Reading a file fully into memory is <em><strong>not</strong></em> faster than <code>mmap</code>. On the contrary, <code>mmap</code> performed consistently better, albeit only slightly.</li>
<li><em>Multiprocessing</em> and <em>multithreading</em> have roughly the same performance. On average, running multiple <em>processes</em> (i.e. using <code>fork</code>) was somewhat faster than running the same number of <em>threads</em>.</li>
<li>The <em>fastest</em> technique for addressing <em>race conditions</em> is to avoid them, e.g. by <em>throwing memory at the problem</em>.</li>
<li>The <em>most efficient</em> technique, in terms of memory usage <em>and</em> performance, is memory synchronization using <em>mutexes</em>.</li>
<li>Stay away from <em>semaphores</em>, at least for anything that requires usage on a large scale.</li>
<li><em><strong>None</strong></em> of the methods scales really well with multiple cores. Peak performance is reached around 32 cores and then gradually decreases.</li>
<li>What <em>does</em> scale is simply reading the corpus without <em>any</em> process coordination whatsoever. How far this can be scaled is to be explored on bigger machines.</li>
</ul>
</blockquote>
<h3 id="processing-other-wikipedia-languages">Processing other Wikipedia languages</h3>
<p>At last, I used the fastest technique to see how long the process of creating a dictionary and of simply <em>reading</em> the Wikipedia corpus takes for other languages than English. Here&rsquo;s a summary:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Wikipedia language</th>
<th style="text-align:left">token type</th>
<th style="text-align:right">file size</th>
<th style="text-align:right">tokens in corpus</th>
<th style="text-align:right">avg. token length</th>
<th style="text-align:right">tokens in dict</th>
<th style="text-align:right">fastest creation of dict</th>
<th style="text-align:right">fastest read of corpus</th>
<th style="text-align:left">top 10 tokens</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">English</td>
<td style="text-align:left">word</td>
<td style="text-align:right">17.3 GB</td>
<td style="text-align:right">2.8 billion</td>
<td style="text-align:right">6.2</td>
<td style="text-align:right">9.9 million</td>
<td style="text-align:right">50 seconds</td>
<td style="text-align:right">6 seconds</td>
<td style="text-align:left">the, of, and, in, to, was, is, for, on, as</td>
</tr>
<tr>
<td style="text-align:left">German</td>
<td style="text-align:left">word</td>
<td style="text-align:right">7.5 GB</td>
<td style="text-align:right">1.1 billion</td>
<td style="text-align:right">7.0</td>
<td style="text-align:right">7.8 million</td>
<td style="text-align:right">29 seconds</td>
<td style="text-align:right">2 seconds</td>
<td style="text-align:left">der, und, die, in, von, im, des, den kategorie, mit</td>
</tr>
<tr>
<td style="text-align:left">French</td>
<td style="text-align:left">word</td>
<td style="text-align:right">6.3 GB</td>
<td style="text-align:right">982 million</td>
<td style="text-align:right">6.4</td>
<td style="text-align:right">4.9 million</td>
<td style="text-align:right">25 seconds</td>
<td style="text-align:right">2 seconds</td>
<td style="text-align:left">de, la, le, et, en, du, des, les, est, un</td>
</tr>
<tr>
<td style="text-align:left">Spanish</td>
<td style="text-align:left">word</td>
<td style="text-align:right">4.8 GB</td>
<td style="text-align:right">743 million</td>
<td style="text-align:right">6.4</td>
<td style="text-align:right">4.1 million</td>
<td style="text-align:right">21 seconds</td>
<td style="text-align:right">1 second</td>
<td style="text-align:left">de, la, en, el, del, que, los, se, por, un</td>
</tr>
<tr>
<td style="text-align:left">Italian</td>
<td style="text-align:left">word</td>
<td style="text-align:right">3.9 GB</td>
<td style="text-align:right">584 million</td>
<td style="text-align:right">6.7</td>
<td style="text-align:right">3.7 million</td>
<td style="text-align:right">19 seconds</td>
<td style="text-align:right">1 second</td>
<td style="text-align:left">di, il, la, in, del, un, che, della, per, nel</td>
</tr>
<tr>
<td style="text-align:left">Portuguese</td>
<td style="text-align:left">word</td>
<td style="text-align:right">2.2 GB</td>
<td style="text-align:right">324 million</td>
<td style="text-align:right">6.7</td>
<td style="text-align:right">2.6 million</td>
<td style="text-align:right">15 seconds</td>
<td style="text-align:right">1 second</td>
<td style="text-align:left">de, em, do, da, que, no, um, com, uma, para</td>
</tr>
<tr>
<td style="text-align:left">Russian</td>
<td style="text-align:left">word</td>
<td style="text-align:right">7.8 GB</td>
<td style="text-align:right">554 million</td>
<td style="text-align:right">14.1</td>
<td style="text-align:right">6.6 million</td>
<td style="text-align:right">26 seconds</td>
<td style="text-align:right">2 seconds</td>
<td style="text-align:left">на, года, категория, по, году, из, не, был, от, за</td>
</tr>
<tr>
<td style="text-align:left">Japanese</td>
<td style="text-align:left">character</td>
<td style="text-align:right">3.1 GB</td>
<td style="text-align:right">944 million</td>
<td style="text-align:right">3.3</td>
<td style="text-align:right">1.6 million</td>
<td style="text-align:right">26 seconds</td>
<td style="text-align:right">1  second</td>
<td style="text-align:left">の, ー, ン, に, は, ス, た, ル, る, と</td>
</tr>
<tr>
<td style="text-align:left">Chinese</td>
<td style="text-align:left">character</td>
<td style="text-align:right">1.3 GB</td>
<td style="text-align:right">406 million</td>
<td style="text-align:right">3.3</td>
<td style="text-align:right">1.4 million</td>
<td style="text-align:right">48 seconds</td>
<td style="text-align:right">&lt;1 second</td>
<td style="text-align:left">的, 中, 一, 年, 大, 在, 人, 是, 有, 行</td>
</tr>
</tbody>
</table>
<p><sup>P.S.: It&rsquo;s interesting to see that the average token length in European languages is almost the same. They also share very similar words in their top 10 of the most frequently used words. One could argue that the top 10 shows how &lsquo;inefficient&rsquo; these languages are given that most top 10 words are &lsquo;low-value&rsquo; prepositions. In contrast, in Chinese, you can find nouns, verbs, and adjectives among the top 10 which arguably indicates a higher efficiency in the language.</sup></p>
<h2 id="source-code">Source code</h2>
<p>I have consolidated all code from this blog post into a project called <em>text2dict</em>. Here is the <a href="https://github.com/mmlind/text2dict/">Github repository</a>.</p>
<blockquote>
<p><em>text2dict</em> supports a command-line interface for easily converting text files to a dictionary using a user-defined number of parallel processes. It supports all methods introduced in this post. Feel free to compare results for your own hardware. Happy coding.</p>
</blockquote>
<p>Thanks for reading. Feel free to share your comments or raise any questions below.</p>
<p>&ndash;</p>

    <script src="https://utteranc.es/client.js"
        repo="mmlind/mmlind.github.io"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

  </article>
<aside class="sidebar">
  <section class="sidebar_inner">
    <h2>Matt Lind</h2>
    <div>
      Contact me if you have an interesting project, contract work, or job opportunity where I can contribute.
    </div>
    <a href = 'https://mmlind.github.io/about/' class="button mt-1" role="button">Read More</a>
    <h2 class="mt-4">Featured Posts</h2>
    <ul>
    
    
    </ul>
    <h2 class="mt-4">Recent Posts</h2>
    <ul class="flex-column">
      
      <li>
        <a href="https://mmlind.github.io/posts/how_to_synchronize_multiprocessing_access_to_shared_memory/" class="nav-link">How to simultaneously write to shared memory with multiple processes</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/migrating_blog_from_jekyl_hugo/" class="nav-link">Migrating my GitHub pages blog from Jekyl to Hugo</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/using_logistic_regression_to_solve_mnist/" class="nav-link">Using logistic regression to classify images</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/linear_regression/" class="nav-link">Understanding linear regression</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/deep_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Deep neural network for MNIST handwriting recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/simple_3-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Simple 3-layer neural network for MNIST handwriting recognition</a>
      </li>
      <li>
        <a href="https://mmlind.github.io/posts/simple_1-layer_neural_network_for_mnist_handwriting_recognition/" class="nav-link">Simple 1-layer neural network for MNIST handwriting recognition</a>
      </li>
    </ul> 
    
    
    
    
    
    
    <div>
      <h2 class="mt-4 taxonomy" id="tags-section">Tags</h2>
      <nav class="tags_nav">
        <a href='https://mmlind.github.io/tags/machine-learning/' class=" post_tag button button_translucent">
          MACHINE-LEARNING
          <span class='button_tally'>6</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/computer-vision/' class=" post_tag button button_translucent">
          COMPUTER-VISION
          <span class='button_tally'>4</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/blogging/' class=" post_tag button button_translucent">
          BLOGGING
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/c/' class=" post_tag button button_translucent">
          C
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/math/' class=" post_tag button button_translucent">
          MATH
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/multiprocessing/' class=" post_tag button button_translucent">
          MULTIPROCESSING
          <span class='button_tally'>2</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/natural-language-processing-nlp/' class=" post_tag button button_translucent">
          NATURAL-LANGUAGE-PROCESSING-NLP
          <span class='button_tally'>1</span>
        </a>
        
        <a href='https://mmlind.github.io/tags/python/' class=" post_tag button button_translucent">
          PYTHON
          <span class='button_tally'>1</span>
        </a>
        
        
      </nav>
    </div>
    
    
  </section>
</aside>

</div>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="facebook">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h151V331h-60v-90h60v-61c0-49.629 40.371-90 90-90h91v90h-91v61h91l-15 90h-76v181h121c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 18.001 18.001" id="twitter">
    <path d="M15.891 4.013c.808-.496 1.343-1.173 1.605-2.034a8.68 8.68 0 0 1-2.351.861c-.703-.756-1.593-1.14-2.66-1.14-1.043 0-1.924.366-2.643 1.078a3.56 3.56 0 0 0-1.076 2.605c0 .309.039.585.117.819-3.076-.105-5.622-1.381-7.628-3.837-.34.601-.51 1.213-.51 1.846 0 1.301.549 2.332 1.645 3.089-.625-.053-1.176-.211-1.645-.47 0 .929.273 1.705.82 2.388a3.623 3.623 0 0 0 2.115 1.291c-.312.08-.641.118-.979.118-.312 0-.533-.026-.664-.083.23.757.664 1.371 1.291 1.841a3.652 3.652 0 0 0 2.152.743C4.148 14.173 2.625 14.69.902 14.69c-.422 0-.721-.006-.902-.038 1.697 1.102 3.586 1.649 5.676 1.649 2.139 0 4.029-.542 5.674-1.626 1.645-1.078 2.859-2.408 3.639-3.974a10.77 10.77 0 0 0 1.172-4.892v-.468a7.788 7.788 0 0 0 1.84-1.921 8.142 8.142 0 0 1-2.11.593z"
      ></path>
  </symbol>
  <symbol aria-hidden="true" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="mail">
    <path  d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="calendar">
    <path d="M452 40h-24V0h-40v40H124V0H84v40H60C26.916 40 0 66.916 0 100v352c0 33.084 26.916 60 60 60h392c33.084 0 60-26.916 60-60V100c0-33.084-26.916-60-60-60zm20 412c0 11.028-8.972 20-20 20H60c-11.028 0-20-8.972-20-20V188h432v264zm0-304H40v-48c0-11.028 8.972-20 20-20h24v40h40V80h264v40h40V80h24c11.028 0 20 8.972 20 20v48z"></path>
    <path d="M76 230h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 310h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zM76 390h40v40H76zm80 0h40v40h-40zm80 0h40v40h-40zm80 0h40v40h-40zm80-80h40v40h-40z"></path>
  </symbol>
  <symbol viewBox="-21 0 512 512" xmlns="http://www.w3.org/2000/svg" id="yank">
    <path d="M410.668 405.332H165.332c-32.363 0-58.664-26.3-58.664-58.664v-288c0-32.363 26.3-58.668 58.664-58.668h181.504c21.059 0 41.687 8.535 56.555 23.445l42.496 42.496c15.125 15.125 23.445 35.223 23.445 56.575v224.152c0 32.363-26.3 58.664-58.664 58.664zM165.332 32c-14.7 0-26.664 11.969-26.664 26.668v288c0 14.7 11.965 26.664 26.664 26.664h245.336c14.7 0 26.664-11.965 26.664-26.664V122.516c0-12.82-4.992-24.871-14.059-33.942l-42.496-42.496C371.84 37.121 359.488 32 346.836 32zm0 0"></path>
    <path d="M314.668 512h-256C26.305 512 0 485.695 0 453.332V112c0-32.363 26.305-58.668 58.668-58.668h10.664c8.832 0 16 7.168 16 16s-7.168 16-16 16H58.668C43.968 85.332 32 97.301 32 112v341.332C32 468.032 43.969 480 58.668 480h256c14.7 0 26.664-11.969 26.664-26.668v-10.664c0-8.832 7.168-16 16-16s16 7.168 16 16v10.664c0 32.363-26.3 58.668-58.664 58.668zM368 181.332H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0"></path>
    <path d="M368 245.332H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 64H208c-8.832 0-16-7.168-16-16s7.168-16 16-16h160c8.832 0 16 7.168 16 16s-7.168 16-16 16zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="github">
    <path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"></path>
  </symbol>
  <symbol viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="rss">
    <circle cx="3.429" cy="20.571" r="3.429"></circle>
    <path d="M11.429 24h4.57C15.999 15.179 8.821 8.001 0 8v4.572c6.302.001 11.429 5.126 11.429 11.428z"></path>
    <path d="M24 24C24 10.766 13.234 0 0 0v4.571c10.714 0 19.43 8.714 19.43 19.429z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="linkedin">
    <path d="M437 0H75C33.648 0 0 33.648 0 75v362c0 41.352 33.648 75 75 75h362c41.352 0 75-33.648 75-75V75c0-41.352-33.648-75-75-75zM181 406h-60V196h60zm0-240h-60v-60h60zm210 240h-60V286c0-16.54-13.46-30-30-30s-30 13.46-30 30v120h-60V196h60v11.309C286.719 202.422 296.93 196 316 196c40.691.043 75 36.547 75 79.688zm0 0"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612" id="arrow">
    <path d="M604.501 440.509L325.398 134.956c-5.331-5.357-12.423-7.627-19.386-7.27-6.989-.357-14.056 1.913-19.387 7.27L7.499 440.509c-9.999 10.024-9.999 26.298 0 36.323s26.223 10.024 36.222 0l262.293-287.164L568.28 476.832c9.999 10.024 26.222 10.024 36.221 0 9.999-10.023 9.999-26.298 0-36.323z"></path>
  </symbol>
  <symbol viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" id="carly">
    <path d="M504.971 239.029L448 182.059V84c0-46.317-37.682-84-84-84h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c19.851 0 36 16.149 36 36v108c0 6.365 2.529 12.47 7.029 16.971L454.059 256l-47.029 47.029A24.002 24.002 0 0 0 400 320v108c0 19.851-16.149 36-36 36h-44c-13.255 0-24 10.745-24 24s10.745 24 24 24h44c46.318 0 84-37.683 84-84v-98.059l56.971-56.971c9.372-9.372 9.372-24.568 0-33.941zM112 192V84c0-19.851 16.149-36 36-36h44c13.255 0 24-10.745 24-24S205.255 0 192 0h-44c-46.318 0-84 37.683-84 84v98.059l-56.971 56.97c-9.373 9.373-9.373 24.568 0 33.941L64 329.941V428c0 46.317 37.682 84 84 84h44c13.255 0 24-10.745 24-24s-10.745-24-24-24h-44c-19.851 0-36-16.149-36-36V320c0-6.365-2.529-12.47-7.029-16.971L57.941 256l47.029-47.029A24.002 24.002 0 0 0 112 192z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="copy">
    <path d="M366.345 406.069H66.207c-9.751 0-17.655-7.904-17.655-17.655V17.655C48.552 7.904 56.456 0 66.207 0h300.138C376.096 0 384 7.904 384 17.655v370.759c0 9.751-7.904 17.655-17.655 17.655z" fill="#f1f4fb"></path>
    <path d="M384 388.414v-76.992c-.907.322-1.869.494-2.751.882-6.307-6.593-14.733-11.025-24.111-11.964a40.49 40.49 0 0 0-8.448.039v-92.93c0-21.903-17.82-39.723-39.723-39.724a40.5 40.5 0 0 0-4.036.202c-20.012 2.004-35.689 19.916-35.689 40.781v101.773l-21.581 21.581c-15.241 15.241-21.393 36.866-16.456 57.847l3.802 16.16h131.338c9.75 0 17.655-7.905 17.655-17.655z"
      fill="#d5dced"></path>
    <circle cx="128" cy="105.931" r="26.483" fill="#b4e66e"></circle>
    <circle cx="128" cy="203.034" r="26.483" fill="#dae169"></circle>
    <circle cx="128" cy="300.138" r="26.483" fill="#ffdc64"></circle>
    <path d="M331.034 229.517H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h141.241c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 194.207H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h105.931a8.826 8.826 0 0 1 8.828 8.828 8.826 8.826 0 0 1-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M331.034 326.621H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h141.241c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 291.31H189.793c-4.879 0-8.828-3.953-8.828-8.828s3.948-8.828 8.828-8.828h105.931c4.879 0 8.828 3.953 8.828 8.828s-3.948 8.828-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M331.034 132.414H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h141.241a8.826 8.826 0 0 1 8.828 8.828 8.826 8.826 0 0 1-8.828 8.828z" fill="#7f8499"></path>
    <path d="M295.724 97.103H189.793a8.826 8.826 0 0 1-8.828-8.828 8.826 8.826 0 0 1 8.828-8.828h105.931a8.826 8.826 0 0 1 8.828 8.828 8.825 8.825 0 0 1-8.828 8.828z" fill="#5b5d6e"></path>
    <path d="M443.656 335.563c-13.21-1.323-24.345 9.015-24.345 21.954v-7.569c0-11.544-8.306-22.063-19.794-23.213-13.209-1.323-24.344 9.015-24.344 21.954v-7.569c0-11.544-8.306-22.063-19.794-23.213-13.209-1.323-24.344 9.015-24.344 21.954V207.448c0-12.939-11.135-23.277-24.345-21.954-11.486 1.15-19.793 11.669-19.793 23.213v109.086l-26.752 26.752a44.14 44.14 0 0 0-11.754 41.32l18.47 78.495c6.567 27.913 31.475 47.64 60.15 47.64h74.645c34.127 0 61.793-27.666 61.793-61.793v-91.431c-.001-11.544-8.306-22.063-19.793-23.213z"
      fill="#f0c087"></path>
    <path d="M339.862 361.377a8.829 8.829 0 0 0 8.828-8.828v-34.194c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zM384 370.205a8.829 8.829 0 0 0 8.828-8.828v-34.194c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zm44.138 8.827a8.829 8.829 0 0 0 8.828-8.828V336.01c-10.052 2.061-17.655 10.844-17.655 21.506v12.687a8.827 8.827 0 0 0 8.827 8.829zM288.885 464.36l-20.467-86.985a28.482 28.482 0 0 1 7.585-26.663l10.893-10.894v22.113a8.829 8.829 0 0 0 17.656 0V185.933c-10.344 2.173-17.655 11.972-17.655 22.773v109.087l-26.752 26.752a44.14 44.14 0 0 0-11.754 41.32l18.47 78.495c6.567 27.913 31.475 47.64 60.15 47.64h22.026c-28.677 0-53.584-19.727-60.152-47.64z"
      fill="#e6af78"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.001 512.001" id="closeme">
    <path d="M284.286 256.002L506.143 34.144c7.811-7.811 7.811-20.475 0-28.285-7.811-7.81-20.475-7.811-28.285 0L256 227.717 34.143 5.859c-7.811-7.811-20.475-7.811-28.285 0-7.81 7.811-7.811 20.475 0 28.285l221.857 221.857L5.858 477.859c-7.811 7.811-7.811 20.475 0 28.285a19.938 19.938 0 0 0 14.143 5.857 19.94 19.94 0 0 0 14.143-5.857L256 284.287l221.857 221.857c3.905 3.905 9.024 5.857 14.143 5.857s10.237-1.952 14.143-5.857c7.811-7.811 7.811-20.475 0-28.285L284.286 256.002z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="open-menu">
    <path d="M492 236H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0-160H20C8.954 76 0 84.954 0 96s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20zm0 320H20c-11.046 0-20 8.954-20 20s8.954 20 20 20h472c11.046 0 20-8.954 20-20s-8.954-20-20-20z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="instagram">
    <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id=youtube>
    <path d="M19.615 3.184c-3.604-.246-11.631-.245-15.23 0-3.897.266-4.356 2.62-4.385 8.816.029 6.185.484 8.549 4.385 8.816 3.6.245 11.626.246 15.23 0 3.897-.266 4.356-2.62 4.385-8.816-.029-6.185-.484-8.549-4.385-8.816zm-10.615 12.816v-8l8 3.993-8 4.007z"/>
  </symbol>
</svg>
<footer class = 'footer'>
  <div class = 'footer_inner wrap pale'>
    <img src = 'https://hitcounter.pythonanywhere.com/count/tag.svg' class = 'icon icon_2 transparent'>
    <p>&lt;/&gt; &copy;&nbsp;<span class = 'year'>2020</span>&nbsp;MATT&#39;S TECH BLOG. &lt;/&gt;</p>
<a class='to_top' href="#documentTop">
  <svg class="icon">
    <use xlink:href="#arrow"></use>
  </svg>
</a>

  </div>
</footer>
    <script type="text/javascript" src = "https://mmlind.github.io/js/bundle.min.7333d63e045f01aaa61cad70ba4e3060064949b5a64c00b840c4e0c664bcdb02869222e7bde3800fe4911ccad719c06a19cb5f48c60048c0e382631fbd17cece.js" integrity=
    "sha512-czPWPgRfAaqmHK1wuk4wYAZJSbWmTAC4QMTgxmS82wKGkiLnveOAD&#43;SRHMrXGcBqGctfSMYASMDjgmMfvRfOzg==" crossorigin="anonymous"></script>
  </body>
</html>
